repository are automatically a bean if extends JpaRepository<...> (Extends PagingAndSortingRepository and adds JPA-specific features. It is the most commonly used interface because it offers the most functionality. Includes all CrudRepository and PagingAndSortingRepository methods, plus more advanced features like flush(), saveAndFlush(), and batch deletes.) or CrudRepository<...> (Extends Repository and provides basic CRUD (Create, Read, Update, Delete) operations like save(), findById(), and findAll()), etc.
One constructor in class (including lombok) means no need @Autowired, private or any access modifier doesnt affect injection or IoC.

ResponseEntity.ok(...) is to return response with 200 OK status; .created(locationUriObj) when you pass a parameter to it, it's basically like constructing ResponseEntity.status(...).header(HttpHeaders.LOCATION, "/cashcards/1").build(); and the value is obtained using response.getHeaders().getLocation() , which will be a URI. (EVEN IF USUALLY BROWSER CAN RESOLVE ABOVE SUBURL, you can SAFELY SEND BACK FULL LOCATION URL ALSO)

URI location = URI.create("/cashcards/1");

return ResponseEntity.created(location).body(resource); // build() is not required if body() is used
[OR]
return ResponseEntity
    .status(HttpStatus.CREATED)
    .header(HttpHeaders.LOCATION, location.toString())
    .body(resource);

 UriComponentsBuilder as parameter to POST method function in controller correctly got injected by IoC just like that.
---------------------
URI locationOfNewCashCard = ucb
                    .path("cashcards/{id}")
                    .buildAndExpand(savedCashCard.id())
                    .toUri();

Another BETTER way of sending back the path as URI in the ResponseEntity.created(locationOfNewCashCard).build();

YOU SHOULD'NT give Id field when creating an object using POST endpoint when it saves using repository.save(). IF
ID is configured as AUTOGENERATED (save() searches & it MAY update an entry (or error occurs) if you give an id, if not given, IT SAVES AS NEW!)

CREATE TABLE cash_card
(
    ID     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    AMOUNT NUMBER NOT NULL DEFAULT 0
);

Regardless of H2 or postgres, ofcourse if this CREATE TABLE script is either used or generated, it will ofcourse use generated value if id field is null, else it uses provided value.
------------------
@Table("cash_card")
public record Card(@Id Long id, Double amount) {}
------------------
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.datasource.url=jdbc:postgresql://localhost:5432/yourdb
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.username=youruser
spring.datasource.password=yourpass
------------------

incase there are 2 constructors in a class type (records must always have only 1 canonical constructor with all fields), then if the type is required to be converted from a json by Jackson (like if @RequestBody is used), then ERROR WILL BE THROWN TYPICALLY.
Use @JsonCreator on 1 of the constructors TO SPECIFY TO JACKSON WHICH TO USE INCASE OF MULTIPLE CONSTRUCTORS

Page<CashCard> page2 = cashCardRepository.findAll(
    PageRequest.of(
        1,  // page index for the second page - indexing starts at 0
        10, // page size (the last page might have fewer items)
        Sort.by(new Sort.Order(Sort.Direction.DESC, "amount"))
    )
);

Pageable pageable is a variable that can be injected magically in a controller function which takes the size and page query parameters in request.
Otherwise, if one of these or both isnt given, Spring provides defaults: page=0, size=20.

pageable.getPageNumber(),
pageable.getPageSize(),
pageable.getSortOr(Sort.by(Sort.Direction.DESC, "amount"))));  //Yep this is correct , either uses given in url else the default specified here.

///Example queries which will be given to Pageable obj in controller func: cashcards?page=1&size=3&sort=amount,desc
(The comma cannot have spaces before and after...)

@DirtiesContext on a method and @DirtiesContext(classMode = ClassMode.AFTER_EACH_TEST_METHOD) on the test class can help to clean the data after each test if it makes a permanent change (former is for 1 specific method , whereas latter applies to ALL test methods)
(like if a card is added in a test for next test it can be undone)

Additional for paging support you need to extend this repository:
interface CashCardRepository extends CrudRepository<CashCard, Long>, PagingAndSortingRepository<CashCard, Long> { ... }

Repository<T, ID> (Marker Interface) <- CrudRepository<T, ID> (CRUD operations) <- PagingAndSortingRepository<T, ID>(pagination + sorting) <- JpaRepository<T, ID>(JPA-specific + batch ops)

Spring Security (works via Role-Based Access Control (RBAC) , which is self explainatory): Token types, Bearer token authentication, CSRF token (Cross-Site Request Forgery token)

Filter Chain in springboot helps to define methods to be executed before controllers to ensure the requests are authenticated, else send back 401 UNAUTHORIZED.

@CrossOrigin - used on controller (or its methods) to specify the urls to allow cross origin requests,& if args not give, it ALLOWS ALL ORIGINS!
	       ("Origin" header is supposed to be set by the browser with CORS protocol enabled, so spring checks that.)

Cross-Site Request Forgery - involves cookie token to be used and sent trying to impersonate, therefore a specially dedicated CSRF token generated is recommended.
			     (Basically autogenerated token sent by server and later again by client like a secret password since COOKIES ARE UNSAFE AND OTHER WEBSITE CAN USE IT TO ACCESS
			      since IF COOKIES IS IN BROWSER AND A HIDDEN FORM IS PRESENT IN MALICIOUS WEBSITE AND FORCED TO SUBMIT, then RELEVANT COOKIES BROWSER WILL SEND TOO!!!
			     But this token was NEVER SENT OR RECEiVED IN COOKIES SO IT WONT HAVE TOKEN VALUE, so only in http headers or body its shared, thats all, simple.)

Cross-Site Scripting - if a script goes in the raw form to a user's client app, and due to poor programming practices its not cleaned properly,
		       It might potentially be used by the client app to run inadvertantly the script if the script is injected/used directly in the app's frontend code.
If say js code chunk is not cleaned and directly rendered in a webpage, unwanted scripts can be executed. Properly data should be escaped accordingly and no loop holes. (like < character as &lt;)

----------------------------
Principal principal in controller is a method argument, provided automatically by Spring Security.
Same as Pageable

Spring security always returns 403 forbidden if that mapping/suburl doesnt exist so it doesnt reveal by mistake any useful info.
delete (Atleast in CRUD repository)

[401 means "DONT EVEN KNOW WHO YOU ARE", whereas
 403 means "EITHER I KNOW WHO YOU ARE BUT YOU CAN'T ACCESS THIS, OR GIVEN SUBURL MIGHT NOT EVEN EXIST"] (Spring Security conceals suburls by this)

Note: Have to explore how repository interface we just type method name and it correctly does the queries behind the scenes.

URI (Uniform Resource Identifier): Identifies a resource — can be a name, location, or both. Example: urn:isbn:9780134685991
URL (Uniform Resource Locator)   : A type of URI that tells you how to locate a resource.    Example: https://example.com/page

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Spring Framework Essentials : -


ApplicationContext context = SpringApplication.run(ApplicationConfig.class);

TransferService service = context.getBean("transferService" , TransferService.class); // one of the parameter is enough too
// only first param means RETURN TYPE WILL BE OF TYPE Object (just typecast thats all) , only with 2nd param it gives directly correct type.
   And also, the class name of the bean just make FIRST LETTER LOWERCASE, that WILL BE THE BEAN NAME TO SUPPLY as FIRST PARAM.

// If there is no other beans returning that type or being that type, then 2nd param ALONE CAN BE ENOUGH.


@Configuration
@Import({ApplicationConfig.class, WebConfig.class}) // To not repeat config classes, basically extending config classes so common stuff is shared.
public class TestInfraConfig {
@Bean // Can also be @Bean(name="dataSource") incase method name had to be different
public TransferService transferService(AccountRepository){
		return new TransferServiceImpl(repository);
	}
}


If TransferServiceImpl is annotated as some bean annotation, then since no other type other than this extends TransferService,
Spring automatically will inject this where TransferService interface type is used.
If multiple contenders, then @Qualifier should be used on the place you want it to be injected with unlike @Primary.
@Qualifier("xxxService") is used AT THE INJECTION POINT to clarify among various contenders (OVERRIDES @Primary easily).

Incase there is cyclic dependency and cant be resolved design wise, then use @Lazy like:

public Constructor(@Lazy Service2 s, ...){} // This will atleast break cycle delaying the MANDATORY req that Service2 is to be injected immediately.
							  // It will basically not fully initalize properly and then after that will inject this bean.


Bean Scopes: -

@Scope("singleton") - Only once instance is created

Issues when it maintains any state/mutable type. Then THREADSAFE stuff should be done.(syncronizing etc)
Better only use for immutable or stateless beans.


@Scope("prototype") - Everytime it's referenced, a new instance is created.

Like context.getBean() if you use to get bean twice, THEN TWO NEW INSTANCES CREATED!
But in springBOOT, difference is: 

//CHANGED HERE
Note: WHETHER PROTOTYPE SCOPED BEAN IS INJECTED IN SINGLETON/ another PROTOTYPE BEAN,
      EVERY SINGLE INJECTION POINT of fields, methods, constructors or getBean() methods regardless of context,
      A NEW OBJECT IS CREATED EACH TIME! (So yes, prototype A injected x times in another prototype bean B means for every injection of B somewhere else, x NEW objs of A are created!!!)

WARNING: 2 Prototype beans INJECTED IN EACH OTHER MIGHT CAUSE A CRASH


@Scope("session") - Instance is created once PER USER SESSION (Web environment ONLY)
@Scope("request") - Instance is created once PER Request (Web environment ONLY)

//CHANGED HERE
But usually these 2 beans wont be created at startup of app, so IF there isn't any request or session yet HOW WILL THESE SCOPED BEANS BE CREATED?? cant simply give dead instance to
singleton bean. Instead give proxy which will give correct bean by redirecting: @SessionScope/@RequestScope OR @Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS) on bean.
proxyMode = ScopedProxyMode.INTERFACES [OR] .TARGET_CLASS can also be an option to @Scope to specify jdk or cglib. (other cases if interface injection points, it uses jdk else cglib)

Vanilla Spring uses jdk proxies as first preference but Springboot tries cglib first as spring.aop.proxy-target-class=true as default value.
WARNING: NEVER MIX AND MATCH INTERFACE AND IMPL CLASS INJECTION POINTS FOR THE SAME BEAN. like it creates 1 single proxy and it HAS to be compatible with al injection points. Dont confuse.



Web Socket Scope, Refresh Scope, Thread Scope (this one maybe not native) , or even custom scopes rarely are used and exist.


A bean should be named like accountRepository , and should return only the interface type (AccountRepository),
Not the implementation class's type, by polymorphism return ofc. Its a standard.


@Bean
public DataSource dataSource(Environment env) //Is a bean an easily injected like other beans.
{
	BasicDataSource ds = new BasicDataSource();
	ds.setDriverClassName(env.getProperty("db.driver")); //Takes from application.properties or somme other prop. file
	...
}

The env.getProperty("key") is used to get value from these below sources (DESCENDING ORDER of precedence):

Command-line arguments: Arguments passed to the application at startup (--server.port=9000) 
JVM system properties (System.setProperty AND -Dserver.port=8080 kind of properties)
OS environment variables
Profile-specific files (e.g., application-dev.properties) overrides the general application.properties)
Config files (application.properties, application.yml)
(.properties overrides .yml if both have same key IF IN SAME DIR)
Any custom property sources registered via annotations or code (@PropertySource)
SpringApplication.setDefaultProperties() [Default properties]

Among same precedence property files, if specified like below 3 ways,
THE LATER FILE OVERRIDES the LEFT FILES! : -

@PropertySource({"classpath:fileA.properties", "classpath:fileB.properties"})
OR
@PropertySource("classpath:fileA.properties")
@PropertySource("classpath:fileB.properties")
OR
spring.config.additional-location=classpath:/fileA.properties,classpath:/fileB.properties


//CHANGED HERE SLIGHTLY
[ CAN ALSO USE "file:..." or "http:..." prefixes to get the property files using absolute/relative path.
classpath: is used like classpath:/com/sagent/daradefault/resources/application.properties , file: is as expected searching in the CURRENT WORKING DIRECTORY (CWD).
IF you dont use these 3 prefixes and mention @PropertySource("application.properties") or so,
It NON RECURSIVELY searches in classpath folders like src/main/resources/cloud.properties for it,
AS IT TAKES IT AS RELATIVE PATH TO CLASSPATH's resource folder]

@TestPropertySource DIFFERS IN BEHAVIOUR WHEN YOU GIVE FILE NAME with NO SLASH like "test.properties", hen in test IT CHECKS SAME PACKAGE AS TEST CLASS,
but here IN @PROPERTYSOURCE it CHECKS THE SAME CLASSPATH FOLDER.

Can check order too: 
((AbstractEnvironment) env).getPropertySources() gives the order of loading the property files in descending order of precedence.


Alternate to using env.getProperty(), use: -
@Value("${db.driver}")


Profiles: -
Actually Beans belong or not belong to profiles,
Like DataSource bean can be many but dev has one, and production uses another bean similar though.
 aSo profile just categorizes beans (and usual beans is common to all).

@Profile("cloud") - CAN BE USED ON ANY BEAN so the bean is only available in context IF ITS IN THAT MENTIONED PROFILE!
@Profile("!cloud") - Means initialized when profile IS NOT "cloud"

Also, if you wanted say 2 DataSource beans in same class, one for cloud and one for local profiles,
function names can be different, so BEAN NAME WILL ALSO CHANGE RIGHT since overloading not possible? (same method signature)
So to EXPLICITLY mention @Bean(name="dataSource") for both.


Ways to activate profile(s): (YES, CAN ACTIVATE MULTIPLE)
-Dspring.profiles.active=embedded,jpa
OR
System.setProperty("spring.profiles.active","embedded,jpa");
(SpringApplication.run(AppConfig.class) is THEN ONLY RUN)
OR for Integration testing: @ActiveProfiles annotation is used (later we will see)


Using   @Profile("cloud")
	@PropertySource("cloud.properties")
on a configuration class means NOT ONLY that configuration will only have beans initialized in that particular profiles,
ONLY IN THE PARTICULAR PROFILE(S) THE PROPERTY SOURCE MENTIONED ALSO IS INCLUDED!!! (yes it has influence on fellow annotation BECAUSE THE ENTIRE BEAN WILL BE LEFT OUT IF NOT CORRECT PROFILE, meaning propertysource annotation wont take effect)


Fun fact: Most annotations the order applied on same thing usually doesnt matter, especially class annotations never at all,
Maybe exceptions like : method-level annotations in JUnit 4, or when using annotation processors that care about order



Spring Expression Language : -

@Value("#{ systemProperties[user.region] }")
//Can annotate this on a class field OR EVEN A METHOD PARAM too.

To fetch a field value, the main obj has to be a bean to be access by SEL.


TRICKY WEIRD NAMING BEHAVIOUR WARNING : -
class StrategyBean{
private KeyGenerator gen = KeyGenerator.getInstance("Blowfish");
public KeyGenerator getKeyGenerator(){return gen;};
}

@Configuration
class StrategyConfig {
@Bean public StrategyBean strategyBean(){
return new StrategyBean();
}
}

If used on class field, the property name "keyGenerator" is used DESPITE THE METHOD NAME OR VARIABLE NAME IN StrategyBean NOT MATCHING.

@Value("#{strategyBean.keyGenerator}")
KeyGenerator kgen;

Reason is, first you specify the bean (aka StrategyBean, which is declared in StrategyConfig as a method,
You DONT have to always declare StrategyBean as a @Bean on the class declaration itself. Instead a method generating the object is in Config class, thats enough).

Now if you try using ".keyGenerator" asking the bean using SEL, it will FIRST:
search for a accessible getter method with proper naming convention, aka here its "getKeyGenerator()"
THEN IF IT FAILS TO, then searches for AN ACCESSIBLE FIELD IN THE Bean's class with EXACT SAME NAME,
aka field in StrategyBean class called keyGenerator is searched for, but since getter is there, field name being different is ok.

REMEMBER, THE GETTER OR FIELD (Whichever is gonna be taken) HAS TO HAVE GOOD ACCESS SPECIFIER. (Obviously not private access level)
Like, if @Value("#{...}") is done in another class which is IN SAME PACKAGE as StrategyBean,
THEN default access/package-private access to the getter or variable IS ENOUGH! OR ELSE INJECTION WILL FAIL AT RUNTIME!!!


@Value("${daily.limit}") IS EQUIVALENT TO @Value("#{environment['daily.limit']}")   [$ symbol is for getting property/env value, # can have expressions]

//CHANGED HERE

NOTE: Below table shows whats the use of diff beans for fetching properties INSIDE SpEL

Variable 		Scope			Type			Precedence
----------------------------------------------------------------------------------------------------------
systemProperties	JVM / -D args		Map			High
systemEnvironment	OS / Shell		Map			Low
environment		Unified Spring Context	Environment object	Universal (searches both + files)

If you want to find a property regardless of whether it's in a .properties file, an OS variable, or a -D flag, use environment or the simple ${key} placeholder. Only use systemProperties or systemEnvironment if you want to force the value to come specifically from that one source.

WARNING: Single quotes '' INSIDE environment INSIDE SpEL expression IS MANDATORY whereas OPTIONAL INCASE OF systemProperties and systemEnvironment, BUT WONT HURT.


And YES, @Value("#{new Integer(environment['daily.limit']) * 2}") IS PERFECTLY FINE!

Just remember to have valid usage of the value from environment AS IT IS A STRING,
IT HAS TO BE CONVERTED TO BE USED AS INTEGER, etc. , IF NEEDED THAT IS.


@Value("${daily.limit : 100000}") IS EQUIVALENT TO @Value("#{environment['daily.limit'] ?: 100000}")
The ':' operator in ${...} and '?:' operator in #{...} BASICALLY DOES THE SAME THING EQUIVALENTLY.
They are " IS NOT NULL, ELSE " operator. Basically they help specify DEFAULT VALUES INCASE property is null.


REMEMBER: @Autowired is STILL REQUIRED even if all paramters of constructor is annotated with @Value, like ofcourse if only 1 constructor is there,
THen no need of autowired because IMPLCITLY its assumed. But generally Autowired is implcitly or explicitly needed at minimum to ATLEAST INDICATE
WHICH CONSTRUCTOR TO USE.

spEL can do this and all as below, whereas EL is more basic: 
@Value("#{T(java.lang.Math).random() * 100}") // where the T() ensures java.lang.Math is seen as a type/class, NOT as 'java' bean with member lang.Math


Annotation-based Configuration: -
@Component if you annotate on a class,
If you annotate @ComponentScan("com.package") on the CONFIG class,
It will search the (sub)package(s) specified and whichever classes have this @Component it will take as Bean adding to application context.
(If no package/argument given, just @ComponentScan, it takes the config class's package and scans inside that for beans ALONE. (its bad if package is only for config))


3 Types of injections: (Ensure NEVER to create object of such a class using new keyword, or else everything expected to be injected will be null)
* Constructor injection (only needs @Autowired if 2 resultant constructors are there, and injects dependency into only paramterized constructor params ofcourse)
* Method injection (same way as constructor, but @Autowired(required=false) can be done if ITS OK for dependency bean not to exist to be available for injection)
* Field injection (directly injects into obj's class's fields if annotated, even if private variable (but bad for unit testing).)

Setter injection preferred only maybe if circular dependency should be resolved, (@Lazy can help too, but it wont let circular dep. beans to be initialized UNTIL ITS ACCESSED)
Constructor injection doesnt let that happen, atleast easily. setters will get injected after constructors, so by then objects are created,
WHY WILL SPRING CARE ABOUT CIRCULAR DEPENDENCIES WHEN NOW IT CAN FREELY INJECT using setters since all are created by then...got it? so thats one senario setter injections are helpful.

In method injection, Optional<...> IS ALSO ALLOWED TO BE INJECTED, as IT WILL UNDERSTAND THAT BEAN IS TO BE INJECTED IN OPTIONAL FORM!!!, like below line:
@Autowired public void setAccountService(Optional<AccountService> accountService){...}	//Injects Optional.empty()

@Qualifier: -
public TransferServiceImpl(@Qualifier("jdbcAccountRepository") AccountRepository accountRepository){} // Qualifier takes the bean name, not class name.
Above code ensures to disambiguate which bean to inject IF THERE EXISTS 2 CLASSES WITH @Component annotation EXTENDING AccountRepository.
YOU HAVE TO ANNOTATE @Qualifier(...) on the literal parameter or field itself, not on method or class.


Finally it couldnt find EXACTLY 1 bean by type or @Qualifier isnt an option, IT CHECKS THE VARIABLE NAME (like "accountRepository" above, takes the variable name as last resort.)

@Lazy should ONLY be used as worst case senario if the Bean REALLY wont be able to be created during startup while other beans are eagarly created immediately.
@Component("beanName") can also be used to give different name for bean name.
@Lazy(true) and @Lazy is same, only @Lazy(false) means its not lazy initialized.


Autowiring Constructors: -
Default constructor or only one constructor is there means @Autowired isnt necessary.
Even if more than one constructor is there, if there is ZERO-ARGUMENT CONSTRUCTOR DEFINED IT USES THAT EVEN IF THERE IS OTHER CONSTRUCTORS.
ELSE, THEN @Autowired IS MANDATORY ON ONE OF THE CONSTRUCTORS.

//CHANGED HERE
WARNING: Annotating @Autowired(required = false) on multiple constructors means IT TAKES THE ONE WITH MOST NUMBER OF PARAMETERS!


Vaguely mentioning @ComponentScan({"org","com"}) is TERRIBLE PRACTICE as too many components wil be searched for (EVEN IN JAR DEPENDENCIES)
Best specify very accurately like "com.bank.app.repository", etc.

(Can do java configurations to avoid spring annotations directly sometimes (if you want to decouple spring directly from main code) BUT NOT ALWAYS POSSIBLE)

Startup and Shutdown behaviours: -
@PostConstruct() - If annotated on a method, AFTER CONSTRUCTOR AND SETTER INJECTIONS ARE DONE in the class, THEN it's executed (incase it needs those objects injected first).
@PreDestroy() - If (ConfigurableApplicationContext is the type) context.close() or basically context is being closed/ended NORMALLY!, (not if it died or was killed)
		    All methods with this annotation will be executed in all the bean classes,
		    EXCEPT Beans SCOPED WITH "prototype", AS ANYWAYS NEW BEAN IS CREATED EVERYTIME it has to be injected at some place.

Incase for some reason you cant or dont want to annotate inside the class , you can specify such methods in @Bean itself! : -
@Bean(initMethod="populateCache", destroyMethod="flushCache")

ConfigurableApplicationContext registers a shutdownHook in JVM, so any graceful shutdown way like System.exit() or Runtime.exit() can trigger context to run PreDestroy methods.


Stereotype & Meta Annotations: -
@Service, @Repository, @Configuration, @Controller, @RestController are basically @Component extended annotations with stereotypes associated with them (like additional properties).

YES YOU CAN CREATE A META ANNOTATION YOURSELF. Eg: @MyTransactionalService if you want to annotate on a class,

import java.lang.annotation.*;

@Target(ElementType.TYPE) // Where it can be used (.METHOD, .FIELD, etc., here TYPE means 4 things it can be used on: class, interface, enum, annotation type)
@Retention(RetentionPolicy.RUNTIME) // Available at runtime (most used), sometimes can use .CLASS (available in .class fiels but not runtime, eg: For frameworks which will see the annotation in compiled classes), or .SOURCE (just in typed source code alone, eg: for just documentation)

public @interface MyAnnotation { } // Marker annotation, no members, @interface is similar to defining an interface, but it’s specifically for annotations.

[OR]

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Service // Makes the class a Spring service bean
@Transactional(timeout=60) // Makes all methods transactional with 60s time limit
public @interface MyAnnotation {     
    String description() default ""; // To have variables in annotation to specify, default values can be given.
    int order() default 0;
}

Below code/function is called for EVERY Bean, and incase it DOES HAVE THAT ANNOTATION, if condition below is executed, and stuff happens. This is how custom annoations can be useful.

@Component // Registers this processor as a Spring bean
public class MyAnnotationProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        // Check if the bean's class has your custom annotation
        MyAnnotation annotation = bean.getClass().getAnnotation(MyAnnotation.class);
        if (annotation != null) {
            System.out.println("Bean '" + beanName + "' has MyAnnotation:");
            System.out.println("  Description: " + annotation.description());
            System.out.println("  Order: " + annotation.order());
        }
        return bean;
    }
}


---------------------------------
Unrelated : -
javadocs basically can help tools to scan code and create html document with details of the classes.
@param — describes a method parameter
@return — describes the return value
@throws or @exception — describes exceptions thrown
@see — refers to related classes or methods
@author, @version — author and version info
Eg: 
/**
     * Creates a new customer.
     * @param name the customer's name
     * @param age the customer's age
     */
    public Customer(String name, int age) {
        this.name = name;
        this.age = age;
    }

    /**
     * Gets the customer's name.
     * @return the name
     */
    public String getName() {
        return name;
    }
}
---------------------------------


Bean LifeCycle Phases: Initializing, Usage, Destruction.


Spring Bean Lifecycle (in order):

1. Load & Process Bean Definitions

@Configuration classes processed
@Component classes scanned
Bean definitions added to BeanFactory (ApplicationContext extends BeanFactory)

2. BeanFactoryPostProcessor Phase

All BeanFactoryPostProcessor beans run (can modify bean definitions before beans are created)
public class BeanFactoryPostProcessorImpl implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableBeanFactory beanFactory) {
        // custom logic to modify bean definitions
    }
}


//CHANGED HERE (FULL SECTION)
3. Bean Creation

Dependencies resolved
Beans instantiated (constructor first, then setter/field injection after this but before BeanPostProcessor )
If @Lazy, bean is created only when needed

4. BeanPostProcessor Phase (instance-level) [This IS Initializing PHASE]

All BeanPostProcessor beans run for each bean:

* postProcessBeforeInitialization(bean, beanName)

* Bean init methods:
	@PostConstruct method (COMES FIRST BEFORE init-method)
	@Resource injection (both enabled by CommonAnnotationBeanPostProcessor)
	init-method (if configured)

* postProcessAfterInitialization(bean, beanName)


public interface BeanPostProcessor { //has to be implemented and that impl class has to be @Component
    Object postProcessBeforeInitialization(Object bean, String beanName);
    Object postProcessAfterInitialization(Object bean, String beanName);
}


5. Bean Usage

Beans are ready for use in the application

6. Bean Destruction

When context closes:
@PreDestroy method
destroy-method (if configured)


----------------------
NOTES: -

Static @Bean methods:
Use for beans that must be created before any other beans (e.g., custom BeanFactoryPostProcessor).
Eg: @Bean
    public static BeanFactoryPostProcessor myConfigurer() { ... }


PropertySourcesPlaceholderConfigurer

Spring 4.3+: auto-configured for value resolution
Older Spring: must configure manually


Java Config      : Read all @Bean annotated method signatures | BeanFactoryPostProcessor | Call @Bean method implementations | BeanPostProcessor
VS
Annotation Config: @Component Scanning | BeanFactoryPostProcessor | Instantiation (@Autowired constructor, then injection into @Autowired methods, fields) | BeanPostProcessor

----------------------

Usage Phase : -

If Bean already in context normally and required as a raw Object, its retrieved just like that if required.

But if a proxy is required like in the case of Transations, Security, Exceptions, etc.,
Then the Bean method/class isnt DIRECTLY used to supply a Bean.
It has a middleman like proxy between actual impl. bean and the caller/requirer.

This proxy creation is usually done in the BeanPostProcessor using the method: public Object postProcessAfterInitialization(Object,String)
This method WILL RETURN A PROXY OF THE OBJECT SUPPLIED IF REQUIRED by our logic.


Spring Boot: Proxy Beans Cheat Sheet

What is a Proxy Bean?

A proxy bean is a wrapper around your actual bean.
Spring uses proxies to add features like AOP (logging, transactions, security) without changing your code.
When you use annotations like @Transactional, @Async, @Cacheable, or AOP advices, Spring wraps your bean in a proxy.
The proxy intercepts method calls and adds extra behavior before/after/instead of your method.

Types of Proxies:

JDK Proxy (Inbuilt in JDK, also called dynamic proxies):
Used if your bean implements an interface.
Proxy implements the same interfaces as impl bean.

CGLIB Proxy (Spring jars have this):
Used if your bean does not implement an interface and/or if injection point directly has impl class type required.
Proxy subclasses your bean.
Cannot be applied for final classes or methods.

Example:
When you inject MyService, Spring actually gives you a proxy object.
When you call doSomething(), the proxy starts a transaction, calls your method, then commits/rolls back.
(SpringTransactionInterceptor intercepts and TransactionManager handles rollbacks/commits ofcourse)

How to See a Proxy Bean?
Print the bean’s class:
The class name will show CGLIB or Proxy in it.

System.out.println(myService.getClass());
// Output: class com.example.MyService$$EnhancerBySpringCGLIB$$...

Limitations:

Only public methods are proxied.
Self-invocation (calling another method in the same bean) does not go through the proxy.
Final methods/classes cannot be proxied by CGLIB.

Why Use Proxies? :
Add cross-cutting concerns (transactions, security, logging) transparently.
Decouple business logic from infrastructure concerns.
--------------------------------------------------------------------------

Destruction Phase: -

ConfigurableApplicationContext context = //Get it from somewhere ;
context.close(); 
//will close context and trigger this phase

Any @PreDestroy (or destroy-method) method of Beans are invoked, then beans are released, and Garbage Collector will destroy them.

IMPORTANT: THIS DESTRUCTION PHASE ITSELF DOES NOT APPLY TO "prototype" scoped beans ALONE, EVERY SINGLE OTHER SCOPED Beans,
	   SPRING WILL MANAGE THEIR LIFECYCLE FULLY, but for prototype scoped beans, IT CREATES AND SIMPLY HANDS OVER FULL RESPONSIBILITY (to deallocate/destroy/etc) TO YOU.
	   Rest of the instantiation and usage (including proxy behaviour) all is SAME FOR prototype beans.

WILL NOT DO THIS PHASE IF APP ISNT SHUT DOWN GRACEFULLY, like killed or terminated.

---------

@DependsOn("beanName") on a bean (class) definition is JUST AN EXPLICIT way to say what Bean dependencies this class needs. (NO need for spring actually, but its just explicit simply)

2 Different Configuration types:

Java config: Takes bean name from method name, or name/value attribute. Type is taken from method return type.
Annotation-based Config: From Annotation value attr (we can give name as param @Bean(name="sampleBean")), Type is the class type.

One main difference is Java config typically RETURNS INTERFACE TYPE as method return type, NOT implementation class type.
But Annotation-based Config ALWAYS RETURNS THE EXACT Impl class TYPE as it has no choice since impl class is the one annotated.


Best Practices:
* Best for bean methods to return INTERFACE TYPES EXCEPT where multiple interfaces exist,
  and BOTH types WILL BE NEEDED for INJECTION. Then think about it, assume X implements A,B ,
  means if both A and B are expected to be injected somewhere, then 2 Bean methods or something has to be declared,
  Unless then alone you HAVE TO RETURN IMPL. TYPE INSTEAD so this 1 bean method alone will suffice for A and B injection places.

* Still for the "to be injected" spots, LET INTERFACE TYPES BE THERE to be injected.
  (Incase bean was proxied (Actual class name itself might be different) or different implementation object was returned as Bean in further development, IT WILL NOT COMPILE right)


--------------------------------------
AOP: -
Aspect-Oriented Programming is sort of a set of best practices, which enables modularization (module=class in java) of cross-cutting concerns.
Example: below concerns should ideally be as one modular class instead of being done FOR EVERY SINGLE CLASS/METHOD (or in many basically):
Logging & Tracing, Transaction Management, Security, Caching, Error Handling, Performance Monitoring, Custom Business Rules.


Without Cross Cutting Concerns, it leads to 2 problems:
* Code tangling (basically tightly coupled code with overlayed concepts like security, error handling, etc)
* Code Scattering (Exact same concern with duplicated code in several methods / classes)

Example:
if(!hasPermission(SecurityContext.getPrincipal())){throw new AccessDeniedException();}
This code could be added to several controller or service methods and UNNECESSARY duplication occurs with TIGHT COUPLING SECURITY WITH APP LOGIC.

2 APO Technologies:
AspectJ :
* Original AOP Technology (first version in 1995)
* Uses bytecode modification for aspect weaving
* A full blown AOP language

Spring AOP (focus of this session) :
* Java-based AOP framework with AspectJ integration.
* Focuses on using AOP to solve enterprise problems.

Spring AOP concepts in true layman's terms:

Join Point:
A spot in your code where something can happen (like calling a method, or exception might be thrown there).

PointCut:
An expression (filter) that says "only do something if methods matching this pattern of methodname does this specified action (eg: execution of method)."

Advice:
The lines of code to execute based on Pointcut (filter). (like logging, checking, or changing).

Aspect:
PointCut + Advice encapsulated in 1 module/class (like pair(s) of these 2 inside a class meant for AOP, that class can be called an Aspect).

Weaving:
The act of mixing your aspects are mixed into your regular code at the right spots.


AOP Proxy: An "enhanced" class that stands in place of original, having extra behaviour of aspects WOVEN INTO IT!
(Usually uses CGLIB or in interface cases and final class beans, JDK dynamic proxies also used, as previously learnt.)

NOTE: some cases both proxies cant be used, like class is final means CGLIB cant be used, and if it doesnt implement interface, jdk dynamic proxy also cant be used. 
If you use such proxies, reason why Interface is required at injection point is, a new class with new name (with Aspect features or other stuff) will be there internally, if you had injected SPECIFICALLY your impl class somewhere, it might fail as its possibly different class. (mainly JDK proxy case I mean, as it could have same interface class but its not related to impl class directly...)


@Aspect // Aspect Annotation: Declares as an aspect class
@Component
public class PropertyChangeTracker {
	@Before("execution(void set*(*))") //Aspect Annotation: Basically filters all methods where any param can be there but func name starts with "set", and void return type
	public void trackChange(){
		//Do something here BEFORE any void set.... method is executed.
	}
}

@Configuration
@EnableAspectJAutoProxy
@ComponentScan(basePackages="com.example.aspects") //Component scan always required right? unless it @Import another config which already has componentscan
public class AspectConfig {}

@Configuration
@Import(AspectConfig.class) //NOW EVERY SINGLE BEAN, regardless if declared inside this config or not, IF INJECTED, IT WILL BE SCANNED BY ASPECT FOR A MATCHING METHOD, and DOES ACTION IF REQUIRED!
public class MainConfig{
@Bean public Cache cacheA(){return new SimpleCache("cacheA");} 
@Bean public Cache cacheB(){return new SimpleCache("cacheB");}
@Bean public Cache cacheC(){return new SimpleCache("cacheC");}
}

@Autowired
@Qualifier("cacheA")
private Cache cache; // Use @Qualifier("cacheA") on @Autowired additionally to specify incase multiple beans with same type but different beanNames (here,its function names as bean names) exist.
...
If cache.setCacheSize(2500); // That aspect expression should catch this and print the log it specifies.


Spring creates proxy bean 'weaving' aspect & target,  implements target's interface like the bean (TAKES AND PROXIES ONLY INTERFACE METHODS, NOT ALL THE ONES IN IMPLEMENTATION).
All calls are routed through proxy interceptor.
The Matching advice for any Aspect's PointCut is executed if condition is true, as interceptor intercepts each incoming calls.
Target bean's method is executed and returns value as expected along with matching aspect functionality also accordingly (Before or After).
			
		   _____Spring_AOP_Proxy____________________________________
incoming	   |  _____________________	 _______________________   |
-------------------|->| Method Interceptor|----->| SimpleCache (target)|   |
<------------------|--|___________________|<-----|_____________________|   |
outgoing return    |__________^__|______________________________|__________|
			      |  |				|  |
		     _________|__v_________________	   _____v__v_____________
		    |PropertyChangeTracker(Aspect) |	   |<<interface>> Cache |   (Spring AOP Proxy and SimpleCache both implement same interface)
		    |______________________________|	   |____________________|



NOTE: Only methods declared in the interface Cache are proxied.
If your implementation class SimpleCache has an extra set... method not in the interface, the aspect will not be applied to that method.
The aspect will work on the other set... methods that are declared in the interface.

(But in CGLIB where interfaces arent declared to be implemented, if subclass is used, then this problem WONT BE THERE. But if interface it implements and has to be inejcted as interface type IN PURE SPRING, dynamic proxy is used as default and this problem will be there.)


@Aspect
@Component
public class PropertyChangeTracker {
	@Before("execution(void set*(*))")
	public void trackChange(JoinPoint point) //Autoinjected
	{
		String methodName = point.getSignature().getName(); //gets method name of the JoinPoint, aka method call.
		Object paramValue = point.getArgs()[0];		    //gets method param values of same call.
		String beanName = point.getTarget();		    //Gets Bean name of the non-proxied original bean.
	}
}


Common Pointcut Designator:
execution( <method pattern> ) - matches method
Can also CHAIN TOGETHER to create composite pointcuts using && , || and ! (not).
eg: execution(<pattern1>) || execution(<pattern2>)

<method pattern> = [Modifiers] ReturnType [ClassType] MethodName (Arguments) [throws ExceptionType]

Wildcard *  matches once (returntype, package, class, method name, argument)
Wildcard .. matches zero or more (arguments or packages)

For Example, Incase of : execution(@javax.annotation.security.RolesAllowed * rewards.restaurant.*Service.find*(..))

execution    ( @javax.annotation.security.RolesAllowed      *        rewards.restaurant .  *Service  .  find*     (..)         )
[designator]   [annotation]                            [returntype]  [package]		   [class]	[method]  [arguments]

Examples:
* execution(void send*(rewards.Dining)) - Any method, with name starting with "send" that takes a single Dining type parameter with void return type. Note: IF fully qualified type is mentioned, just ensure the single method param is of Dining type from reward PACKAGE ONLY.
* execution(* send(*)) - Any method called send which takes A SINGLE PARAMETER! (* DOES NOT MEAN MULTIPLE PARAMS LIKE REGEX)
* execution(* send(int,..)) - Any method called send whose first parameter is an int type, and 0 OR more parameters may follow.
* execution(void example.MessageServiceImpl.*(..)) - Any void method in the MessageServiceImpl class and in MOST CASES subclass object method access also triggers this.
  [HUGE DOUBT: Please refer foot NOTES for the massive explanation.]
* execution(void example.MessageService.send(*)) - ANY METHOD from class implementing MessageService INTERFACE WILL TRIGGER by this exp.

Note: you cant start a expression phrase with '..' like atleast '*..' is required Like expression(* ..restaurant.*.*(..)) IS WRONG!!!
Instead add a * just before .. to make it legal.


Advice TYPES: -

Before: In this @Before type of Aspect Advice, if an EXCEPTION is thrown, YOU CAN PREVENT THE TARGET METHOD FROM BEING EXECUTED! (useful security feature)

The other types of Aspect annotations available are:
@Before — before method execution
@After — after method execution (always executes)

@AfterReturning — after successful return

Eg: @AfterReturning(
    value = "execution(* rewards.internal.*.*(..))",
    returning = "result"
)
    public void afterReturningAdvice(JoinPoint joinPoint, ReturnType result) {}

WARNING: APART FROM MATCHING METHOD's RETURN TYPE in expression, ASPECT ALSO WONT BE TRIGGERED IF THE PARAMETER pointed to by 'returning' in annotation, of this advice method parameter, IS NOT OF THE SAME RETURNTYPE AS THE METHOD MATCHED. [BUT POLYMORPHIC IMPLICIT ASSIGNMENT IS ACCEPTS AND ASPECT WILL TRIGGER if aspect returntype here is SUPERCLASS type of the one returned!]
Also, the 'returning' variable name specified in annotation should EXACTLY match a variable name in this advice method ELSE RUNTIME EXCEPTION WILL OCCUR. Just that if type of that variable in this above advice method param is different means method wont be matched DESPITE EXPRESSION DOES MATCH OR NOT.


@AfterThrowing — after (only if) exception thrown. Remember, THIS DOES NOT PREVENT THE ORIGINAL EXCEPTION FROM BEING THROWN! (But you can instead throw a new exception inside this method if you want a NEW MORE ELEGANT EXCEPTION INSTEAD OF THE ONE that was originally thrown.)

Eg: @AfterThrowing(
    value = "execution(* rewards.internal.*.*(..))",
    throwing = "ex"
)
    public void afterThrowingAdvice(JoinPoint joinPoint, Exception ex) {} // Similar to above example, here also the Exception type mentioned HAS TO BE MATCHED along with the expression for this method to be executed. (CAN ALSO BE A SUBTYPE OF THE MENTIONED EXCEPTION OFCOURSE)


@Around - This annotation, UNLIKE the above ones, DOES NOT HAVE THAT 'other than exception, return type also has to match'  condition, so only filter expression matters.
	  Return type of below method CAN be the specific type or Object also (TESTED, no issue). Just ensure you do proper typecasting, and RETURN PROPER COMPATIBLE VALUE.
	  When method is kept as void instead, VALUE RETURNED BY ORIGINAL METHOD BECOMES NULL!!! (printed this after method call line - "THE SECTION OF CHANGE IS OVER: null")

	  YES, WHAT VALUE YOU RETURN HERE WILL BE RECEIVED BY ORIGINAL METHOD CALL (and null, if this method is void)
	  AND if .proceed() is NOT called, then the ORIGINAL METHOD CALL DOESNT EVEN HAPPEN!!! (TESTED THIS, the before and after print statements were printed consecutively with NO 
	  "RandomClass.randomMethod() was called" in between those prints)

@Around(value="execution(@java.lang.Deprecated String rewards.internal.RandomClass.*(..))")
public String afterRandomMethod(ProceedingJoinPoint pjp) throws Throwable {         	     //throws is MANDATORY as proceed() method NEEDS THIS regardless of what method matches.
     System.out.println("Aspect triggered before randomMethod!");
     String returnedValue = (String)pjp.proceed();					     // If this line isn't called, original method call itself DOESNT HAPPEN!
     System.out.println("Aspect triggered after randomMethod! : "+returnedValue);
     return "DUMMY";									     //THIS VALUE WILL BE RECEIVED BY THE CALLING METHOD INSTEAD!!!
}

Output:
RewardNetworkImpl.rewardAccountFor() was called & Started
Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!
Aspect triggered after randomMethod! : RandomClass
THE SECTION OF CHANGE IS OVER


Limitations of Aspect advice: -
* ONLY WORKS FOR Non-PRIVATE METHODS
* Can only apply aspects to methods of SPRING MANAGED BEANS.
* IMPORTANT NOTE: IF in (say) RandomClass which is a spring bean/component, if randomMethod made another call to randomMethod2 OF THE SAME Component/Bean,
		  then randomMethod2 WILL NOT BE EXECUTED ON THE PROXIED BEAN AND HENCE, IT WONT TRIGGER ASPECT METHOD for that or any method calls inside it OF SAME BEAN!!!
		  But if you inject and CALL A NEW BEAN's method internally OTHER THAN THIS ONE, that would be proxyied and ASPECT WILL BE TRIGGERED accordingly (nested way as you expect).
		  		  
[See Notes section for detailed outputs]


Regarding the JUnit testing: -

//CHANGED HERE
Yes, @SpringBootTest is the equivalent APPROXIMATELY of all these plus maybe more: @ExtendWith(SpringExtension.class), @BootstrapWith(SpringBootTestContextBootstrapper.class)

Other unconnected annotations are: @ContextConfiguration, @EnableAutoConfiguration.], @TestPropertySource(optional, just like @PropertySource), @WebAppConfiguration — (optional, if you want a web environment).

@EnableAutoConfiguration - Optional. It enables Spring Boot’s auto-configuration, but if your config class already sets up everything, you may not need it.
In Spring Boot tests, it’s often included for convenience, but not strictly required if your context is fully defined.

Eg: Assume spring.datasource.driver-class-name/url/username/password all this is in a included properties file, and PostgreSQL JDBC driver JAR is in classpath.
    Then, If you used @Autowired to inject DataSource and you did'nt have a bean declared, This annotation WILL CREATE ONE IF THESE 2 ABOVE CONDITIONS ARE IN PLACE.

Same way, for autoconfiguring ObjectMapper as a bean (if org.fasterxml.jackson dependency is there), and EntityManagerFactory bean, if spring-boot-starter-data-jpa is there, etc.,
All such things this annotation may take care of, if the properties are in place (if any required).



JUnit 5 : -

JUnit5 is the default version from Springboot 2.6, and was a major feature of Spring 5.3
Requires Java 8+ Runtime.

Components oof JUnit: -
* JUnit Platform - Foundation for launching test frameworks on the JVM.
* JUnit Jupiter - An extension model for writing tests and extensions in JUnit5
* JUnit Vintage - A TestEngine for running JUnit 3 & 4 tests on the Platform. (for older JUnit tests execution)

Annotations NAME-CHANGED from JUnit 4 changed to JUnit 5:
@Before		==> @BeforeEach
@BeforeClass	==> @BeforeAll
@After		==> @AfterEach
@AfterClass	==> @AfterAll
@Ignore		==> @Disabled

(@DisplayName, @Nested, @ParameterizedTest , etc. are NEW annotations in JUnit5)

Note: It's very EASY to MIX AND MATCH JUnit5 and OLDER JUnit annotations, IT WONT WORK!!! Please check if ALL annotations are FROM org.junit.jupiter...

Diff between:
Stub: Provides fixed mockedresponses, no verification.
Mock: Provides responses and verifies interactions (can set expected number of calls done, how many arguments, etc. and verify this).

Difference between:

Unit Testing:
Tests one unit of functionality, isolated from the environment (including Spring)
Keeps dependencies minimal, uses simplified alternatives like Stubs and/or Mocks.

Integration Testing:
Tests MULTIPLE units working together, All units should first work individually.
In some kind of appcontext, but out-of-container testing, no need to run full App/Server.
Infra can be scaled down, like using ActiveMQ instead of Commercial messaging servers, using throwaway instances of common databases, etc.


@ExtendWith(SpringExtension.class):
It is a JUnit 5 annotation that tells JUnit to use Spring’s testing support for this test class.
It enables Spring features in your test, like dependency injection (@Autowired), loading the application context, and managing beans.
JUnit4 had Runners (@RunWith,but were unable to use multiple runners), now we have @ExtendWith which can RUN JUnit5 WITH SPRING EXTENSION (support)

@ContextConfiguration(classes={SystemTestConfig.class}):
TestContext framework, defines appcontext for tests, and USES THIS ANNOTATION to specify which configuration class to use for the application context.

FUN FACT: @SpringJUnitConfig(SystemTestConfig.class) IS THE COMBINATION OF THE ABOVE 2 ANNOTATIONS (@ExtendWith(SpringExtension.class) and @ContextConfiguration(classes={SystemTestConfig.class})).
And when either of these config specifications are used, THERE IS NO NEED FOR manually running springboot application .run() to create context (it handles it).


IMPORTANT NOTE: In Normal Springboot application, YOU CANNOT INJECT @Autowired to SPECIFIC PARAMs in a method alone instead of whole method,
like @Autowired on top of constructors, setters, fields, OR EVEN NORMAL methods also its allowed (Not recommended but allowed, called onces after initialization), BUT NOT INDIVIDUAL METHOD PARAMS.

BUT IN JUnit5 ALONE, for a @Test annotated function, I CAN USE @Autowired ON A @Test METHOD PARAMETER(s) to inject as dependencies, as usually these methods DONT have any params.

Another thing to do which INVOLVES JUnit Tests:
@ParameterizedTest
@ValueSource(strings = {"string1","string2","string3"})
void testMethod(String temp){}

The above test is RUN 3 TIMES, EACH TIME WITH ONE VALUE FROM WHAT @ValueSource provides. (basically to avoid repetition this annotation is used)


Multiple @Test methods in JUnit class WILL USE ONLY SAME ApplicationContext, not recreating each time as most beans are IMMUTABLE. So no need new.
 

Including an OVERRIDING/Changed @CONFIGURATION as EMBEDDED in your Test Class for that class alone to use the changed config.class: -

* First, DO NOT SPECIFY you Config.class in the @SpringJUnitConfig or the @ContextConfiguration annotations ON THE TEST CLASS. Just have @SpringJUnitConfig alone with no params.
* Inside the class body, have a static class like below TO IMPORT ANOTHER CONFIGURATION AND OVERRIDE ONE BEAN ALONE
(incase you want a different Bean instance/behaviour FOR RUNNING THIS CLASS ALONE, this can let you specify/redeclare for those one or 2 Beans)

@SpringJUnitConfig  //DO NOT SPECIFY Config class here or you cant override some beans alone or this test class.
public class SampleJUnitTests {
   ...
   ...
   @Configuration
   @Import(SystemTestConfig.class)
   static class TestConfiguration{
	@Bean public Datasource dataSource(){...} //Now this bean returned will be used ONLY FOR THIS test class if injected, REST of the BEANS ARE TAKEN FROM SystemTestConfig.class
   }
}


@DirtiesContext : INCASE Your code DOES Change Beans/"Dirties" the context, if you annotate this on a @Test method, After this test, NEW Application context will be created.


@TestPropertSource(properties = {"username=foo","password=bar"},
		    locations = {"classpath:/specialtestprops.properties"})

Above annotation can be annotated on a Tests class TO OVERRIDE OR ADD properties to be used for Tests IN THIS CLASS.
Properties or property file mentioned this was HAVE HIGH PRIORITY and override any other property.


@ActiveProfiles({"jdbc","dev"}) OR spring.profiles.active=jdbc,dev
 - Annotation used on JUnit 5 class to take not just Non-profile-specific beans alone, but ALSO Beans, which are declared with @Profile("jdbc") (and "dev" ones too) on the configuration classes or bean classes (or EVEN ON BEAN METHODS), in the test application context.

Note: By default no profile is activated, there ISNT any default profile/profile name used.


@Sql({"/testfiles/schema.sql","/testfiles/load-data.sql"})   OR   @Sql(scripts="/testfiles/setupBadTransfer.sql")
   -   This annotation can be used on a JUnit5 test class to RUN THESE SQL scripts BEFORE EACH @Test method executions, UNLESS THE @Test method has @Sql specified for it especially, then it follows that annotation(s).
If used on JUnit5 TEST METHOD, it overrides the class level annotation, running the method specific @Sql scripts (by default, BEFORE the @Test execution).

@Sql(scripts="/testfiles/cleanup.sql",
		executionPhase=Sql.ExecutionPhase.AFTER_TEST_METHOD)   -    By default it is executed before, using this EXPLICIT option, it executes AFTER the @Test.

The @Sql annotation also has a config value you can specify:
@Sql(..., config = @SqlConfig(errorMode = ErrorMode.FAIL_ON_ERROR,
						commentPrefix="//", separator="@@") )

ErrorMode config options for @Sql in Spring:

FAIL_ON_ERROR: Stops execution if any SQL statement in the .sql file fails.
CONTINUE_ON_ERROR: Continues executing remaining SQL statements even if one fails.
IGNORE_FAILED_DROPS: Ignores errors from failed DROP statements, but fails on other errors.
DEFAULT: Uses the default error handling (usually same as FAIL_ON_ERROR). TYPICALLY takes @Sql config parameter from class level @Sql, OR DEFAULTS TO FAIL_ON_ERROR. (usually its fail on error)

Other config internal options (SQL syntax control):
commentPrefix: Marks the start of a comment in SQL scripts (e.g. -- )
separator: Defines the statement separator in SQL scripts (e.g. ; )


JDBC Template: -

Templates in Spring like: JdbcTemplate, JmsTemplate, RestTemplate, WebServiceTemplate.
They hide away boiler plate code, And can specify other details later if needed. All exception handling, resources are handled properly.

int count = jdbcTemplate.queryForObject("SELECT COUNT(*) FROM CUSTOMER", Integer.class); //HANDLES EVERYTHING ELSE!

// Note: queryForInt() and queryForLong() are deprecated and removed since Spring 4.2

It also allows CALLBACKS to be used to add the important implementation logic alone.
Eg: The logic to map the SQL row values into creating an object TO HOLD THOSE VALUES can be sent as a callback (RowMapper).

List<Customer> results = jdbcTemplate.query(someSqlStatementString,
    new RowMapper<Customer>(){
	public Customer mapRow(ResultSet rs, int row) throws SQLException {
	    //map the current row elements to Customer obj. int row will have value 0 if its first element, then 1,.. so on, use only if needed.
	    //The resultset POINTER WILL BE MOVED AUTOMATICALLY EACH TIME IN SEQUENCE, like mapRow() call is done INSIDE while(rs.next()){} !
	}
});

NOTE: while int row supplied by Spring starts from 0 as index, 
      rs.getString() TAKES INT PARAM FROM 1, NOT 0 !!! (That's because its part of old jdbc version while this int row is supplied by spring so its new)


JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // NEEDS Datasource as constructor param.
// JdbcTemplate class IS THREADSAFE AFTER CONSTRUCTION!
// So dont need to create one for each thread. Can be used anywhere even tests.

JdbcTemplate can query for the usual Simple types (int,long,String,Date), Generic Maps, Domain Objects

Query With Bind Variables:
jdbcTemplate.queryForObject("SELECT count(*) from person WHERE age > ? AND nationality = ?",
	Integer.class, 12, "Indian");

//BELOW METHOD update() IS USED FOR INSERT OPERATIONS ALSO!!!
jdbcTemplate.update("INSERT INTO NAME (first_name,last_name) VALUES (?,?)",
	"Matthew","Jonathan G");

jdbcTemplate.update("UPDATE NAME SET last_name=?","John")

jdbcTemplate.queryForMap("SELECT * FROM person WHERE id=?", 1) - Used to map query RETURNING ONE ROW into 1 Map<String, Object> object as return value.
jdbcTemplate.queryForList("SELECT * FROM person") - Similar as above except returns multiple Maps as List<Map<String, Object>>

NOTE: Depending on the DB driver, the case of the column name (aka Key) in the map can vary, cant say if it will be in upper or lower case for sure. (But Spring course example shows in uppercase depiction)

Domain Object Queries (Mapping of resultset to domain pojo objects using callback approach) :
* public interface RowMapper<T> {
	T mapRow(ResultSet rs, int row) throws SQLException;
}

Eg: 

jdbcTemplate.queryForObject("SELECT first_name,last_name FROM person WHERE id=?",
				(rs,rowNum)-> new Person( rs.getString("first_name"),rs.getString("last_name") ),
				idValue);  // Returns pojo object. and YES, Id value comes AFTER rowmapper lambda passed.
    
FOR MULTIPLE OBJECTS To be returned, use .query() method instead, REMOVE the idValue param and SQL condition to get all rows,
And it will return List<PojoObject> in this case.

* public interface ResultSetExtractor<T> {
	T extractData(ResultSet rs) throws SQLException, DataAccessException;
}

Eg: Same as .query() method syntax above, EXCEPT that LAMBDA NEEDS TYPE CASTING (as THERE IS AMBIGUITY due to other ResultSet variations of .query() method, but RowMapper doesn't have this issue)

jdbcTemplate.query(
	"SELECT ID,NAME FROM order o WHERE confirmation_id=?",
	(ResultSetExtractor<Order>) (rs) -> {
		// THIS LAMBDA RUNS ONLY ONE TIME! So MANUALLY iterate and map rs to return 1 object of type Order.
		// Get the rs column values using rs.getLong("ID"), rs.getString("NAME") inside while(rs.next()){}
	},
	confirmationIdValue	// Same as rowmapper syntax, after lambda only the '?' param values are supplied
)

* RowCallbackHandler is similar to RowMapper, but IT DOESNT RETURN ANYTHING. Its just for processing and not returning some obj.

public interface RowCallbackHandler {
	void processRow(ResultSet rs) throws SQLException;
}


** CAUTION ** : the .query() method accepts ALL 3 callback obj types,
		BUT .queryForObject() ONLY ACCEPTS RowMapper CALLBACK, not other 2 !!!
		REST OF THE 2 QUERY METHODS (list and map), and update() DO NOT ACCEPT SUCH CALLBACKS !

Exception Handling: -

SQLException, like all other checked exceptions MAKE TIGHT-COUPLING of methods AS ALL INTERMEDIATE METHODS NEED TO DECLARE TO THROW such exceptions,
Incase you want to handle the exception at a higher level, so all method signatures have to handle this correctly, a nuisance.

DataAccessException is provided by Spring, an UNCHECKED HEIRARCHY of Exceptions which WRAPS SQLException by catching it,
giving A MORE MEANINGFUL EXCEPTION TYPE THROWN.

Like instead of SQLException, it can be wrapped into some meaningful unchecked exceptions like: 
BadSqlGrammarException (if there is sql syntax error),
DataAccessResourceFailureException, CleanupFailureDataAccessException, OptimisticLockingFailureException, DataIntegrityViolationException.



Transactions : -

ACID principle:
Atomicity - Each unit of work done is ALL OR NOTHING operation. Either full work committed or ROLLED BACK.
Consistency - No DB integrity rules or constraints are violated, ensures DB always is in valid state/data.
Isolation - Isolating changes (in progress/uncommitted) of transactions from each other. Only when one is committed, it's visible to the other.
Durablity - Once transaction is committed, changes are permanent, and can survive a system failure, power outage, etc. (Non-volatile)


Without transaction, till now, each time DB connection was acquired, used, and then released, several times this happening in 1 atomic work is bad. Transaction should/will ensure ONE connection is reused for such individual db operations, then released. Either all succeed or fail.

Separation of Concerns
Demarcation (@Transactional): You mark a method to indicate it should run in a transaction. Spring handles the rest automatically.
Implementation (PlatformTransactionManager): An underlying component handles the actual transaction logic (begin, commit, rollback), based on the configured manager.

2 Ways to use/include transactions in your code: -
Declarative (@Transactional): Recommended. Use an annotation. Spring's AOP creates a proxy that intercepts the method call to manage the transaction.
Programmatic (TransactionTemplate): Less common. Manually control transactions inside code for fine-grained control.

Global vs. Local Transactions
Spring uses @Transactional for both. Your code doesn't change when switching between them.
Just change the PlatformTransactionManager bean in your configuration between them.

The PlatformTransactionManager: -
Abstraction: A generic interface in Spring for transaction strategies.
Implementations: Different managers for different needs.

Local transactions (single resource [db/msg queue] ) : These manage transactions for a single resource, such as one database or one message queue.

DataSourceTransactionManager: Manages transactions for a single JDBC DataSource. Use this for applications that access a database via plain JDBC.
JpaTransactionManager: Handles transactions for a JPA EntityManagerFactory. This is typically used with JPA providers like Hibernate.
JmsTransactionManager: Manages transactions for a single JMS ConnectionFactory. It's suitable for applications that only involve a single message queue.
HibernateTransactionManager: Manages transactions specifically for Hibernate's native SessionFactory API (without using JPA).

Global transactions (multiple resources [db/msg queue]): These coordinate transactions across multiple transactional resources, like several databases or a database and a message queue. They require a transaction manager in an application server or a standalone JTA provider. They CAN ALSO DO local transactions but just more overhead due to TWO phase commits.

JtaTransactionManager: Delegates transaction management to the JTA (Java Transaction API) provider, which is often part of a Java EE/Jakarta EE application server. This is the standard choice for distributed transactions.
WebLogicJtaTransactionManager: A specialization of JtaTransactionManager for the BEA (now Oracle) WebLogic application server, providing additional vendor-specific features.
WebSphereUowTransactionManager: A specialization for the IBM WebSphere application server, using its Unit of Work (UOW) API to manage global transactions.

Just like other concepts, Transaction ALSO WORKS BY PROXYING THE BEAN, simply having SpringTransactionInterceptor intercept any request for target method/class (both work together as 1),
And it communicates with TransactionManager to begin/commit, adding transaction management behaviour to the code.

As expected, Transaction is started before entering method, Commits at end of normal method execution.
ROLLBACKS if method throws a RuntimeException BY DEFAULT. (can be overridden)
Checked exceptions DO NOT CAUSE ROLLBACK BY DEFAULT, BUT ALL THIS EXCEPTION BEHAVIOUR CAN BE OVERRIDEN USING:

@Transactional(rollbackFor = MyCheckedException.class, noRollbackFor = MyRecoverableRuntimeException.class))

Caution: Incase similar exception type (or even same) is mentioned in both opposite attributes, noRollbackFor takes PRECENDENCE !

Transaction context bound to Current Thread HOLDS THE UNDERLYING JDBC CONNECTION. Hibernate sessions, JTA (Java EE) work similarly.
JdbcTemplate CAN USE this capability automatically IF USED IN @Transactional method.

(Can also fetch Connection manually using DataSourceUtils.getConnection(dataSource))
--------------

Step 1: @EnableTransactionManagement (add to config class)

Step 2: Create a Bean returning PlatformTransactionManager implementation.

Step 3: @Transactional (add on method required to be transactional)

Eg: DataSourceTransactionManager is created by new DataSourceTransactionManager(dataSourceObj);
    While new JtaTransactionManager() doesn't required any constructor param.

@Transactional can be declared on CLASS or EVEN INTERFACE! (since Spring 5.0)

@Transactional(timeout=60) - Sets timeout in seconds for transaction if it exceeds it.

IF USED ON CLASS, its the default value for all methods in it, IF METHOD HAS the annotation TOO, it will use that specifically for that method alone instead.

WARNING: JAVA ALSO HAS @Transactional annotation, BUT ITS NOT THE SAME AS SPRING's @Transactional.
	 BE CAREFULY AND USE ONLY THE SPRING ONE.


@Transactional( propagation = Propagation.REQUIRED ) : [ DEFAULT VALUE ]

Creates one (obviously as usual) if method not in a transaction already.
If a @Transactional method CALLS ANOTHER @Transactional method, WHAT HAPPENS ???
The Transactions JOIN TOGETHER, which is one way. (Though marked as 2, internally logic works like 1 transaction)


@Transactional( propagation = Propagation.REQUIRES_NEW )

If you really want separate transactions, you can specify it. It will be separate independent transactions.
And NO, THEY AREN'T NESTED, Like Second Transaction can commit, but First can fail, that wouldn't happen if they were "nested" right? so yep,
It CREATES NEW INDEPENDENT TRANSACTION ALWAYS (If already one is there, it SUSPENDS it temporarily) !


CAUTION (MASSIVE ONE):

JUST LIKE OTHER PROXY BEAN BEHAVIOUR, if one @Transactional annotated method calls another one,
WHICH IS IN THE SAME CLASS, then THE CALL DOES NOT GO THROUGH PROXY BEAN, and hence THAT SECOND METHOD's propagation rule WONT APPLY !!!
Think about it, Proxy is injected instead of real target, so when you call method FROM ANOTHER BEAN, it will call proxy,
AS METHOD CALL HAPPENS ON OBJECT INJECTED (aka meaning its proxy if applicable).

BUT CALLING FROM THE METHOD (which you called using proxy bean) to another method INTERNALLY INSIDE SAME CLASS,
It's not calling on the proxy bean actually, it will call the actual TARGET class method itself DIRECTLY (think about it),
Proxy cant intercept if YOURE ALREADY INSIDE THE TARGET, only if outside and you injected and used obj, it can act as proxy.
Internal calls are directly in the target obj itself, like its literally that datatype as the class name, cant be some random proxy class.


You CAN make @Test methods TRANSACTIONAL !
But in this case, if you make it so, IT WILL ROLLBACK FOR SURE (since it's a test), UNLIKE THE MAIN CODE WHERE IT CAN COMMIT IF NO ERROR.

Warning: IF YOU START different TRANSACTION INSIDE the method body, then this RULE DOES NOT APPLY.

If you REALLY WANT TO COMMIT @Test method changes, NOT rollback, then:
@Commit/@Rollback(false) if you use on the @Test method (@Transactional either on method or class itself), THEN IT WILL COMMIT TRANSACTION like main code!



----------------------------------

Springboot Course:=

Usually in springboot main class, we use 3 annotations together:

* @SpringBootConfiguration - Marks a class as a source of configuration specifically for a Spring Boot application.

* @ComponentScan - Tells Spring which packages to scan for components like @Component, @Service, and @Repository. This automatically registers them as beans in the application context. 

* @EnableAutoConfiguration - Automatically configures Spring beans based on the dependencies found in your project's classpath. For example, it sets up a web server if you have spring-boot-starter-web.


@SpringBootApplication(scanBasePackages="example.config") CAN REPLACE THESE 3 into just 1 annotation !!

In springboot, autoconfiguration checks like h2/derby/etc is there in classpath, then datasoure obj can be created or not based on properties etc.

A "Fat" JAR basically contains ALL dependencies required to run the web application. (even the required tomcat server)
So it can be simply run using the java -jar command.

Using the mvn package command or the gradle assemble command, you can create the required jars:
Eg: my-app.jar can be the executable "FAT" JAR,
whereas my-app.jar.original can be the "usual" JAR. (has ONLY COMPILED CODE & without overhead of sping dependencies)

The below dependenency mentioned inside a <plugin>...</plugin> alone, WILL CREATE A "FAT" JAR:
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-maven-plugin</artifactId>

Ensure to use springboot:run option as a goal to it, so it runs the app.

@SpringJUnitConfig(SystemTestConfig.class) is usually used till now for JUnit 5 testing as it creates beans in test app context
only as many as required, NOT doing it exactly like it would happen in the real application.

@SpringBootTest(classes=Application.class) - IT'S THE ANNOTATION you can use to RUN THE ENTIRE application like in the main app run.
It's ideal for more general like Integration tests.

@SpringBootConfiguration - Optionally, you DONT have to mention the classes param value in the @SpringBootTest annotation
ONLY IF you have this annotation @SpringBootConfiguration on your TestConfiguration class where there is @ComponentScan, @EnableAutoConfiguration, etc.

WARNING: If you use @SpringBootTest ALONE no params in your test class,
YOU HAVE TO ENSURE the @SpringBootConfiguration annotated TestConfig class IS IN A PACKAGE ONE LEVEL HIGHER THAN the former.
And ONLY ONE of such configuration classes can exist in a hierarchy, basically NO multiple PRIMARY configuration classes.
(but generally multiple normal config classes allowed!)


Ideally to start springboot project, you can use spring initializer (also opensource),
But mainly 3 files are needed: pom.xml (for maven), Application.java (main class) , and application.properties


@SpringBootApplication is a combination of 3 annotations:
@SpringBootConfiguration (primarily to specify main class without specifying in SpringTests)
@EnableAutoConfiguration (Some Beans are autocreated based on classpath dependencies)
@ComponentScan

For example, JdbcTemplate WILL BE AUTOCREATED in app context, just inject it and use.

Commands to run app:
"mvn package" then use "java -jar JarName.jar"


logging.level.root=DEBUG
# Logs only log statements of MORE SEVERE OR EQUAL to the specified level.
# List of Logging levels (in asc. order of severity):
# TRACE (least severe)
# DEBUG
# INFO
# WARN
# ERROR
# FATAL (most severe)


If you keep 2 SQL files names schema.sql and data.sql,
IN A FOLDER PRESENT IN CLASSPATH (like "src/main/resources"),
Then SpringBoot WILL RUN IT automatically at the start,
Else if it is in some other subfolder, use this:
#path like classpath:db/schema.sql can be used
spring.sql.init.schema-locations=<path to your schema SQL file>
spring.sql.init.data-locations=<path to your data SQL file>

If you have banner.txt and it contains something (ideally meant to be like \___\ symbols used diagramatically),
Then at start of running application, SPRINGBOOT WILL DISPLAY THIS BANNER INSTEAD OF THE DEFAULT ONE.

assertThat(1).isEqualTo(21); is example of asset statement in test.



Environment and @Value annotation can be used to fetch properties and env values from application.properties or other @PropertyConfig sources.

application.properties is looked for in priority in following:
* /config subdirectory of the working directory (config subdir in the directory where executable jar is executed in target folder)
* The working directory (same directory as executable jar in target folder)
* config package in classpath (eg: src/main/resources/config/application.properties)
* classpath root (eg: src/main/resources/application.properties)

(if multiple same property is mentioned in the same file twice or more, LAST ENTRY IS TAKEN.
Also YOU SHOULD ONLY put properties of imp early created beans properties in this file or yaml (like LOGGING LEVEL or other important early initialized beans), not in some random PropertySource as application.properties or .yaml is loaded first)

Apart from this, springboot also looks for PROFILE-SPECIFIC like application-dv.properties

YAML FILE properties also can be specified: -

- environment.getProperty("server.port") or  @Value("${my.app.name}") can ONLY be used with snakeyaml.jar inside spring-boot-starter dependency is used)

- .yaml files neeed to use 2 spaces for indentation rather than tab space.

- ALL 2x4=8 possible files are attempted to be loaded.

- The SAME PRECEDENCE order as for .properties files is used, where IF BOTH .yaml and .properties ARE IN THE SAME LOCATION,
  any SHARED properties in .properties file IS MORE PRIORITY THAN one in .yaml.

- The parsing done to find these IS DONE FROM LOWEST PRIORITY, as it comes to higher priority files, PRE-EXISTING PROPERTIES ARE OVERWRITTEN WHEN ENCOUNTERED. So just follow priority list of 8 files blindly, but all 8 files are looked if they have some unique properties atleast.

- In yaml, the following way can be used to specify different profile properties IN SAME yaml FILE:

.....
..... (Common properties here always loaded, till the 3 dashes is encountered)
---
spring:
  profiles: local
  datasource:
    url: .......
---
spring:
  profiles: cloud
  datasource:
    url: .......



Properties Overall Heirarchy (in order): -

1. Devtools settings
2. @TestPropertySource and @SpringBootTest properties
3. Command line arguments
4. SPRING_APPLICATION_JSON (inline JSON properties).
5. ServletConfig / ServletContext parameters.
6. JNDI attributes from java:comp/env
7. Java System properties
8. OS environment variables
9. Profile-specific application properties
10. Application properties / YAML
11. @Property Source files
12. SpringApplication.setDefaultProperties.



@ConfigurationProperties :

If you want to map certain properties to a BEAN OBJECT, like these:
reward.client.host=192.168.1.42
rewards.client.port=8080

YOU CAN INJECT PROPERTIES INTO A BEAN OBJECT FOR ACCESS SOMEWHERE ELSE!

@ConfigurationProperties(prefix="rewards.client") //all properties will be fetched with this prefix
public class ConnectionSettings{ //Inject this bean anywhere like normal to get properties
	private String host;
	private int port;
// getters and setters are mandatory ofcourse
}

WARNING: To enable this behaviour of property injection using this annotation, 3 WAYS are there:
* Annotate @Component on above class
* Annotate @EnableConfigurationProperties(ConnectionSettings.class) on MAIN CLASS.
* Annotate @ConfigurationPropertiesScan on Main class (springboot 2.2.0+ onwards),
  Like @ComponentScan, THIS TOO SCANS the package of the class it's hosted on AND it's subpackages.


WARNING: If @ConfigurationProperties is used say with "rewards.client-connection", hostUrl as a variable,
The VARIOUS LEGAL MATCHES NEED NOT BE EXACT, CAN VARY SLIGHTLY AS FOLLOWS: (mix & match mostly is a NO)
* rewards.clientConnection.hostUrl (Camelcase words separation)
* rewards.client-connection.host-url (hyphens)
* rewards.client_connection.host_url (underscores)
* REWARDS_CLIENTCONNECTION_HOSTURL (For matching with ENV variables, capitalizes, removed dashes,
	replaces dots with underscores, and using this new string, it searches for a value in envs.)


@EnableAutoConfiguration (or just @SpringBootApplication is enough) on main class enables Spring's Configuration classes. (can create our own too)
They are @Configuration classes which are activated CONDITIONALLY based on things like:
Do classpath include specific classes, or some specific properties are set, or some beans already configured (or not)

Eg: JdbcTemplate is autoconfigured IF a DataSource bean is present in context,
Which can be present if there is dependency in classpath + properties relevant are there in properties files.


@ConditionalOnBean(DataSource.class) :
This annotation when annotated on bean class/method, IT's ONLY actually initialized as bean IF DataSource bean is present.

@ConditionalOnClass [If given class exists in classpath], @ConditionalOnProperty [If given property has a particular value],
@ConditionalOnMissingBean / ...MissingClass [Similar to above except only creates bean IF SPECIFIED BEAN/CLASS is missing instead]		
(Even @Profile annotation is in this category)


@AutoConfiguration annotation specifies a class EXPLICITLY for autoconfiguration. (Can be overridden)
Such classes only are enabled AFTER THE EXPLICIT beans you specify are CREATED.
(so missing ones are configured, and your beans defined always are preferred over AutoConfiguration beans)

There are 4 ways to controlling autoconfig classes:
- Set Springboot properties
	Eg: In springboot, spring.datasource.url/username/etc properties if are present, DataSource is prepared using @ConfigurationProperties("spring.datasource") on a bean,so only if you configure these properties you can control the datasource's params.

  Eg: Same way logging.level.org.springframework=DEBUG is a kind of property to control the logging framework.
      Basically whatever you put after "logging.level.", THAT PACKAGE's LOGGING WILL ONLY BE AFFECTED. More specific ones OVERRIDE general ones.
      (Springboot uses SLF4J as default "facade"/pattern interfaces/classes, with LogBack implementations for it, this is recommended)


-Explicilty specify the beans yourself so springboot won't

- Explicitly disable some AutoConfiguration

@EnableAutoConfiguration and @SpringBootApplication has (exclude=DataSourceAutoConfiguration.class) option for you to EXCLUDE any class you dont want so it doesn't autoconfigure.
(OR)
Have this property: spring.autoconfigure.exclude=\
			org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration

(Yes, a property can be extended beyond more than 1 line using '\' operator, next line you can indent and put value without issue)

- Change dependencies or their versions.

If you want to use Jetty instead of Tomcat server, you can specify spring-boot-starter-jetty dependency, BUT EXCLUDE tomcat FROM STARTER WEB DEPENDENCY as follows:
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
	<exclusions>
		<exclusion>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
		</exclusion>
	</exclusions>
</dependency>


As seen before, DataSource can be Auto-configured by 3 ways: predefined properties, define own bean instead,
CHANGE UNDERLYING DATASOURCE CONNECTION POOL IMPLEMENTATION

Connection pool can create and contain multiple connections for multiple usage to prevent multiple connections open and close.

You have seen spring.datasource.url/username/password/driver-class-name
We have below properties for AFFECTING UNDERLYING CONNECTION POOL (doesn't look so but yes) :
spring.datasource.initial-size/max-active/max-idle/min-idle

Note: Each connection pool IS FOR ONE DATABASE, yes multiple of such connection objects are there
      So they can use DIFFERENT NETWORK SOCKETS FOR THE SAME DB FOR CONCURRENCY/PERFORMANCE (or each db operation has to wait for the other)!


Default Pooled DataSource for springboot 1.x.x is Tomcat and for 2.x.x its Hikari. (can be in sp-bt-starter-jdbc or ..-..-starter-jpa)
Apache Commons DBCP2 is the backup if both dependencies arent present. (HikariCP then Tomcat JDBC then Commons DBCP2 then Oracle UCP)
Can use spring.datasource.type to pick pool explicitly.

Even if regular datasource general property can be used, spring.datasource.tomcat.*, or x.x.hikari.* or x.x.commons-dbcp2.* are for FINEGRAIN control of properties.


CommandLineRunner and ApplicationRunner are basically having run() method WHICH RUN AFTER CONTEXT HAS ALL BEANS CREATED.
Its to ensure you dont put application logic in main method of mainclass, instead have this as Bean inside the main class.


    @Bean
    CommandLineRunner commandLineRunner(JdbcTemplate jdbcTemplate){ //You can autoinject any bean req

        String QUERY = "SELECT count(*) FROM T_ACCOUNT";

        // Use Lambda expression to display the result
        return args -> System.out.println("Hello, there are "
            + jdbcTemplate.queryForObject(QUERY, Long.class)
            + " accounts");
    }

ApplicationRunner interface has below method where it HAS ARGUMENTS FROM CMD (Can use LAMBDA INSTEAD to return like above)
public void run(ApplicationArguments args) throws Exception {
	// !args.getNonOptionArgs.isEmpty()
	// args.getNonOptionArgs().get(0)     // Basically gets first argument which ISNT part of like "-jar target/xxx", aka without respective option
}

Methods in ApplicationArguments:
getNonOptionArgs() → Returns List<String> of raw values (e.g., file.txt which is not given with '--').
getOptionNames() → Returns Set<String> of keys (e.g., port from --port=80).
getOptionValues("optionNameOrKey") → Returns List<String> of values for a specific option.
getSourceArgs() → Returns String[] of the original raw command line.
containsOption("optionNameOrKey") → Returns boolean check for presence of a flag.


spring-boot-maven-plugin : This dependency is required for packaging, running, and reloading Spring Boot apps via Maven.
			   (Eg: executable jar generated which can be executed using java -jar, ca also run using mvn clean package spring-boot:run)

Steps converting spring project to springboot: -
* Added @SpringBootApplication annotation to main class.

* Use @SpringBootTest instead of regular spring annotations like @ContextConfiguration(classes = {SystemTestConfig.class}) // (aka class annotated with @Configuration OR an XML file EXACTLY named applicationContext.xml)
as while the ContextConfiguration annotation will just include ONLY THE CONFIG CLASS YOU SPECIFY. (if none passed, checks for a static inner class called ContextConfiguration, else nope.)

The SpringBootTest annotation does 3 things (as told long before):

Load the full application context
Scan for components and configurations in the current package and subpackages
- ANY CONFIG inside SAME OR SUBPACKAGE of @SpringBootTest class, IT WILL BE DISCOVERED BY DEFAULT. (DOESNT MATTER main/test folder, all is same!!!)
- If you MENTION CLASSES AS PARAMS, it will ONLY INCLUDE THOSE and ignore rest (unless there is @Import or @ComponentScan usage in the classes it scans).


IMPORTANT: @SpringBootTest DOES NOT AUTOMATICALLY ENABLE AUTOCONFIG (like i incorrectly suspected),
	   Since main class ALSO was under "package rewards;", the SystemTestConfig PICKS UP THE CLASS AS CONFIG (no class params in test annotation),
	   And thus enables AutoConfiguration since the @SpringBootApplication (or xxConfiguration) does this unless explicitly excluded.

	   Now thats why it looked like WHEN SPECIFYING CLASSES IN @xxTest annotation it DIDNT ENABLE Autoconfig (and datasource wasnt found),
	   BUT when no params were given to the test annotation, IT ENABLED, because IT SCANNED MAIN CLASS IN SAME PACKAGE!!!

So remember that by default without any @EnableAutoConfiguration, or @SpringBootApplication which doesnt exclude the autconfig class, 
Then actually @SpringBootTest DOES NOT DIFFER IN THIS ASPECT like ContextConfiguration. (@SpringBootConfiguration WONT ENABLE THIS!)


@SpringBootApplication on the main class ALSO acts like @SpringBootConfiguration (default main config marker annotation),
Meaning the SpringApplication.run() CAN HAVE THIS SAME CLASS as it's parameter for configuration.

If NO packages are specified for scanning components, ALL OF THE SAME + SUBPACKAGES classes ARE SCANNED! 
If you dont supply config or any class to run() in main class, it assumes the same class as the one to be passed (not some weird scanning).

The @SpringBootConfiguration is a marker annotation which is BASICALLY LIKE CONFIGURATION ENTRY POINT,
Minus the 2 things offered by @SpringBootApplication: @EnableAutoConfiguration and @ComponentScan; Usuall not preferred over the application annotation as main class usually is main config also

Can use this annotation in tests if you want a configuration entry point INSTEAD of main application class,
Therefore you can avoid loading (for some reason) THE ENTIRE CONTEXT which main class might include by @Import or component scanning, etc.
Instead here you can control what is scanned.

Locations where jars are stored:
cp *jdbc-autoconfig/target/*.jar temp (for Maven)
cp *jdbc-autoconfig/build/libs/*.jar temp (for Gradle)


@Order annotation, unlike the STRAIGHTFORWARD @Qualifier annotation, this:
- is used when injecting a collection (like List<BeanType> or Map<String, BeanType>).
- It tells Spring in what order to inject or execute those beans.
- It does not help select a specific bean.
- Has no effect on single bean injection.

Eg: 
@Component
@Order(1)
public class FirstHandler implements Handler { }

@Component
@Order(2)
public class SecondHandler implements Handler { }

@Autowired
List<Handler> handlers; // Injected as [FirstHandler, SecondHandler]

So it DOES NOT ACT LIKE QUALIFIER, just affects order incase List/Map<String, Bean> is injected.


Instead of using the annotation, your bean class CAN ALSO IMPLEMENT Ordered Interface FOR SAME EFFECT!
public interface Ordered { int getOrder(); }

Infact, @Order DOES NOT GET USED IF Ordered interface is implemented by a bean class!!! (preferred over what annotation @Order says).
Just implement the method in the class and override, lowest (1) value returned is highest priority.


-----------

Spring JPA: -
ORM Mapping: Maps Java classes to database tables using @Entity.
Auto Configuration: Spring Boot auto-configures JPA with minimal setup.
Repository Support: Use JpaRepository for CRUD without writing SQL.
Query Methods: Supports derived queries, JPQL, and native SQL.
Transaction Management: Handles commit/rollback automatically.
EntityManager Access: For custom persistence logic.
Relationship Mapping: Supports @OneToMany, @ManyToOne, etc.
Schema Generation: Can auto-create/update DB schema via properties.

spring-boot-starter-data-jpa is the dependency required as starter.
HIBERNATE WILL BE THE IMPLEMENTATION for this as JPA is just made of interfaces.

WARNING: @EnableJpaRepositories WONT BE NEEDED IF THIS DEPENDENCY IS INCLUDED, UNLESS there are rep. interfaces which
ARENT IN SAME OR SUBPACKAGES as your main class, then needed TO SPECIFY THE OTHER PACKAGE LOCATION of the repositories.

	@EnableTransactionManagement IS NOT EVEN NEEDED for default behaviour if this dependency is there! [ONLY APPLIES TO SPRINGBOOT, NOT PURE SPRING.]

If jpa is in classpath, springboot AUTOCONFIGURES:
- DataSource,
- JpaTransactionManager (remember @Transactional is just marker annotation, THIS BEAN HANDLES THE ACTUAL BEHAVIOUR)
  Eg: Can be created using EntityManagerFactory object passed as single param to JpaTransactionManager constructor.

- EntityManagerFactoryBean (creates & configures EntityManagerFactory, which inturn builds EntityManager objects,
	which are like smart helpers that let you save, update, delete, and fetch data as Java objects (handles ORM basically).),

---
Eg. of EntityManagerFactoryBean WITHOUT SPRING BOOT EASY WAY OF AUTOCONFIG (mostly FYI, not that important):
@Bean
public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
	HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter();
	adapter.setShowSql(true); // Enable SQL logging in the console
	adapter.setGenerateDdl(true); // Allow Hibernate to auto-generate database schema (DDL)
	adapter.setDatabase(Database.HSQL); // Set target database type
	
	Properties props = new Properties();
	props.setProperty("hibernate.format_sql","true"); // Format SQL output for better readability

	LocalContainerEntityManagerFactoryBean emfb = LocalContainerEntityManagerFactoryBean();
	emfb.setDataSource(dataSource);
	emfb.setPackagesToScan("rewards.internal"); // Packages To Scan for Entities for ORM
	emfb.setJpaProperties(props);
	emfb.setJpaVendorAdapter(adapter); // Hibernate Implementation (aka Adaptor) is added as the JPA's actual implementation.
	
	return emfb;
}
---

In springboot (dont need above code), @Entity is checked in the same package/subpackages by default (as told previously)
You can OVERRIDE WHERE IT SCANS FOR ENTITIES using @EntityScan("rewards.internal") to specify different BASE package.

Some Properties for jpa:
spring.jpa.database=default 	     # Springboot will try to select dialect for you, but default is enough as IT CAN FIGURE IT OUT BY ITSELF
spring.jpa.hibernate.ddl-auto=update # validate, create, create-drop are other legal values. Default val is none (does NOTHING at startup)
				     # Except for embedded databases, create-drop is default value in this case alone.
				     # validate - app startup fails if expected db tables format isn't there.
				     # update - modifies db schema to match entity classes. Adds cols/tables. NO DELETION though.
				     # create - DROPS AND CREATES schema (DONT MISTAKE AS IF THIS WONT DROP, it will)
				     # create-drop: One difference from create is IT DROPS ALSO WHEN YOU SHUTDOWN THE APP.

spring.jpa.show-sql=true    	     # Shows the SQL statements executed
spring.jpa.properties.hibernate.format_sql=true # Formats the SQL to beautify. Any other hibernate property can be access like this.

YES, JPA CAN be used for NO SQL DATABASES ALSO just like RDBMS ones!

Instant Repositories: a feature..just annotate the Interface with @Repository [OR] interface SpringDataCommon's Repository<T,K> (or subtype)
		      like CrudRepository<T,K>, JpaRepository<T,K> , etc, and define the keys & enable persistence,
		      Springboot will implement it with CRUD operations support, including paging, custom queries if any, sorting etc.

Annotations for RDBMS entities:
@Entity - Marks class as a persistence class
@Table - To specify what table to map this entity into (not mandatory but can use)
@Id - To mark id field in entity.
@GeneratedValue(strategy = GenerationType.AUTO) - Helps to specify id field value generation strategy.

Entity annotations for other dbs include : @Document [MongoDB], @NodeEntity [Neo4J] with @GraphId for id field, @Region [Gemfire]

The format for finder methods to just declare in repository interface you create is: [ALWAYS CHECK ENTITY's FIELD NAME MATCHES ALSO,
					if any of both conditions fail, then method wont be implemented automatically!]
find(First)By<DataMemberOfClass><Op>
<Op> - can be GreaterThan,NotEquals,Between,Like
Eg: findByOrderDateBetween(Date d1,Date d2)


You can also SPECIFY CUSTOM SQL QUERY FOR A finder method. Example:
@Query("SELECT c FROM Customer c WHERE c.email = ?1")
public List<Customer> findByEmail(String email); // ?1 is REPLACED BY parameter here


Note that JpaRepository<T,ID> extending interface supports WHICH EXTENDING Repository<T,ID> DOESNT SUPPORT:
- Basic CRUD operations like save(),delete(),findById()
- Batch operations (like saveAll(), deleteInBatch())
- Pagination & Sorting
- Flush operations,

COMMON THINGS BOTH SUPPORT:
- methods autogeneration if declared
- Custom queries using @Query can autogenerate when explicit method declaration.
- Transactional behaviour

Note: @EnableJpaRepositories(basePackages="com.acme.repository") on a config file IS NOT MANDATORY IF the repositories are
IN SAME OR SUB PACKAGES of where @SpringBootApplication is in.

SpringData implements your repositories AT RUNTIME, creating proxies for injection so at runtime it intercepts method call to interface,
Gets query custom created and executes using Jpa.


Firstly, JpaRepository<T, K> is ideal to be extended by repository interfaces if you want the predefined default operations,
else the generic Repository<T,K> is better, as INCASE of test, you try injecting Stub* repository CLASSES instead,
Then remember, whatever predefined methods JpaRepository INTERFACE has, Stub* Repository CLASS MUST IMPLEMENT.
Usually hibernate will implement those predefined but youre injecting stub repository, so it's UNNECESSARY work for you, so you dont use in that case.

@Entity - Marks class as a JPA persistent entity class.
@Table(name="T_ACCOUNT") - Specifies exact table name to use from DB (would be class's name if unspecified).
@Id - Indicates the field to use as the primary key on the database.
@Column(name="ID") - Identifies column-level customization, such as the exact name of the column on the table. (optional if same name)
@OneToMany - Identifies the field on the 'one' side of a one to many relationship. (MARKS field as COLLECTION like List<>/Set<>)
@JoinColumn - Identifies the column on the 'many' table containing the column to be used when joining. Usually a foreign key.

Eg: Here ONE-TO-MANY relationship field is set (this entity's field will be on the "ONE" side, mapping to many Beneficiary entries)
    the field name (here it's "ACCOUNT_ID") is looked for in the injected datatype's entity (Beneficiary) and is mapped.
    
    @OneToMany
    @JoinColumn(name = "ACCOUNT_ID")
    private Set<Beneficiary> beneficiaries = new HashSet<Beneficiary>();

Remember: Jpa could POSSIBLY convert simple datatype differences like int and Integer, etc between this entity and other entity's
same named fields you try to join, but IT SHOULD PRACTICALLY BE SAME TYPE!


@AttributeOverride(name="value", column=@Column(name="ALLOCATION_PERCENTAGE"))
private Percentage percentage; // GETS this variable SET USING REFLECTION!

WARNING: A datatype/class used like above HAS TO BE ANNOTATED WITH EITHER @Entity or @Embeddable in this case (latter is the case here).
YES THE VALUES HAVE TO BE IN DATABASE. it starts using default constructor but values are assigned by ORM.

@Transient - In this case this annotation ensures while ORM is done, THIS FIELD IS IGNORED.
	     Saving entity or retreival of this entity from or to db WILL IGNORE THIS FIELD!

In SQL schema, identity keyword in table creation statements like "ID integer identity primary key"
AUTOINCREMENTS by 1 and saves the value (default behaviour atleast).


Remember: spring.sql.init.schema-locations & data-locations is the right property to set in springboot 2.x.x usually. (value is like "classpath:/xxx").


Spring MVC (Model/View/Controller): -

2 types of MVC applications: Web Servlet (what we will do, traditional web apps with limited threads/imperative programming style)
			     Web Reactive (eg: Netty/Undertow server supports this, reactive/functional programming, fewer threads, highly concurrent apps in real time)

Embedded servlet containers are supported by springboot. FAT jar contains even the container required to run springboot web apps from cmd!

spring-boot-starter-web is required for Spring MVC plus Spring Web. It DOES AUTOCONFIGURATION OF:
DispatcherServlet, default Message Converters, default resource locations (img, css, js, etc), internal config to support controllers, etc.

REST request-response processing lifecycle involves "Dispatcher Servlet" calling a "Message Converter" which converts the JSON/XML to Data/Objects,
which is how the Controller only deals with receiving and sending requests/responses as Objects while on the outside deals with JSON, XMl, etc.

Warning: @Controller is for Controller classes whose methods/endpoints RETURN VIEWS, NOT JSON/XML!!!
	 @RestController is the one whose methods return JSON/XML.
	 BUT annotating @ResponseBody on the methods/CLASS ITSELF in @Controller class is BASICALLY EQUIVALENT TO just using @RestController alone. (so RestController just spares that extra @ResponseBody annotation , ofc you cant use it if you need a method to return a View)

@GetMapping("/data") - specifies suburl for Get endpoint. Use it on class for a GENERAL base path applying to ALL GET requests (not others) in that class.
@RequestMapping("/api") - same as above except general to ALL requests in controller.

@RequestParam("userid") - This is for param. variable used in controller method, so a url query variable's value with given name is assigned to it. 
			  Even @RequestParam(value = "userid", required=false) exists to HAVE THIS PARAM AS OPTIONAL (doesn't throw exception unlike the usual case where it will)

@PathVariable("accountId") - Similarly but path variable value is assigned to method param. (both do 'implicit' type conversions decently)
			     suburl in method annotation should be like @GetMapping("/accounts/{accountId}") to let it know where in url it should take val.

Note: you DONT NEED TO SUPPLY PARAM to above 2 annotations if the variable names in query/suburl_path_var EXACTLY matches java variable name.

@RequestHeader("user-agent") - Gets the header received mapped to the method param variable you annotate this on.

The methods in controller CAN have ANY PARAMETERS which is available in Servlet Api like: Principal, HttpSession, Locale, HttpServletRequest, etc.

Except Protobuf (protocol buffers), springboot sets up everything else like XML conversions and JSON (using Jackson, gson for json too possible), form-based data, Byte[], String, BufferedImage, etc. google protocol buggers require 3rd party libraries on classpath for this to convert.

ResponseEntity (Subclass of HttpEntity):
You can return ResponseEntity<> instead for more control like sending status codes, SETTING RESPONSE HEADERS, content type etc.

Eg: ResponseEntity<String> response = ResponseEntity.ok()
					.contentType(MediaType.TEXT_PLAIN) //Sets the Content-Type header to let client know format of response
					.lastModified(System.currentTimeMillis()) // Sets Last-Modified header with 'long' type value
					.body("Hello Spring");

.contentType(MediaType.APPLICATION_JSON) is OPTIONAL if you use @RestController, as SpringBoot WILL SET THAT HEADER AUTOMATICALLY as application/json.


WAR file ARE NOT selfcontained ;like JAR files are, as they require external container to run it unlike JAR (fat jar) which can have everything required and run in cmd alone! To run as WAR file, you have to do this to main class as below :

//EXTEND main class WITH SpringBootServletInitializer and implement below method
protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
	return application.sources(Application.class);
}

The main method with SpringApplication.run(Application.class, args) CAN EXIST ALONG WTH ABOVE METHOD ALSO! IF BOTH ARE THERE,
Then while running as JAR, main method is used, when running WAR file, above method is used. that's all. Ensure that tomcat dependencies versions are compatible with the tomcat server version (if using tomcat as external server) in case of WAR. Same fat and thin WARs will be generated.

spring-boot-devtools (in org.springframework.boot) dependency can make development EASIER by HOT restarting application,
instead of cold restarting from the start EVERYTIME YOU MAKE A CHANGE TO A CLASS/ON RECOMPILING.
Use <scope>runtime</scope> (tells maven this is only for runtime, NOT for compile time dependency so it can ignore for build as not needed),
and <optional>true</optional> (tells maven that this dependency is NOT required by downstream projects, aka projects which take this project's POM as a parent to it, etc., besides you dont want this for production build)


<parent>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-parent</artifactd>
	<version>2.7.5</version>
</parent>

This parent can be added which serves 4 purposes: 
* Centralizes dependency versions without need to specify versions individually.
* Applies sensible defaults for compiler settings, encoding, plugin versions, etc.
* Manages plugin configurations: Like spring-boot-maven-plugin for packaging your app.
* Supports BOM (Bill of Materials): Ensures consistent versions across dependencies.

spring-boot-maven-plugin can be added to <plugins> as a <plugin> artifact so it can package and make FAT executable jars for mvn command to execute springboot directly also.

server.port=8088 # if not specified, 8080 is default
server.servlet.session.timeout=5m


spring-boot-starter-mustache : Dependency which adds support for Mustache template engine, renders .mustache template files for HTML views in controller.

If a dependency is a jar file/packaged project inside same repo/parent project, then you HAVE to ensure that is build and jar is generated first.
Then only other projects which import that subproject will work. (like just do mvn clean install, it works atleast)
IMPORTING A SUBPROJECT INTO ANOTHER SUBPROJECT IS SIMPLE, no extra steps. In root component body of pom.xml,
you specify <artifactId>, and maybe <groupId> right? That is enough, just import using these as <dependency> in the other subproject!!

Any PUBLIC classes, interfaces, beans, configuration, resources, AND TRANSITIVE dependencies declared in that subproject WILL BE INCLUDED! (No Source code ofcourse)


REST (Representational State Transfer) usually doesn't use HttpSession, as REST is supposed to be Stateless, forcing client to maintain state.
Jakarta EE (successor of Java EE, basically javax.* to jakarta.*) is a collection of APIs and specifications for building scalable, secure, and transactional enterprise apps. It covers everything from web services, servlets, and REST APIs to dependency injection, security, and persistence. But Spring MVC DOES NOT IMPLEMENT JAX-RS.

RestTemplate is used to build Rest clients in java.

@RequestMapping is generic annotation which can be equivalent to the composite annotation '@GetMapping(path="xxx")' by
@RequestMapping(path="xxx", method=RequestMethod.GET)

All enumerators are: GET,POST,PUT,PATCH,DELETE,HEAD,OPTIONS,TRACE (for these last 3, there aren't composite Mapping annotations separately)

PUT changes body of existing entity in 1 shot (giving null in some other field WILL SET IT AS NULL typically), where PATCH is ideally for changing one field alone.

Http Status Codes: 200 OK, 30x (Redirects), 4xx Client error (like 404 Not Found), 5xx Server Error (like 500 Internal Server Error)
		   201 CREATED sucessfully (sends back constructed url as "location" header, pointing to resource created), 405 HTTP method not supported,
		   406 Cannot generate Response Body in requested format, 415 Req body NOT supported.

@ResponseStatus(HttpStatus.NO_CONTENT) - If annotated on controller method, Then sends back with given status code.
					(instead of returning ResponseEntity<> as that can set response headers, etc additionally than this)

Note: If method is void, it sends back EMPTY BODY with given response code, aka 204 No Content.

@RequestBody - Annotate this ON THE CONTROLLER METHOD PARAM for PUT/POST to get the Request Body sent as an object.
	      (Can take from JSON/XML sent to endpoint BASED ON Content-Type header sent AUTOMATICALLY)

Warning: ResponseEntity<Void> is returned by controller method IF THERE IS NO CONTENT TO RETURN BUT JUST STATUS CODE ALONE!

UriComponentsBuilder        : Allows Explicit creation of URI, requires hardcoded URLs.
ServletUriComponentsBuilder : Subclass of UriComponentsBuilder, which provides access to URL THAT INVOKED CURRENT CONTROLLER METHOD!

Eg: URI location = ServletUriComponentsBuilder.fromCurrentRequestUri() //takes currently called controller method url
			.path("/{itemId}") //Adds "/{itemId}" to whatever URL this contr. method is called through
			.buildAndExpand("item A") // Substitutes the placeholder Path Variable (WARNING: space becomes %20 when converted)
			.toUri();
ResponseEntity.created(location).build();

RestTemplate: 

Creating RestTemplate using new keyword is fine for normal configuration, BUT IF YOU HAVE PROPERTIES to be used to modify default props,
you can EITHER change in code itself OR properties file:

Eg: @Bean
public RestTemplate restTemplate(RestTemplateBuilder builder) {
    return builder
        .setConnectTimeout(Duration.ofSeconds(3))
        .setReadTimeout(Duration.ofSeconds(5))
        .defaultHeader("Accept", "application/json")
        .build();
}

OR

# Below properties are optional and used by RestTemplateBuilder, SO builder.build() ALONE IS ENOUGH INSTEAD OF ABOVE CODE !
# Set timeouts (in milliseconds), set a root URI for all requests, Set basic auth credentials
spring.rest.template.request-factory.connect-timeout=5000
spring.rest.template.request-factory.read-timeout=10000
spring.rest.template.root-uri=https://api.example.com
spring.rest.template.basic-auth.username=myuser
spring.rest.template.basic-auth.password=mypass


RestTemplate methods: - ("uri" string can have {orderId} path variable, pojo object itemObj here should minimum satisfy these requirements: A public no-arg constructor, all fields getters and setters, serializable fields)

Items[] items    = template.getForObject(uri, Items[].class, "1")  [Gets all items of order id 1]
URI itemLocation = template.postForLocation(uri, itemObj, "1") [Basically POST for 201 CREATED]
ResponseType ack = template.postForObject(uri, itemObj, ResponseType.class, "1") [Basically POST but gets and returns an acknowledgement response as java obj (from json/xml)]
ResponseType ack = template.patchForObject(uri, itemObj, ResponseType.class, "1") [similar to postForObject as above]
		   template.put(uri, itemObj, "1") [PUTs the item obj modified values for item with id "1"]
		   template.delete(uri, "1") [Deletes the given item]
HttpHeaders hdrs = template.headForHeaders(url, "1") [retrieves only the headers, no body.Check metadata like Content-Type, Content-Length]
Set<HttpMethod> allowedMethods = template.optionsForAllow(url, "1") [FOR GIVEN ENDPOINT, WHAT HttpMethod is allowed or not it fetches]

Same way as above, getForEntity() instead returns ResponseEntity<...>, basically same obj but inside ResponseEntity.
Use responseEntity.getBody() to get obj,  response.getHeaders.getxxx() to fetch header values, .getStatusCode() returns HttpStatus.OK / etc.

ResponseEntity<Void> response = restTemplate.exchange(request, Void.class);

To use above metod, you can create as follows the request obj:
RequestEntity<Item> request = RequestEntity.post(new URI(itemUrl))
					.getHeaders().add(HttpHeaders.AUTHORIZATION,
						"Basic "+base64EncodedLoginData)
					.contentType(MediaType.APPLICATION_JSON)
					.body(newItemObj);

Ideally WebClient is preferred in cases of Streaming , and may evolve compared to RestTemplate, which wont, but that DOESN'T mean IT's depreciated.

The trailing variable params, last param(s) end of each restTemplate method like getForObject, postForObject, etc, CAN TAKE STRING of that val,
OR the datatype meant to be used also (like Integer, or just the number as it will autobox), as the values to be substituted
in the uri's "/{id}" part. Actually any type with a proper .toString() implementation WILL WORK apparently!

For static rendering of resources in webapp, springboot looks in "classpath:static", basically static folder in resources folder,
BUT IT WILL LOOK FIRST IN src/main/webapp if such a path exists!

Spring boot also CONVENIENTLY MAPS "/" endpoint to the index.html which SHOULD BE IN main/resources/static OR main/resources/public folders.

RestTemplate methods THROW Exceptions IF STATUS CODE IS NOT 2xx.

assertThrows RETURNS THE EXCEPTION IT EXPECTS TO BE THROWN (and if it is thrown, else it throws its own ERROR - AssertionFailedError) :
HttpClientErrorException exp = assertThrows(HttpClientErrorException.class,()->{...});

Exception handling in Controller involves the @ExceptionHandler annotation, where if any controller method throws specified exception,
This method runs and that exception is a parameter to this. Eg:

@ResponseStatus(HttpStatus.CONFLICT) //Returns 409 status without the method to even return anything.
@ExceptionHandler({ DataIntegrityViolationException.class }) //This exception can occur if while saving to db some constraint is violated (like unique)
public void handleAlreadyExists(Exception ex){...}


Spring Boot Testing Framework (Built on top of Spring Testing Framework): - (spring-boot-starter-test dependency required (<scope> as test))

Eg of annotations: @SpringBootTest,@WebMvcTest,@WebFluxTest,@DataJpaTest,@DataJdbcTest,@JdbcTest,@DataMongoTest,@DataRedisTest
@MockBean annotation helps to mock specific bean.

Dependencies inside starter dependency: JUnit(5),SpringBootTest,SpringTest,AssertJ,Mockito,JSONassert,JsonPath,Hamcrest(library of matcher)

webEnviroment option in @SpringBootTest annotation can be set to RANDOM_PORT / DEFINED_PORT (server.port prop it finds it uses)
TO START WEB SERVER !
MOCK (default, NO REAL webserver started, only mocked using MockMvc) and NONE (no web env) are the other options

WARNING: Simply using @SpringBootTest (which itself is optional while using @Test methods) WILL NOT START THE EMBEDDED WEB SERVER/CONTAINER. Only app and app context will be ready.
	 You need to use this annotation to ensure it does start, or app is running in another terminal/etc :
	 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)


TestRestTemplate bean is always configured if SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT OR .DEFINED_PORT) annotation is there.
[.MOCK (the default val) and .NONE values DO NOT RUN A REAL SERVER, HENCE TestRestTemplate CANNOT BE INJECTED in test class]
Difference between this and RestTemplate is:
* It takes a relative path instead of mandatory absolute path
* Fault Tolerant: It does NOT throw an exception when an error response like 4xx or 5xx occurs from server.
  		  (Except malformed urls (IllegalArgumentException) and unreachable hosts (ResourceAccessException))
* Configured to ignore cookies and redirects.

TestRestTemplate CAN ALSO BE MODIFIED by RestTemplateBuilder (autoconfigured in tests too, so can inject directly) as shown before.
Create a normal restTemplate USING BUILDER, and PASS IT TO CONSTRUCTOR. Eg: new TestRestTemplate(restTemplate)


Mvc test framework does NOT NEED to run web server container to test the controller endpoints!

For MOCK option value:
@SpringBootTest(webEnvironment = WebEnvironment.MOCK)
@AutoConfigureMockMvc //on test class these both should be used, can inject MockMvc bean directly

Code should be like: (mock server, not a real one)
     mockMvc.perform( get("/api/user/{id}" , "1").accept(MediaType.APPLICATION_JSON)) // Can use URI substitution like restTemplate methods; post(), put(), even head(), patch(), options() [all 8] are supported
               .andExpect(status().isOk())                                 // Checks HTTP 200
               .andExpect(content().contentType(MediaType.APPLICATION_JSON)) // Checks response is JSON
               .andExpect(jsonPath("$.name").value("Alice"))              // Checks JSON field "name" is "Alice"
               .andExpect(header().string("X-Custom-Header", "value"));   // Checks custom header is present

// .perform() returns MockHttpServletRequestBuilder, which we can chain methods with like this.
// Required static imports for these is org.springboot.test.web.servlet.request.MockMvcResultBuilders.get; and xxx.request.MockMvcResultMatchers.status;

Other methods of MockMvc to chain from like get()/put()/post(), all INSIDE perform() as 1 parameter:

.param("id", "42")                      // Adds a query parameter ?id=42 to the request, instead can directly substitute in get() 2nd param too.
.requestAttr("userRole", "admin")      // Sets a request attribute accessible in the controller, Request attributes are objects stored in the request scope that can be accessed by controllers, filters, or interceptors using HttpServletRequest.getAttribute().

.header("Authorization", "Bearer xyz") // Adds an HTTP header to the request
.content("{\"name\":\"Alice\"}")       // Sets the raw request body content (e.g., JSON payload), if endpoint expects json, like @RequestBody var.
.contentType(MediaType.APPLICATION_JSON) // Declares the format of the request body as JSON
.accept(MediaType.APPLICATION_JSON)    // Tells the server the client expects a JSON response
.locale(Locale.ENGLISH)                // Sets the request's locale (used for i18n or formatting)

Below static methods are to be used inside 1 .andExpect() each, which itself is chained to perform: (can chain .andExpect() with another, perform() only 1 should be there)

content().string("Hello World")                   // Asserts that the response body is exactly "Hello World"
content().contentType(MediaType.APPLICATION_JSON) // asserts response contentType is json
header().string("Content-Type", "application/json") // Asserts that the response has a header Content-Type with value application/json
header().string("Location", "http://localhost:8080/accounts/21") // For checking location header.
status().isOk()                                 // Asserts that the response status code is 200 OK. isCreated, isNotFound(), isNoContent() are others.
xpath("/user/name").string("Alice")            // Asserts that the XML response has <name>Alice</name> at the given XPath
jsonPath("$.user.name").value("Alice")         // Asserts that the JSON response has "user.name" equal to "Alice"
jsonPath("$..name").value("Alice")	       // Asserts if EVERY OCCURENCE IN ANY RECURSIVE DEPTH LEVEL OF RESPONSE JSON a field name has "Alice" as value.
jsonPath("$[0].name").value("Alice")	       // Asserts first json of LIST 's name property as "Alice".

Note: jsonPath string param "$.user" and just "user" would be IDENTICAL, BUT "$.user.name" IS NOT SAME AS "user.name" (former is correct), since it will assume the context is already in the node "user", so ONLY for 1st level access, both syntax work the same.

Difference between TestRestTemplate and MockMvc: TestRestTemplate DOES need startup of a REAL embedded SERVER using REAL http calls,
		   Whereas MockMvc does In-memory simulation via DispatcherServlet. MockMvc is ideal only for Controller Slice Tests, not exactly unit test or integration but inbetween somewhat.


.andDo(print())                      		   // Logs the full request and response details to the console for debugging
.andDo(result -> assertTrue(result.getResponse()
	.getContentAsString().contains("Alice"))) // Executes custom logic after the request, useful for advanced assertions or side effects

.andReturn()              // Eg: MvcResult r = perform(...).x.x.x.andReturn();  // Returns the MvcResult object so you can inspect the response manually (e.g., extract body, headers, status)

Note: Basically andDo lets you access MvcResult object (above eg. shows result variable) which you can use to inspect response/request,
      BUT if you wanted to stop for now and check in further lines, you can instead end the parent level chaining with .andReturn(); ,
      which will return MvcResult obj. In later lines, you can do SAME THING YOU COULD'VE DONE INSIDE andDo() example as above!


@WebMvcTest(MyController.class)       // Web slice testing: loads only web layer (controllers, filters, etc.) for fast controller testing

Disables FULL autoconfiguration and instead apply ONLY configuration relevant to MVC tests OF GIVEN CONTROLLER CLASS.
(aka controllers, filters, exception handlers, and related config & beans OF Controller.class you pass as param to the annotation!)

MockMvc bean (as seen before) is autoconfigured, and optionally Spring Security too.

@MockBean is used to mock & inject any other beans you will need which ISNT part of the mvc like service class beans etc.

To add MOCK BEHAVIOUR TO @MockBean injected object in test class:
given(userService.getUserName(1L)).willReturn("Alice"); // When getUserName(1L) is called, return "Alice".
given(userService.getUserName(anyLong())).willReturn("Alice"); //to accept any long
given(userService.getUserName(any(Long.class))).willReturn("Alice"); //GIVEN DATATYPE value is accepted,
								     //OR alternatively use just any() FOR ANYTHING to be accepted!
given(...).willThrow(new Exception()); //similar to willReturn except it throws given exception obj. 

verify(userService).getUserName(1L);  // Verifies that getUserName(1L) was called once, can have 2nd param for verify() call to specify times(2) or atMost(3) or never(), etc. (frequency of calling)

verify(userService).getUserName(any(Long.class)); // or the other anyXXX() methods you see above CAN BE USED HERE SIMILARLY for more generalized matching.

Warning: @Mock from Mockito creates a bean which is NOT PRESENT OR MANAGED IN SPRINGBOOT CONTEXT. Like inside controller,
if i injected a bean i want to mock there, by executing controller method in test I CANT CHANGE THAT INJECTION, so @MockBean springboot annotation is needed.


@DataJpaTest                          // Repository slice: loads JPA repositories and related config for testing database access

Loads @Repository beans, excludes all other @Components. Autoconfigures TestEntityManager, an alternative to EntityManager (for helper methods alone for entity management during testing like persistAndFlush() or persistFlushFind())

@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) //Used on test class to say basically: "use configured db in properties file". IF YOU OMIT THIS ANNOTATION OR just use .ANY option instead, it will assume you want a lightweight IN-MEMORY db for testing purposes.

@CacheTest                    // Caching slice: loads only caching-related beans to test cache behavior and configuration (like CacheManager)


Spring Security : - (Portable, Separations of Concern, Flexible)
Principal: User, device or system that is contacting api and performing an action

Authentication: Establishing principal's credentials are valid

Examples of auth mechanisms: Basic, Digest, Form, OAuth2.0/OIDC, X.509. Can store credentials in a external (or inmemory for dev) db or Lightweight Directory Access Protocol (LDAP) storage in cloud to authenticate by sending there the credentials to get verified.


Authorization: Deciding if a principal is allowed to access a resource.

Authority: Permission or credential enabling access (such as role)


All secured resources (as configured) will have to be accessed by execution thread through SecurityContext.

AuthenticationManager checks for Valid credentials, if found to be correct, 
Then this will ADD the Principal and Authorities to the SecurityContext (SecurityContext will be EMPTY BEFORE THIS)

BUT BEFORE ACCESSING SecuredResources,  there is a "Security Interceptor",
which will send these information to AuthorizationManager (to check if this user has access to this resource), then lets you access.

3 Steps for Spring Security: -
* Defining Filter chain

  DelegatingFilterProxy bean is autoconfigured by SpringBoot and is required for this filterchain.
  ALL THIS HAPPENS INSIDE THE SERVLET CONTAINER.
  The request first goes into the DelegatingFilterProxy bean, which redirects to springSecurityFilterChain,
  where there is implementation consists of many spring configured filters, and it goes through from 1 to N of all filters,
  Then only only goes to DispatcherServlet and so on.
  
  NOW Response GOES BACK THE SAME ROUTE FROM DispatcherServlet back to user! (coz They might modify response headers, log/audit, handle exceptions, clean up resources, etc)

Basic Path of what happens overall: -

Request enters servlet container → DelegatingFilterProxy → springSecurityFilterChain → AuthenticationManager checks credentials,
SecurityContext gets filled with Principal + Authorities → FilterSecurityInterceptor checks with AuthorizationManager if user can access resource,
request goes to DispatcherServlet → controller runs → response comes back through same filters in reverse → out to user.

[Note: FILTERS ARE RUN IN REVERSE ORDER IN RESPONSE PATH, And authentication & Authorization Managers are NOT REPEATED AGAIN!]

The Spring Security Filters can have more, but usual basic filters are:
* SecurityContextPersistenceFilter - Establishes/Finds SecurityContext in session to set for current thread, to maintain between HTTP requests.
* LogoutFilter - Clears SecurityContextHolder when logout requested.
* UsernamePasswordAuthenticationFilter - Puts Authentication into SecurityContext on login request
* ExceptionTranslationFilter - Converts SpringSecurity exceptions into HTTP response or redirect.
* AuthorizationFilter - Authorizes web requests based on config attributes and authorities.

Remember: Not all of these filters always no something, like in some cases literally SecurityContextPersistenceFilter and AuthorizationFilter run.

IF DEFAULT SECURITY SETUP enabled, SpringBoot Security sets up a SINGLE IN-MEMORY USER called "user",
AUTOGENERATES a UUID password. Relies on Spring Security's content-negotiation strategy to determine whether to use httpBasic or formLogin.
ALL URLs REQUIRE A LOGGED-IN USER!



Configure the FilterChain and the AuthenticationManager (indirectly) by configuring these 2 beans like below (AuthenticationManager asks UserDetailsService for the details, thats why i say this configures that) : -

// BELOW CODE USES "Ant-style" pattern matching for the suburls
// "/admin/*" would match ONLY suburls like "/admin/xxx" (i.e /admin should be direct parent)
// "/admin/**" will match ANY SUBURL with ANY DEPTH as long as it starts with "/admin/" (yes, the 2nd slash is hardcoded in this example so it's required, i.e "/admin" WONT be matched by this. for that you need "/admin**" then it will match anything after /admin)

@Bean
public SecurityFilterChain filterChain(HttpSecurity http){
    http.authorizeHttpRequests(
        (authz) -> authz
	    .requestMatchers("/public/**").permitAll()       // Anyone can access /public/...
	    .requestMatchers("/secret/**").denyAll()	     // Denies ALL requests to this suburl
            .requestMatchers("/admin/**").hasRole("ADMIN") // Only users with ADMIN role can access any /admin/... URL
            .requestMatchers(HttpMethod.PUT,"/accounts/edit*").hasRole("ADMIN") // Only ADMINs can perform PUT on /accounts/edit...
            .requestMatchers("/accounts/**").hasAnyRole("USER","ADMIN") // USER or ADMIN can access any /accounts, can use/... URL
            .anyRequest().authenticated()); // All other requests require authentication (any logged-in user)

	   //All the permitAll,denyAll,hasRole,authenticated, etc. can be used (mix & matched) with anyRequest and requestMatchers ALSO!
	   // MOST SPECIFIC APPEARS FIRST AND GETS MORE GENERAL AS YOU GO BELOW.
}

Warning: There are NO PREDEFINED ROLES in spring security. Following methods are DEPRECIATED (requestMatchers is the replacement):
.antMatchers("/admin") [only matches /admin] and .mvcMatchers("/admin") [matches /admin, /admin/]

Below is a way to BYPASS FilterChain COMPLETELY for some endpoints: [.permitAll() STILL MEANS IT PASSES THROUGH FILTER CHAIN, so this is better for less overhead]

@Bean
public WebSecurityCustomizer webSecurityCustomizer(){
	return (web) -> web.ignoring().requestMatchers("ignore1", "/ignore2"); // THESE URLs ARE NOT CHECKED if specified like this
}


Spring Security Authentication Flow: - (More detailed beans/objects than previous depiction, <<XXX>> denotes interface type)

Http request -> BasicAuthenticationFilter				  [Creates Authentication type object with EXTRACTED username & password]
	      ( <<Authentication>> UsernamePasswordAuthenticationToken )
	
	     -> ProviderManager (of type <<AuthenticationManager>>)  --provides--> <<AuthenticationProvider>> impls like DaoAuthenticationProvider.		
	     -> calls loadUserByUsername() method of a <<UserDetailsService>> implementation (This happens ONLY in the case of 					DaoAuthenticationProvider alone). Retrieves user-related data from identity store. Fetches from either:
			* In memory User defined details (InMemoryUserDetailsManager)
			* Relational DB tables (JdbcUserDetailsManager)
			* LDAP directory queries (LdapUserDetailsService) to use Ldap identity store
			* Custom logic to fetch (CustomUserDetailsService, implement your own loadUserByUsername() method)

	     -> The UserDetails object is returned by UserDetailsService impl, which goes back THE SAME ROUTE IT CAME (aka first to 				DaoAuthenticationProvider , then back to the ProviderManager (which is impl of AuthenticationManager) and back to 				BasicAuthenticationFilter.

		Now this filter populates the SecurityContext with this object, where this obj ALSO HAS THE AUTHORITIES ASSOCIATED WITH THE USER.


Other AuthenticationProvider types than Dao: Ldap, OpenID, RememberMe, etc.

Note: InMemoryUserDetailsManager IMPLEMENTS << UserDetailsService >> AND << UserDetailsManager >>,
has SAME PLUS MORE FUNCTIONS than InMemoryUserDetailsService like: createUser,updateUser,deleteUser,changePassword,userExists

Below way can be used to define the Bean to provide UserDetailsService IN-MEMORY implementation (ideal only for development/local env):

@Bean
public InMemoryUserDetailsManager userDetailsService(){
	UserDetails user = User.withUsername("user").password(passwordEncoder.encode("user")).roles("USER").build();
	UserDetails admin = User.withUsername("admin").password(passwordEncoder.encode("admin")).roles("ADMIN").build();
	
	//Supply UserDetails objects to a MANAGER's constructor, called InMemoryUserDetailsManager()
	return new InMemoryUserDetailsManager(user, admin); // put all the UserDetails objects (users/roles) you want as parameters.
}

@Bean public UserDetailsManager userDetailsManager(){ return new JdbcUserDetailsManager(dataSource); }

Basically order of inheritance: <<UserDetailsService>> <-implements- JdbcDaoImpl (has read only functions: getting username password, and authorities of users),
<-extends- JdbcUserDetailsManager (also implements <<UserDetailsManager>>)

Queries RDBMS (overridable) for users and authorities (like "SELECT username,password,enabled FROM users" or "SELECT username,authority FROM authorities"). Groups are also supported (tables like group, group_members, group_authorities).


2 ways for Custom Authentication:
* Implementing UserDetailsService interface : UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
OR
* Implementing AuthenticationProvider interface: Authentication authenticate(Authentication authentication) throws AuthenticationException;
						 boolean supports(Class<?> authentication);

PassworkEncoders are used to hash passwords to store in DBs (one way unlike encrypt/decrypt).
MD5PasswordEncoder and SHAPasswordEncoder ARE DEPRECIATED (they are broken now).
BCryptPasswordEncoder is currently recommended.

Eg: To use passwordEncoder in statement like: User.withUsername("user").password(passwordEncoder.encode("user")).roles("USER").build();
    
    PasswordEncoder encoder = PasswordEncoderFactories.createDelegatingPasswordEncoder();
   //as bcrypt is current default, "{id}pswd" is the format, where id is the pswd encoder used. Eg: {bcrypt}$2r4fsff...    


//CHANGED HERE
WARNING: While MD5 and SHA-1 are BROKEN now,
SHA-256, SHA-384, SHA-512, SHA-3 and all SHA variants ARE UNSUITABLE and NOT IDEAL as they are still subjected to bruteforce attacks, dont use any 'salt', etc.

So IF ASKED WHICH IS BROKEN ALREADY, only those 2, else these ALL are unsuitable.

Only BCrypt, SCrypt, Argon2, Pbkdf2 algorithms are good to use.


HttpSecurity obj has MORE methods than just authorizeHttpRequests.

@Bean
public SecurityFilterChain filterChain(HttpSecurity http){
    http.authorizeHttpRequests(
        	(authz) -> authz.requestMatchers("/admin/**").hasRole("ADMIN")
			   ...
            	   	   .anyRequest().authenticated())
	
	.httpBasic(withDefaults()) // ENABLES HTTP BASIC AUTH (Browser prompts for username & password)

	/* 	ExceptionTranslationFilter will intercept any request WITHOUT HEADER having credentials, and SEND BACK 401,
		with a response header "WWW-Authenticate: Basic". Browser understands this exactly means it shows a small
		native dialog box asking for username and password. Once submitted, "username:password" is formatted so and encoded
		using Base64, and request is resent with header "Authorization: Basic base64EncodedCredentials".
	*/
				      

	[OR]

	.formLogin( form -> form.loginPage("/login")   // Sets up form-based auth, the given url is used when login needed
				.permitAll() 	     ) // Any user can access

	/*	ExceptionTranslationFilter intercepts any unauthenticated request, and redirect the browser to the login page
		(`/login`). The user fills out a form and POSTs credentials to `/login`. Upon submitting to POST "/login", a session
		is created, a `JSESSIONID` cookie is sent to the browser, and the user is redirected to the original requested URL.
		A simple DEFAULT /login page will be created too IF YOU DONT SPECIFY login page, like .formLogin(withDefaults()).

		WARNING: the JSESSIONID cookie which is sent as response header "Set-Cookie" IS NOT LIKE A TOKEN, it will maintain
		a session, WHETHER of a user or anonymous, that's all. BUT YES if a user is ALREADY logged in according to springboot,
		Then a matching JSESSIONID means it will consider the req authenticated. Basically SecurityContextPersistenceFilter
		looks in the corresponding HttpSession of cookie, and a SecurityContext WILL BE THERE IF USER IS AUTHENTICATED ALREADY.
		The SecurityContext would've been created during successful login and stored in the HttpSession,
		so now it will be placed in SecurityContextHolder.

		TLDR: SESSION cookie isn't EXACTLY a token, but IF YOU WERE LOGGED IN in the session before, HttpSession obj
		IN THE BACKEND is stored and checked for right session using cookie, and THAT OBJECT tells your authenticated or NOT.
	*/

	.logout( logout -> logout.logoutSuccessUrl("/home") ) // Configures logout, goes to given url after logout (any user can access)

	/*
		When a request is sent to `/logout`, the LogoutFilter intercepts it. The user's HTTP session is invalidated,
		the `JSESSIONID` cookie is cleared from the browser, and the browser is redirected to the specified
		`logoutSuccessUrl` (`/home`) as an unauthenticated user.
		The "Set-Cookie" header for JSESSIONID cookie is sent back with "Expires" set to past time, INDICATING browser to clear it. Springboot also DELETES the SecurityContext associated with the HttpSession object.
	*/

	return http.build();
}


Method Security: (method level security even for Service classes etc, OTHER than web based security)

Same way as AOP proxies work, you CAN ENABLE (using certain annotations) security for even other layers like service classes, etc.
When a request is sent with a Service bean as target, the SpringSecurityInterceptor will intercept it, and
asks the AuthorizationManager if the user has Permission/authorization for this resource, if yes, THEN target method is invoked.
Else, AccessDeniedException is thrown if not allowed.


@PreAuthorize("hasRole('MEMBER') && #order.owner.name == principal.username") // to be used ON A Method
public Item findItem(Order order, long itemNumber){...} // This annotation checks BEFORE executing the method itself if condition is
							   true. 1st condition checks if current User has specified role,
							   Next it checks if order object in formal param has owner.name == username

Built-in variables
authentication:			The current Authentication object from the SecurityContext.
authentication.name:		The username of the authenticated principal.
authentication.authorities:	The collection of authorities (roles) granted to the user.
principal:			A shortcut that provides direct access to the principal object, equivalent to authentication.principal.
returnObject:			The object returned by the method. Only available in @PostAuthorize expressions.
filterObject:			The current object in the collection or array that is being filtered. Used in @PreFilter and @PostFilter

Note: You can ALSO use "#" followed by a parameter name TO ACCESS METHOD PARAM objects in these expressions! For example, in a method myMethod(User user), you can access the user object with "#user" and do stuff like "#user.id". 

@PostAuthorize: Evaluates an expression after a method has been invoked. It can inspect the method's return value to decide access.
		This is useful for preventing a user from seeing an object that doesn't belong to them, even if method access was there
		for their user. Example: @PostAuthorize("returnObject.owner == authentication.name").
@PreFilter: Filters the arguments of a method before it is invoked. It works on collections or arrays and allows you to remove elements
	    based on a given expression. Example: @PreFilter("filterObject.owner == authentication.name").
@PostFilter: Filters the returned value of a method after it has been executed. It iterates through the collection or array returned by
	     method and removes any elements for which the expression is false.
	     Example: @PostFilter("hasPermission(filterObject, 'read')").  [YES hasPermission is PREDEFINED METHOD: PermissionEvaluator.hasPermission(authentication, filterObject, "read")]


spring-boot-starter-security: Just including this dependency will cause default login page to appear (Username is "user", password is dynamically generated and shown in console when starting up app)
			      For logout, you just access the /logout suburl and click yes on the button in webpage to logout successfully. (Reloading page doesnt affect the logged in or out status as using the JSESSIONID cookie session is recovered)


In @Test methods for spring boot security, you can make test do api calls with TestRestTemplate using restTemplate.withBasicAuth(username,pswd)
In mockMvc 's case this should be done: mockMvc.perform(get("/...")).with(httpBasic("user", "password"))) 

@WithMockUser(username = "user", password = "user", roles={"USER"}): Similar to basicAuth, except simply annotating this on @Test will
			  					     use mock user details given for authentications like filterchain
								AND @PreAuthorize, etc (method security too). No UserDetailsService used

@withUserDetails("joe") - Similar to above annotation and practically can instead use withBasicAuth(), but that needs filterchain etc setup. Here this will USE A REAL USER unlike @WithMockUser, from the UserDetailsService, so that bean's working also can be tested.

(For both annotations, a SecurityContext is created and placed in SecurityContextHolder, thats how these annotations work.)

Warning:
	Eg: MyObject[] myObjectArray = restTemplate.getForObject(url, MyObject[].class);

	While calling using xxForObject and xxForEntity methods in both RestTemplate and TestRestTemplate, if List<> generics is used
	to fetch an object of that type using these methods, DUE TO TYPE ERASURE YOU WILL GET ERROR!
	Using ARRAYS IS the WORKAROUND instead, but IDEALLY use restTemplate 's EXCHANGE METHOD AS IT WILL SOMEHOW REMEMBER GENERIC TYPE
	at runtime (forEntity and forObject are depreciated)

	Eg: ResponseEntity<List<MyObject>> responseEntity = restTemplate.exchange(url, HttpMethod.GET, null,
										new ParameterizedTypeReference<List<MyObject>>() {} );
	
To fetch the grantedAuthorities as a Collection, use this code:
	SecurityContextholder	// injected, helps get SecurityContext
	.getContext().getAuthentication().getAuthorities() //Gets the roles/"authorities" of this user from Authentication obj
	.stream().map(GrantedAuthority::getAuthority).collect(Collectors.toList()); //To convert to proper List<String> from Collection<? extends GrantedAuthority>


@Primary - is annotated on bean declaration to specify it as MAIN contender over other qualifying beans.
	   @Qualifier is used AT INJECTION SITE and can EASILY OVERRIDE @Primary.

Ways to custom define your UserDetailsService and AuthenticationProvider :-

class CustomUserDetailsService implements UserDetailsService {	@Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {...}	}

class CustomAuthenticationProvider implements AuthenticationProvider { @Override public Authentication authenticate(Authentication auth) throws AuthenticationException {... //this parameter has credentials from client haven't been verified
	...
	return new UsernamePasswordAuthenticationToken(username, password, AuthorityUtils.createAuthorityList("ROLE_ADMIN"));
} }


Actuators: -

Production grade monitoring without implementing it ourselves, can return metrics and health indicators.
Can integrate with 3rd party systems for aggregating and visualization.

JMX(Java Management Extensions) is a technology that exposes your application's operational data and management capabilities through a standard Java-based protocol. This can be used for fetching data from actuator. (more fine grain control)
OR
Http protocol api calls:
/actuator/health - Default response is just { "status":"UP" }. (later using dbs it does checks internally for that too)
/actuator/metrics - { "name":["jvm.memory.max","http.server.requests"...]} (Lists of most available metrics, MAYBE NOT ALL INBUILT ONES)
/actuator/{metric_name} - If you use one of the names from list, you can fetch the details like:
{"name":"http.server.requests", "measurements":[ {"statistic":"COUNT","value":13} , ...], // tells 13 http reqs received till now
	"availableTags":[{"tag":"method", "values:["POST","GET"],.."}] } 		  //mentions what all http methods available

(spring-boot-starter-actuator dependency's presence alone adds these endpoints, here are more endpoints of /actuator/xxx):
/beans - List of all Spring beans created by app with details like scope, datatype, resource and dependencies.
/conditions - Report of AutoConfiguration classes with reasons why or why not they were applied.
/env - Gives all system properties, environment vars, etc. (from ConfigurableEnvironment)
/configprops - Collated list of all @ConfigurationProperties
/info - Arbitary application information YOU specify, empty by default unless you add some properties in yml or .properties files.
	Needs <executions><execution><goals><goal> build-info </goal></goals></execution></executions> SET for spring boot maven plugin,
	So it generates atleast empty build file to display in this endpoint. (in target/classes/META-INF/build-info.properties)

	management.info.java.enabled=true	#Displays details about "java":{...} in /info response json
	management.info.env.enabled=true	#Takes info from properties (as below statements), env, etc. & includes in "build":{...}
	
	NOTE: All info.xxx=value OR info.xxx.yyy=value ,etc properties will be included in /info response json as like
	{"xxx":value,...} AND {"xxx":{ "yyy":value },...}. (Basically represent the json path as property and it will also be in /info)

/loggers - Query about logging levels of different packages
/mappings - ALL the Spring MVC's @RequestMapping paths are fetched.
/session - Fetch or Delete user sessions (only if using Spring Session)
/shutdown - (DISABLED BY DEFAULT) Shuts down app gracefully.
/threaddump - Performs threaddump, basically provides snapshot of ALL running threads in JVM at the moment, with stack traces,
	      thread states, lock acquired/not informations, etc.
/jolokia - Exposes JMX beans over HTTP (not just actuators)

POST /loggers/{any.package.name} {"configuredLevel":"INFO"}	- Changes the logging level FOR THAT PACKAGE AT RUNTIME!

Enabled means endpoint is created and req bean(s) is in application context. Like,
All endpoints are "Enabled" BY DEFAULT EXCEPT /shutdown suburl.

Exposed means endpoint is accessible via JMX or HTTP.
HTTP by default exposes only /health (/into too in springboot 2.x.x but not in 3.x.x) , whereas JMX by default exposes ALL ENABLED ENDPOINTS.

(JMX capability is only available when spring.jmx.enabled=true,
Http capability is ONLY available when using Spring MVC, WebFlux, or Jersey)

/actuator/xxx is by default the suburl for actuator BUT IT IS CUSTOMIZABLE:
management.endpoints.web.base-path=/admin

# Below property CAN EXPOSE MORE ENDPOINTS
management.endpoints.web.exposure.include=beans,env # OR JUST USE * as this property's value, indicating ALL ENDPOINTS to be exposed.

WARNING: Though /health is exposed by default, IF THIS ABOVE PROPERTY IS USED to customize and YOU DONT MENTION IT TO BE EXPOSED,
	 Then it WON'T BE EXPOSED. ('health' is default value of this property, so you cant just OMIT "health" & expect it to be there)

Usually to secure actuator endpoints, you simply use .requestMatchers as seen before:
http.authorizeHttpRequests((authz)-> authz
	.requestMatchers("/actuator/health").permitAll()
	.requestMatchers("/actuator/**").hasRole("ACTUATOR")
	.anyRequest().authenticated());
return http.build; // to return a SecurityFilterChain object as Bean from this @Bean method

Now WHAT IF default ACTUATOR endpoint is CHANGED/CUSTOMIZED later? Yes we can change hardcoded values but here is alternative lines:
	.requestMatchers( EndpointRequest.to(HealthEndpoint.class) ).permitAll() // Both can work "base-path agnostic" 
	.requestMatchers( EndpointRequest.toAnyEndpoint() ).hasRole("ACTUATOR")     i.e not knowing base path and still working


Metrics:
Micrometer is monitoring or metrics facade which collects metrics IN A VENDOR NEUTRAL WAY.
it's like slf4j is for logging (It ISNT the implementation, but is like interfaces, easy to use but you also include actual impl too).
Barely adds any overhead.

Custom Metrics CAN BE CREATED, but its NOT ENDLESS POSSIBILITIES, instead you are limited to do BASED ON certain types like:
Counter: Used for measuring a single, non-decreasing value over time. It can only be incremented.
Gauge: Used for measuring an instantaneous value that can go up or down. (Like size of current threads or memory)
Timer: Used for measuring the duration of event and its frequency. It provides a count of events, the total time, and the maximum time.
Distribution Summary: Similar to a timer, but for non-time-based values. It measures a distribution of events. Eg: Tracking the size
		      of payloads in bytes or the number of items processed per batch.

MeterRegistry: A Bean where such Classes are created or REGISTERED

You would want to use arbitrary combo of values to check the metrics for, like: Http method, URI, response & exception status, etc.
2 Ways to access metrics data on Http requests:
Hierarchical Metrics: This basically ARRANGES THE METRICS INTO DIRECTORY-LIKE STRUCTURE, like for given metric, inside that dir subfolders for each uri, then subdirs for each HttpMethod available, and inside that for each statusCode received.
Disadvantage is if you want some "total" of some metric in each req, you will have to do RECURSIVE SEARCH AND ADD in the directories. Main Disadvantages are consistent naming convention hard to achieve and adding new attribute may break existing queries (if exact path slightly changes as its a "hardcoded" query). Eg: Metrics > http.server.requests > uri=/api/users > method=GET > status=200 > count

Example to access value: http.method.get.status.200 (key AND value are linearly placed in left to right order)

Dimensional Metrics: (How Micrometer ACTUALLY WORKS) Metrics are tagged (aka Dimensional)

Examples: http?tag=method:get&tag=status:200 , http?tag=method:get&tag=status:200&tag=region:us-east
	 (Flexible Naming Convention, and Adding a new attribute is easy.)

Timer: (basically how to use one of the types of metrics called Timer)
[ Gives count, mean, max and total of it's metric ]

* Inject MeterRegistry (holds all metrics related beans)
* Timer timer = registry.timer("orders.submit"); //gets timer object and sets Metric name as "orders.submit"
						 ( "/actuator/metric/orders.submit" suburl gets you this metric details)
* to use Timer obj in controller method to get stats on the time taken by controller method code:
	-> 	@PostMapping("/orders") public Order placeOrder(...) {
			return timer.record( ()->{/* ALL THE CONTROLLER METHOD CODE INSIDE TO TIME */} );
		}
		// YES, the record method RETURNS EXACT SAME OBJ AS lambda code in it, solely only diff is that it times it.

[OR]...
Simply ANNOTATE @Timed("orders.summmary") on controller method AND IGNORE THESE ABOVE 3 STEPS !!!
(Yep , that easy, if doing on controller method normally, TimedAspect bean is Autoconfigured by springboot)


DistributionSummary : Similar to timer as it gives count, max and total fields by default of a value you ask it to record each time the controller method code runs. simple as that. But code to use IS LONGER than timer.

* INJECT MeterRegistry in constructor of controller class and have class level final DistributionSummary summary;

* summary = DistributionSummary.builder("reward.summary") //specifies metric name
				.baseUnit("dollars") //optional, simply a field for clarity shown when fetching this metric.
				.register(registry); //Registers in the meterRegistry obj

* Inside controller method code, simply invoke:
  summary.record(intOrLongOrFloatOrDoubleValue); //it will convert to double and use

In /actuator/metric/reward.summary , output json will be like: { "name":"reward.summary",
								 "baseUnit":"dollars",
								 "measurements": [
											{ "statistic":"COUNT", "value":3 },
											{ "statistic":"TOTAL", "value":13 },
								 "availableTags":[]
								]}

Counter: 
Counter counter = meterRegistry.counter("account.fetch","type","fromCode"); //1st param-Metric name, 2nd & 3rd param is key-value tag as disussed before
counter.increment(); //When invoked, metric "statistic":"COUNT" 's value increases.

Warning: EVEN if this above call is done in MULTIPLE CLASSES WITH SAME metric NAME, counter WILL HAVE SAME INSTANCE, NOT NEWLY CREATED.

Note: to add tags simple use .tags(key,value) to add a tag to these metric objects when building, OR constructor call in counter's case.
      Similarly .withDetail(key,value) is SIMILAR TO TAGS but in Health object builder, rendering instead inside "details" json, which 
      is inside the healthCheck custom class/indicator you created (indicator name is class name BUT IN CAMEL CASE), inside "components"

//CHANGED HERE

	Eg: Timer timer = Timer.builder("api.request.duration")		//EXCEPT GAUGE ALL HAVE BUILDER METHODS/CLASSES like this!!!
   				 .tag("endpoint", "/users")
   				 .tag("method", "GET")
    				 .description("Request duration")
    				 .register(meterRegistry);

Note: ALL the metrics shown till now HAVE registry obj methods to create them, INCLUDING GAUGE AND DISTRIBUTED SUMMARY.
      Syntax of BOTH THIS AND BUILDER WAY OF CREATING METRIC OBJ IS SAME FOR ALL EXCEPT GAUGE !!!
	Eg: registry.gauge("queue.size", taskQueue, Queue::size); // 2nd param is OBJECT TO WATCH FOR, 3rd param is METHOD REFERENCE OR LAMBDA to APPLY ON OBJ TO GET GAUGE VALUE!!!


Summary of available statistics in these 4:

Counter: count only
Gauge: current value only
Timer: count, total time, max, mean, percentiles, histograms
DistributionSummary: count, total, max, mean, percentiles, histograms

Warning: HISTOGRAM AND PERCENTILES NEED ENABLING LIKE:

management.metrics.distribution.percentiles-histogram.http.server.requests=true
management.metrics.distribution.percentiles.http.server.requests=0.5,0.95,0.99

OR

SomeRandomMetric.builder("api.request")
    .publishPercentiles(0.5, 0.95, 0.99)
    .publishPercentileHistogram()
    .register(registry);


Health indicators in /actuator/health: -

BY DEFAULT /health suburl returns { "status":"UP" } , which DOES NOT seem USEFUL. BUT USE BELOW PROPERTY FOR MORE DETAILS! :
management.endpoint.health.show-details=always		# This ensures to show breakdown of app health details.

With this property in place, now the response json would look like:

{
  "status": "UP",		# Even if 1 is down, this shows as down (regardless of property file "show-details" config)
  "details": {			# This "details" property in springboot 2.x.x is "components" in springboot 3.x.x (not 100% sure)
    "db": {
      "status": "UP",		# A sample validation query like "SELECT 1;" is executed to check if db is UP or DOWN BY DEFAULT.
      "details": {
        "database": "MySQL"
      }
    },
    "diskSpace": {
      "status": "UP",		# This is UP if ATLEAST 10MB space is free BY DEFAULT.
      "details":{"total":499963170816,...}
    }
  }
}

GROUP Health Indicators: You can group health indicators for ease of configuring (for eg, group "system" you can use property to display details of those indicators, meaning all health indicators in that group are set to display).

management.endpoint.health.group.somegroupname.include=diskSpace,db	      #Can have multiple indicators grouped to configure easier together

management.endpoint.health.group.somegroupname.show-details=always	      #ONLY details of indicators in "somegroupname"(aka diskspace & db) are
					      present in /actuator/health response (NO CHANGE IN RESPONSE FORMAT just because of groups)
								      #Rest of indicators NOT affected if configured like this

management.endpoint.health.status.order=FATAL,DOWN,OUT_OF_SERVICE,UNKNOWN,UP
[Built in status values are : DOWN, OUT_OF_SERVICE, UNKNOWN, UP] (default order is this, So if FATAL is encountered, that case ALONE SPECIALLY is treated like it's DOWN)

Fun fact: If show-details property is always for a group but NOT overall, then only components are listed with status value alone in /health
	  general response, but /health/{componentName} will give proper details. i.e, in /health youll only see each component's status, but using component specific url u can see details

Several health indicators are AUTOMATICALLY SET UP if DEPENDENCIES ARE IN CLASS PATH, like DiskSpace,DataSource,Cassandra,Elasticsearch,InfluxDb,JMS,Mail,MongoDB,Neo4J,RabbitMQ,Redis,Solr,etc.
(Basically anything springboot does Autoconfiguration for)

What if you wanted to include Health Indicator to show status OF AN EXTERNAL SERVICE?
YOU CAN CUSTOMISE THE health indicator to include external api health YOURSELF using CUSTOM CLASS!

2 Ways to do this is : 
* Implement health() method of HealthIndicator interface

@Component
public class MyCustomHealthCheck implements HealthIndicator {
	@Override public Health health(){ //Use custom logic to contact external api, etc.
		return Health.down()	        //Builds Health object indicating DOWN status CONDITIONALLY if you custom logic says so.
			.withDetail("someFieldOrMetric",0).build();   // TAKES ANY KEY-VALUE PAIR to show in the "details" section.
	}
}

//CHANGED HERE
* [OR] Can Extend AbstractHealthIndicator and override below method doHealthCheck() method:

protected void doHealthCheck(Health.Builder builder) throws Exception {
	builder.up().withDetail("service", "available"); //instead of return Health.up()... you dont return anything and use builder.
}
//ANY EXCEPTION THROWN INSIDE METHOD IN ABSTRACTHEALTHINDICATOR's case alone IT WILL AUTO CONSIDER STATUS AS DOWN!!!

Output json /health will have:
{ "status":"DOWN",
  "details":{
		"myCustomHealthCheck":{ "status":"DOWN",		# Name is taken from class BUT USES CAMEL CASE INSTEAD!
					"details":{
						    "someFieldOrMetric":0	# .withDetail(K,V) key value pairs U GIVE DISPLAYED HERE
						  }},
		"diskSpace":{"status":"UP",...},...
	    }
}

Health.up().withDetail("key","val").build() is another method call to indicate status UP.
Health.status("RANDOM_VAL").xx.yy... can be used to specify a CUSTOM STATUS or UP or DOWN too!
0
Ensure to use this property: management.endpoint.health.status.order=FATAL,DOWN,OUT_OF_SERVICE,UNKNOWN,UP
Or else it will treat your custom status as UNKNOWN and WILL NOT AFFECT THE AGGREGATE health status of your app. (BUT OTHERWISE THAN THIS CASE,it just picks LEFTMOST aggregate status)
Aka not mentioned ones are like LOWEST POSSIBLE PRIORITY AND WiLL BE IGNORED UNLESS THERE IS NO OTHER STATUS IN TOTAL WHICH IS ACTUALLY IN THIS order property.

(management.endpoint.health.group.randomgrp.status.order=... is a way TO SPECIFY STATUS ONLY FOR PARTICULAR GROUP!
More like basically anything to specify for a group use like management.endpoint.health.group.<grpname>.yyy format)


Ideally these data especially /metric/XXX ones SHOULD BE SENT TO EXTERNAL SYSTEMS, TO GRAPH or find statistical representations, like:
Atlas (Netflix), CloudWatch, Datadog, Dynatrace, Graphite, JMX, InfluxDB, Prometheus, Wavefront (VMware),etc.
(Above names like the 3 micrometer-registry's : Prometheus, Graphite, and InfluxDB implementations are standard impls to micrometer which is like interfaces.)


---------------------------------------------------
==================================================

NOTES: -
* Springboot scans and takes default/no param constructor if multiple are there, one is there means it takes that constructor. Else it raises error.

* Mix and matching field and constructor injection in a component is fine,  but remember that in test if I create by constructor,
  Now field injection ALONE WILL BE NULL, and if you forget this fact, youll keep testing how all others aren't null except that obj.

* Usually SpringApplication.run() will have the Configuration file it uses, now any AspectConfig or something you have to add means, just Import AspectConfig into that main config.

* WARNING ABOUT ASPECT (AOP): If Spring proxy-based AOP	is used, then Injecting bean from Spring only will work as expected with aspects, NOT with objects created with "new" keyword. (You already know this)
  I thought It was malfunctioning, BUT I TESTED AND IT's right, see below output and observe how if new is used t create the class obj whose method should be observed by aspect, then no it wont work.

RewardNetworkImpl.rewardAccountFor() was called & Started
Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!
THE SECTION OF CHANGE IS OVER
THIS is the test where RewardNetwork bean was autoinjected/initialized, so spring managed RandomClass.

RewardNetworkImpl.rewardAccountFor() was called & Started
RandomClass.randomMethod() was called!
THE SECTION OF CHANGE IS OVER
This is the test with OBJ manually created using new and initalized by constructor.
-----------------------------

* I EXECUTED AND VERIFIED THAT : NO, ITS NOT MANDATORY TO IMPORT ALL CONFIG FILES TO THE MAIN CONFIG FILE (which you use for SpringApplication.run()).
  				 Instead, ensure in the @ComponentScan (Can be in main config or imported config, 2 annotations are just additive, so no issues if you see double),
				 That you add the package where config java files are there additionally to be scanned (INCASE IT ALREADY ISNT covered). Eg: @ComponentScan(basePackages = {"rewards.internal","config"})
				 Then you will see even without @Import(AspectConfig.class), functionality works as expected AS LONG AS config file is in package(s) mentioned in ComponentScan and it isn't private class.

Note: CLASS IMPORTED USING @IMPORT() DONT THEMSELVES HAVE TO BE A @Configuration class!!! 
----------------------------------------------------------------------

* I TESTED if RandomSubClass obj executing its parent's method also triggers aspect, and see if overrided that method, that has an effect. (by mixing datatypes ofcourse.)

YES, I injected RandomSubClass obj then used it to access it's superclass method randomMethod() directly, ASPECT TRIGGER WORKED JUST LIKE AS IF I INJECTED AND RAN USING RandomClass obj!
(Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!)

Then I ensured I OVERRIDED THE RandomClass method with RandomSubClass version of the method, IT STILL TRIGGERED THE ASPECT!
I even tried removing @Component from RandomClass incase, and FIRST TRIED Injection points as RandomClass, it works same! THEN TRIED WITH RandomSubClass as type expected at injection, STILL WORKS!
Similarly I tried making RandomClass as interface, SAME WAY IT WORKS, SUBCLASS METHOD TRIGGERS THE ASPECT!

(Aspect triggered before randomMethod!
RandomSubClass.randomMethod() was called!)

BUT THERE IS ONE CRITERIA WHERE ASPECT ISNT EXECUTED. IF the randomMethod declaration is REMOVED FROM THE SUPERCLASS (for interface its impossible obviously), AND ONLY IN SUBCLASS YOU HAVE THAT METHOD (Injection points expect RandomSubClass as then only it will compile since randomClass.randomMethod() WONT BE AVAILABLE IN THIS SITUATION AS WE REMOVED IT), Then FINALLY,
ASPECT DOES NOT RUN!!! This shows as long as superclass or interface has the method, then its all fine, even if you override it in subclass, aspect filter will catch it. See below output:

RewardNetworkImpl.rewardAccountFor() was called & Started
RandomSubClass.randomMethod() was called!
THE SECTION OF CHANGE IS OVER
THIS is the test where RewardNetwork bean was autoinjected/initialized, so spring managed RandomClass.


The aspect PointCut expression used for above is: @Before("execution(void rewards.internal.RandomClass.*(..))").
And OBVIOUSLY creating new Object in these cases, Aspect WONT WORK/TRIGGER.


Second part, i tried Experimenting with annotation specifications also, like @Before("execution(@java.lang.Deprecated void rewards.internal.RandomClass.*(..))") with same classes.
After annotating @Deprecated on method in RandomClass, and INJECTION POINTS ARE OF RandomClass, ASPECT IS TRIGGERED.

But while trying REMOVING @Component on RandomClass, and forcing it to inject RandomSubClass to RandomClass injection points, IT DOESNT RUN ASPECT! (It has overrided method)
Injection points were kept as RandomClass, then RandomSubClass, still NO LUCK!!!

BUT if RandomSubClass BODY IS EMPTY COMPLETELY, THEN NO METHOD IN SUBCLASS TO OVERRIDE, and IT WORKS AGAIN!

RewardNetworkImpl.rewardAccountFor() was called & Started
Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!


RewardNetworkImpl.rewardAccountFor() was called & Started
RandomSubClass.randomMethod() was called!
THE SECTION OF CHANGE IS OVER


MORAL OF THE STORY: Normally, subclass methods whther overriding or not, as long as the superclass/interface declares same signature method, THEN IT WILL TRIGGER ASPECT HOWEVER YOU INJECT IT!

BUT IF YOU HAVE SPECIFIED ANNOTATION in the filter PointCut of the aspect, THEN BEHAVIOUR IS CHANGING. EVEN IF YOU USE SUBCLASS OBJECT, If subclass object injected, is used to
ACCESSING THE SUPER CLASS METHOD (SubClass doesnt have that method), THEN IT WORKS SAME!
BUT IF YOU OVERRIDE THE METHOD IN SUBCLASS, THEN ASPECT ISNT TRIGGERED IF YOU INJECT THE SUBCLASS OBJECT! (Regardless of injection point type) In this annotation specified CASE ALONE!

-----------------------------------------------------------------------------
For Aspect triggering regarding bean internal method calls to its own other methods...(Assuming methods a() and b() both match some aspect PointCut conditions)

If I do intentional separate calls in code, then clearly aspect is triggered:
Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!
RandomClass.randomMethod2() was called!
Aspect triggered after randomMethod! : RandomClassmethod2
THE SECTION OF CHANGE IS OVER: DUMMY
Aspect triggered before randomMethod!
RandomClass.randomMethod2() was called!
Aspect triggered after randomMethod! : RandomClassmethod2
THE 2nd SECTION OF CHANGE IS OVER: DUMMY


But if I do "return randomMethod2();" inside randomMethod(), then see output where Aspect WAS NOT TRIGGERED because now the internal calls after aspect triggering ARE HAPPENING ON THE REAL BEAN ITSELF!

Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!
RandomClass.randomMethod2() was called!
Aspect triggered after randomMethod! : RandomClassmethod2
THE SECTION OF CHANGE IS OVER: DUMMY


But if I attempt to call ANOTHER BEAN's (RandomSubClass in this case) method internally of that original method call body, THEN IF ASPECT filter is matched then YES IT WILL BE TRIGGERED AS USUAL! So as expected, nested way of Aspect triggering and ending happens (as I use @Around method with more proper labelled output dynamically using PointJoinPoint methods to print function and bean names)

Aspect triggered before rewards.internal.RandomClass@9e2ad91.randomMethod!
RandomClass.randomMethod() was called!
RandomClass.randomMethod2() was called!
Aspect triggered before rewards.internal.RandomSubClass@1aa6e3c0.randomMethod!
RandomSubClass.randomMethod() was called!
Aspect triggered after rewards.internal.RandomSubClass@1aa6e3c0.randomMethod! : Subclass
Aspect triggered after rewards.internal.RandomClass@9e2ad91.randomMethod! : DUMMY
THE SECTION OF CHANGE IS OVER: DUMMY


-------------------------------------------------------------------------------------------

HOW TO EXECUTE: I moved to lab folder in cmd and usually to run tests alone I used: mvn test -pl 22-aop
BUT FOR ASPECT TESTING, the LOGGER STATEMENT WERE MISSING, I SEARCHED FOR CODE ISSUES and all,

FINALLY PROBLEM WAS HOW I EXECUTED UNIT TEST OF 1 Test ALONE : mvn -pl 22-aop -Dtest=LoggingAspectTests test [THIS WORKS!!!]

Also, anything wrong with JoinPoint expression (like @Before("execution(* *(..))") IS NOT CORRECT) , it will THROW EXCEPTION AS IF beanInitialization failed for the Aspect class.
SO ENSURE TO CHECK IT's correct or not.









---------------


Mocking Annotation Deep Dive (Boot 2 & 3)
Annotation 	Function					Origin (Dependency)		Supported by Default?
@Mock		Creates a mock object (no Spring context).	mockito-core			No
@Spy		Creates a partial mock/spy (no Spring context).	mockito-core			No
@InjectMocks	Injects @Mock fields into the test class.	mockito-core			No
@Captor		Captures method arguments for verification.	mockito-core
@ExtendWith	Required to use MockitoExtension.class.		junit-jupiter-api		Yes (junit is considered default with springboot typically speaking)
@MockBean	Mocks a Spring Bean and adds to Context.	spring-boot-test		Yes (Deprecated in Boot 3.4)
@SpyBean	Spies on a Spring Bean in the Context.		spring-boot-test		Yes (Deprecated in Boot 3.4)
@MockitoBean	Modern replacement for @MockBean.		spring-test (via Boot 3.4)	Yes (Spring Boot 3.4+)
@MockitoSpyBean	Modern replacement for @SpyBean.		spring-test (via Boot 3.4)	Yes (Spring Boot 3.4+)



Feature		systemProperties				environment
Object Type	A Map (specifically java.util.Properties)	An Environment object
Scope		Just JVM -D flags				JVM flags + OS vars + Config properties/yaml/etc files
Default Bean	Pre-defined in SpEL by default			Pre-defined in SpEL by default
Reliability	Only finds system-level properties		Finds "Spring-managed" properties

All below are allowed if its a system property:
#{systemProperties['my.prop']} — Correct (Map access).
#{environment['my.prop']} — Correct (Property access via Environment).
#{environment.getProperty('my.prop')} — Also Correct (Calling a method on the environment object).

Test Category	Context Scope	Setup Annotation			Mocking Annotations			Wiring / Injection Mechanism		Source Dependency	Automatic Reset?	Exam Logic / Key Behavior
Unit Test	None (POJO)	@ExtendWith(MockitoExtension.class)	@Mock, @Spy, @InjectMocks, @Captor	Manual via @InjectMocks			mockito-core		No			Fastest; isolates logic; zero Spring Beans/Context loaded.
Integration	Full (Total)	@SpringBootTest	@MockBean, @SpyBean	@Autowired 				from AppContext				spring-boot-test	Yes			Starts entire app; @MockBean replaces real beans in Context.
Web Slice	Partial (Web)	@WebMvcTest(Ctrl.class)	                @MockBean				@Autowired (MockMvc)			spring-boot-test	Yes			Loads only Controllers; Services/Repos must be mocked.
Data Slice	Partial (DB)	@DataJpaTest				@MockBean (optional)			@Autowired (Repositories)		spring-boot-test	Yes			Loads Repos + H2 DB; uses TestEntityManager.
JSON Slice	Partial (JSON)	@JsonTest				@Mock					Manual Constructor/Setter		spring-boot-test	No			Tests Jackson/JSON serialization/deserialization only.
Client Slice	Partial (REST)	@RestClientTest(Svc.class)		@MockBean 				@Autowired (Service)			spring-boot-test	Yes			Tests REST clients; provides MockRestServiceServer.
Legacy/Core	Manual		@SpringJUnitConfig			None (Manual Mocking)			@ContextConfiguration			spring-test		No			Framework way; loads only specified @Configuration classes.
Boot 3.4+	Any Boot	@SpringBootTest / Slices		@MockitoBean, @MockitoSpyBean		@Autowired from AppContext		spring-test*		Yes			Official replacement for @MockBean / @SpyBean.


These enable annotations ARE NOT MANDATORY as long as dependencies are there correctly:

@EnableAutoConfiguration: Triggered by @SpringBootApplication.
@EnableTransactionManagement: Triggered by any data starter (e.g., spring-boot-starter-jdbc or spring-boot-starter-data-jpa).
@EnableJpaRepositories: Triggered by spring-boot-starter-data-jpa.
@EnableConfigurationProperties: Triggered automatically in Spring Boot to support @ConfigurationProperties.
@EnableMongoRepositories: Triggered by spring-boot-starter-data-mongodb.
@EnableDiscoveryClient: Triggered by Spring Cloud starters (Eureka, Consul) if auto-registration is not disabled.
@EnableElasticsearchRepositories: Triggered by spring-boot-starter-data-elasticsearch.
@EnableJdbcRepositories: Triggered by spring-boot-starter-data-jdbc.


Autoconfiguration classes: -
META-INF/spring.factories 	[for springboot 2.x version]

Specify below property: 
org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.example.HelloAutoConfig

[OR]

META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports	[for springboot 3.x versions]

Mention just full qualified class name in each line, thats all.
It imports in both springboot versions REGARDLESS IF CLASS IS IN SAME/SUB-PACKAGE OF MAIN CLASS OR NOT!


This above file need to have the names of custom Autoconfiguration classes you create.
IF SO THEN the @AutoConfigureBefore or @AutoConfigureAfter can be used as follows:

@Configuration
@AutoConfigureAfter(DataSourceAutoConfiguration.class) // WAIT for the DB to be ready
@ConditionalOnBean(DataSource.class)                   // ONLY run if the DB was actually created
public class MyDbPluginConfig {
    // My custom logic that NEEDS a DataSource to work
}

It helps to specify this autoconfiguration class you created HAS TO RUN BEFORE OR AFTER the AUTOCONFIGURATION CLASS MENTIONED in brackets of annotation.
BOTH THIS CONFIG AND THE TARGET MENTIONED CLASS HAS TO BE SPRINGBOOT AUTOCONFIGURATION CLASSES OR BE IN THAT .imports file.

@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) // Absolute priority (-2147483648)


Here are some additional PointCut syntaxes: -

@Pointcut("execution(* com.example.service.*.save(com.example.model.*))")	-Param is of type in a particular package

@Pointcut("execution(* com.example.service.*.processOrder(..)) && args(orderId, amount)")
public void processOrderWithArgs(String orderId, Double amount) {}
@Before("processOrderWithArgs(orderId, amount)") 				- POINTCUT WITHOUT "execution()" IS ONLY VALID IF THE METHOD MATCHING IS A POINTCUT's METHOD!!!

@Pointcut("execution(* com.example.service.*.*(com.example.model.User)) && @annotation(org.springframework.transaction.annotation.Transactional)")

@Around("execution(* com.example.service.*.*(..)) && args(String, ..)")		- TO verify if first param is string, rest is somethings else if any

Remember: proceedingJoinPoint.getArgs() [for @Around] and joinPoint.getArgs() [for @Before,@After, etc] gives the arguments Object[] list so you can check types if you wish.


And usually method calls inside same class DONT GO THROUGH applicable proxy, EXCEPT in case of @Configuration class for ConfigurationPostProcessor actually rewrites all method code,
So technically even INTERNAL CALLS ALSO GO THROUGH PROXY, this is for the purpose of not recreating beans when @Bean methods are called even inside same class.

By default, @TestPropertySource loads files relative to the test class itself if no explicit file path is given. The file name defaults to the test class name with a .properties extension (e.g., MyAppTest.properties). 

Annotation Usage 			Resolved Path
@TestPropertySource			classpath:[package/of/class]/[ClassName].properties
@TestPropertySource("foo.prop")		classpath:[package/of/class]/foo.prop
@TestPropertySource("/foo.prop")	classpath:/foo.prop (Root of resources)
@TestPropertySource("file:./foo")	Relative to the current working directory (Actual Project Root)

Autoconfigured Health Indicators in Springboot (except first 2, dependencies need to be there so they are autoconfigured): -

DiskSpaceHealthIndicator
PingHealthIndicator

CassandraHealthIndicator
CouchbaseHealthIndicator
DataSourceHealthIndicator (Common exam answer)
ElasticsearchHealthIndicator
HazelcastHealthIndicator
InfluxDbHealthIndicator
JmsHealthIndicator
LdapHealthIndicator
MailHealthIndicator
MongoHealthIndicator
Neo4jHealthIndicator
RabbitHealthIndicator (Common exam answer)
RedisHealthIndicator
SolrHealthIndicator 


Metrics actuator tags BUILT IN FOR MOST POPULAR:
1. http.server.requests

This is the most common exam metric. It tracks every web request.
Built-in Tags:
method: (e.g., GET, POST, PUT) — Filter by HTTP verb. [C]
status: (e.g., 200, 404, 500) — Filter by response code. [D]
uri: (e.g., /orders/{id}) — Filter by the endpoint path.
exception: (e.g., None, NullPointerException) — Filter by error type.
outcome: (e.g., SUCCESS, CLIENT_ERROR, SERVER_ERROR) — Filter by category.

2. Database Metrics: jdbc.connections.*

If you are using a connection pool (like Hikari), these tags are built-in:
name: The name of the DataSource (usually dataSource).
pool: The name of the connection pool.

3. Cache Metrics: cache.*

If you use @Cacheable, these tags are built-in:
name: The name of the cache (e.g., users).
cacheManager: The bean name of the manager.

4. JVM Metrics: jvm.memory.used

area: (e.g., heap, nonheap).
id: (e.g., G1 Eden Space).


When Id is NOT null in save() call of entity of a DB table with Autogenerated id column,
If id doesn't exist, it throws Exception else it updated the existing record. null id creates new record.

For records, @JsonProperty can help specify the translated field name from json to obj field name.
only 1 Canonical constructor is mandatory for Jackson to use for conversions, rest HAVE TO CALL this(A,B,...) as FIRST line of construtor.

In a Record, the Canonical Constructor (the one with all fields) is always provided by the compiler, even if you write a custom, non-canonical one.

public record User(String username, Integer age) {
    @JsonCreator
    public User(@JsonProperty("user_name") String userName) {
        this(username,age);
    }
}

In Java, a subclass instance is an instance of its superclass. Therefore, Spring sees two perfectly valid candidates of the type RandomClass in its context. 
So IF you have RandomClass and RandomSubClass in context, if injection point requires RandomClass and assume field name is NOT name of both beans,
THEN NoUniqueBeanDefinitionException OCCURS EVEN IF YOU THINK RANDOMCLASS IS OBVIOUS CHOICE!!!


The syntax and features provided are fully supported in Spring Boot 2.7 (which uses Spring Data JPA 2.7). 
Here are the specific method signature details and capabilities for this version:

1. Core Method Signatures
In 2.7, these "prefixes" are interchangeable and produce the same query result:
find…By, read…By, get…By, query…By, stream…By. 

2. Supported Operators (<Op>)
These are the standard "Keywords" for query derivation in 2.7: 
Equality: Is, Equals, (or empty).
Logical: And, Or.
Comparison: Between, LessThan, LessThanEqual, GreaterThan, GreaterThanEqual, After, Before.
Null Checks: IsNull, IsNotNull, NotNull.
Pattern Matching: Like, NotLike, StartingWith, EndingWith, Containing.
Collections: In, NotIn.
Boolean: True, False.
Case Sensitivity: IgnoreCase (for one property) or AllIgnoreCase (for all). 

3. Result Modifiers
Uniqueness: findDistinctBy....
Limiting: findFirstBy... or findTop<N>By... (e.g., findTop10By).
Ordering: OrderBy<Property>Asc or OrderBy<Property>Desc at the end of the name. 

4. Return Types for 2.7
Your interface methods in 2.7 can return: 
Single Items: T (your entity), Optional<T>, or void.
Collections: List<T>, Set<T>, Collection<T>, Stream<T>.
Paging/Sorting: Page<T> or Slice<T> (requires a Pageable parameter).
Async: Future<T>, CompletableFuture<T>, ListenableFuture<T>


Answer is @MockBean when question mentions:

✅ "Spring context" / "application context"
✅ "Replace a bean in the context"
✅ "Slice tests" (@WebMvcTest, @DataJpaTest, etc.)
✅ "spring-boot-test annotation"
✅ "Mock Spring-managed dependencies"
✅ "Integration testing with mocks"
✅ "Add mock to application context"

Example theory questions → @MockBean:

"Which annotation replaces a bean in the application context with a mock?"
"In slice testing, which annotation mocks services?"
"Which annotation from spring-boot-test creates mocks?"

Answer is @Mock when question mentions:

✅ "Mockito annotation" (without mentioning Spring)
✅ "Unit testing WITHOUT Spring"
✅ "Pure Mockito mocking"
✅ "Testing POJOs"
✅ "Without application context"
✅ "org.mockito package"

Example theory questions → @Mock:

"Which Mockito annotation creates mock instances?"
"For unit testing without Spring framework, which annotation?"
"Which annotation is from Mockito library directly?"

Key Word Triggers:

"Spring" / "context" / "bean" / "slice" → @MockBean
"Mockito" / "without Spring" / "POJO" / "pure unit" → @Mock

Default assumption: If question mentions ANY Spring bean involved testing scenario → @MockBean

.permitAll() EVEN If i use:

Authentication filters still process the request
SecurityContext is still created (might be anonymous)
CSRF protection still applies (unless explicitly disabled)
Other security filters (CORS, headers, session management) still execute
Custom filters in the chain still run
