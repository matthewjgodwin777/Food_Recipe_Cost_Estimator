spring.datasource.driverClassName=org.postgresql.Driver # JDBC driver for PostgreSQL
spring.datasource.url=jdbc:postgresql://localhost:5432/postgres # Database URL
spring.datasource.username=postgres # Database username
spring.datasource.password=postgres # Database password
spring.jpa.hibernate.ddl-auto=create-drop # Create and drop schema at app start/stop (dev/testing only)
spring.jpa.show-sql=true # Show SQL statements in the console
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect # Use PostgreSQL-specific SQL
spring.jpa.properties.hibernate.format_sql=true # Format SQL output for readability
spring.mvc.format.date=dd-MM-yyyy # Set default date format for web requests/responses
springdoc.api-docs.path=/api-docs # OpenAPI docs endpoint path
spring.security.user.name=admin # Default Spring Security username
spring.security.user.password=12345 # Default Spring Security password
com.auth0.domain=dev-mxgv6sk7untmws6p.us.auth0.com # Auth0 domain
com.auth0.clientId=abcdef....... # Auth0 client ID
com.auth0.clientSecret=abcdef.... # Auth0 client secret


@Repository not compulsory if repository extends JPARepository<> where impl of it usually has it already....,
if only extends custom repo interface, then need.

Eg: public interface BorrowerRepository extends JpaRepository<Borrower,Long> {} //no @Repository annotation needed

@Transactional on service or repository methods ensure changes are committed or if exception occurs it rolls back to previous DB state

@Autowired helps inject dependencies req for a method or constructor with parameter(s) which actually are already having spring beans existing.
And also can be used on member variables so they are injected.
BUT AUTOWIRED IS NOT NEEDED FOR CONSTRUCTOR if there is ONLY ONE constructor in the class.

@Entity				// Makes it JPA entity and already expects table with same as class name, unless @Table is tehre
@Table(name="userdetails")	// Specified table name and stuff
@Data					// OR can use @Getter @Setter alone also
@NoArgsConstructor
@AllArgsConstructor		// remember if 2 constructors are there (i consider this as one), use @AllArgsConstructor(onConstructor_ = @Autowired) if specifying for autgen const.


@Column(name="col_name_in_db", nullable = true, unique = false) //If not specified, col name in db same as variable name here, and the default boolean values for rest attr is as shown here

@Id
@SequenceGenerator(name="user_seq",sequenceName = "user_seq",allocationSize = 1)
@GeneratedValue(strategy = SEQUENCE,generator = "user_seq")

@Id and @GeneratedValue just like that no params is enough for primary key autogen..but @GeneratedValue uses the generator specified.
name attribute in 2nd anotation is used to refer in the 3rd annotation thats all, sequenceName IS THE SEQ NAME INSIDE DB! (yes there is a sequence in db side created or you have to),
allocationSize: Use a low value for strict sequence order and minimal gaps as it fetches new number from DB each time (very costly).
		    Use a high value for better performance when inserting many records, accepting possible gaps in the sequence so cant say all are in order you expect, thats all...


Access modifiers of field and constructor wont affect spring from injecting values.


Controller: -

@RestController
@RequestMapping(path="/api")		// Specifies base url for the endpoints in that controller class.

@PostMapping(path = "/getuserbyname")	// To be used on each method of controller, if (...) not given it takes the default base url of controller]
@GetMapping

public Optional<User> addUser(@RequestBody User u)  // RequestBody annotation to accept this variable by taking json supplied and mapping.
....addUser(@PathVariable("sample") String samplePathVariable) // Basically gets the path variable IF MENTIONED in the @PostMapping/@GetMapping 's path value with "{sample}"

Note: -
* Optional<User> and User almost behave same when serialized and all, since if User is there, User json is used, else null value. so not much diff)

* Incase @RequestBody Type type 's class structure fields and json fields dont match, here is what happens in each situation: 

Missing fields → default values in Java used. (This and next point same for even NESTED JSONs inside the req body json)
Extra fields → ignored. (by default it ignores these but can be forced not to...)
Type mismatch → error occurs. (Doesnt throw error if the expected and obtained type is both same...)

* Map<String, Object> or JsonNode can be used with @RequestBody incase you want any structure.

* incase @RequestBody List<String> is there and you give [1,2,3] or even list of booleans, JACKSON CONVERS IT TO STRING REPRESENTATION just fine!

* Note about omiting and not omitting DTO id fields which should be autogenerated.

-> If you omit userId in the JSON OR give as null value, The ID will be generated automatically as expected.

If you provide a value for userId in the JSON, and it's not null, JPA TRIES TO ADD, if alreadty that id exists , primary key violation might occur and throws error, ELSE IT ADDS IT FINE, THIS ONE TIME IT DOESNT SEQUENCE GENERATE and simply uses given value.
And SEQUENCE NEXT ATTEMPT RESUMES FROM THE NUMBER AFTER THE PREV. SEQ Value GENERATED, not what you gave manually, so yes if you give 10 after 1 2 3 generated, when it reaches 9 and then tries, IT CAUSES KEY VIOLATION ERROR AND TRANSACTION ROLLS BACK.

@ResponseStatus(value = HttpStatus.NOT_FOUND) 		// TO be annotated on a RuntimeException Subclass so if it is thrown it sends to client this HttpStatus specified with message.
// Can annotate on methods also, and make them return only one status code which is specified..UNLESS YOU USE RESPONSEENTITY to return, then THAT TAKES PRECEDENCE THAN THIS ANNOTATION.

Todo: How to handle above senario gracefully, How to make the @RequestBody strict in checking json if possible.

