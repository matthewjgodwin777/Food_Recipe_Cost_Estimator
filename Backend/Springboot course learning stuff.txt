repository are automatically a bean if extends JpaRepository<...> or CrudReposity<...> , etc.
One constructor in class (including lombok) means no need @Autowired, private or access modifier doesnt affect injection or IoC.

ResponseEntity.ok(...) or created(...) when you pass a parameter to it, it's basically like constructing ResponseEntity.status(...).header(HttpHeaders.LOCATION, "/cashcards/1").build(); and the value is obtained using response.getHeaders().getLocation() , which will be a URI.

URI location = URI.create("/cashcards/1");

return ResponseEntity.created(location).body(resource); // build() is not required if body() is used
[OR]
return ResponseEntity
    .status(HttpStatus.CREATED)
    .header(HttpHeaders.LOCATION, location.toString())
    .body(resource);

 UriComponentsBuilder as parameter to post function in controller correctly got injected by IoC just like that.
---------------------
URI locationOfNewCashCard = ucb
                    .path("cashcards/{id}")
                    .buildAndExpand(savedCashCard.id())
                    .toUri();

Another way of sending back the path as URI in the ResponseEntity.created(locationOfNewCashCard).build();

Atleast in CrudRepository internal db, YOU CANNOT give Id field when creating an object using POST endpoint when it saves using repository.save() ;

CREATE TABLE cash_card
(
    ID     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    AMOUNT NUMBER NOT NULL DEFAULT 0
);

Regardless of H2 or postgres, ofcourse if this CREATE TABLE script is either used or generated, it will ofcourse use generated value if id field is null, else it uses provided value.
------------------
@Table("cash_card")
public record Card(@Id Long id, Double amount) {}
------------------
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.datasource.url=jdbc:postgresql://localhost:5432/yourdb
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.username=youruser
spring.datasource.password=yourpass
------------------

incase there are 2 constructors in a class type (records must always have only 1 constructor with all fields), then if the type is converted from a json,
like @RequestBody is used to do so, then apparently acc to AI, it will choose depending on what fields json has and choose constructors. (not sure)

Page<CashCard> page2 = cashCardRepository.findAll(
    PageRequest.of(
        1,  // page index for the second page - indexing starts at 0
        10, // page size (the last page might have fewer items)
        Sort.by(new Sort.Order(Sort.Direction.DESC, "amount"))
    )
);

Pageable pageable is a variable that can be injected magically in a constructor function which takes the size and page query parameters in request.
Otherwise, if one of these or both isnt given, Spring provides defaults: page=0, size=20.

pageable.getPageNumber(),
pageable.getPageSize(),
pageable.getSortOr(Sort.by(Sort.Direction.DESC, "amount"))));  //Yep this is correct , either uses given in url else the default specified here.

///Example queries which will be given to Pageable obj in controller func: cashcards?page=1&size=3&sort=amount,desc
(The comma cannot have spaces before and after...)

@DiryContext on a method and @DirtiesContext(classMode = ClassMode.AFTER_EACH_TEST_METHOD) on the test class can help to clean the data after each test if it makes a permanent change
(like if a card is added in a test for next test it can be undone)

Additional for paging support you need to extend this repository:
interface CashCardRepository extends CrudRepository<CashCard, Long>, PagingAndSortingRepository<CashCard, Long> { ... }


Spring Security (works via Role-Based Access Control (RBAC) , which is self explainatory): Token types, Bearer token authentication, CSRF token (Cross-Site Request Forgery token)

Filter Chain in springboot helps to define methods to be executed before controllers to ensure the requests are authenticated, else send back 401 UNAUTHORIZED.

@CrossOrigin - used to specify the urls to allow cross origin requests and if args not give, it ALLOWS ALL ORIGINS!

Cross-Site Request Forgery - involves cookie token to be used and sent trying to impersonate, therefore a specially dedicated CSRF token generated is recommended.
Cross-Site Scripting - Similar to SQL injection attacks, if the script or something goes in the raw form , and due to poor programming practices its not cleaned and used somewhere,
If say js code chunk is not cleaned and directly rendered in a webpage, unwanted scripts can be executed. Properly data should be escaped accordingly and no loop holes.

----------------------------
Principal principal in controller is a method argument, provided automatically by Spring Security.
Same as Paegable

Spring security always returns 403 forbidden if that mapping/suburl doesnt exist so it doesnt reveal by mistake any useful info.
delete (Atleast in CRUD repository)

Note: Have to explore how repository interface we just type method name and it correctly does the queries behind the scenes.

URI (Uniform Resource Identifier): Identifies a resource â€” can be a name, location, or both. Example: urn:isbn:9780134685991
URL (Uniform Resource Locator)   : A type of URI that tells you how to locate a resource.    Example: https://example.com/page

UriComponents


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Spring Framework Essentials : -


ApplicationContext context = SpringApplication.run(ApplicationConfig.class);

TransferService service = context.getBean("transferService" , TransferService.class); // one of the parameter is enough too
// only first param means RETURN TYPE WILL BE OF TYPE Object (just typecast thats all) , only with 2nd param it gives directly correct type.
   And also, the class name of the bean just make FIRST LETTER LOWERCASE, that WILL BE THE BEAN NAME TO SUPPLY as FIRST PARAM.

// If there is no other beans returning that type or being that type, then 2nd param ALONE CAN BE ENOUGH.


@Configuration
@Import({ApplicationConfig.class, WebConfig.class}) // To not repeat config classes, basically extending config classes so common stuff is shared.
public class TestInfraConfig {
@Bean // Can also be @Bean(name="dataSource") incase method name had to be different
public TransferService transferService(AccountRepository){
		return new TransferServiceImpl(repository);
	}
}


If TransferServiceImpl is annotated as some bean annotation, then since no other type other than this extends TransferService,
Spring automatically will inject this where TransferService interface type is used.
If multiple contenders, then @Qualifier should be used on the one you want it to be injected with.

Incase there is cyclic dependency and cant be resolved design wise, then use @Lazy like:

public Constructor(@Lazy Service2 s, ...){} // This will atleast break cycle delaying the MANDATORY req that Service2 is to be injected immediately.
							  // It will basically not fully initalize properly and then after that will inject this bean.


Bean Scopes: -

@Scope("singleton") - Only once instance is created

Issues when it maintains any state/mutable type. Then THREADSAFE stuff should be done.(syncronizing etc)
Better only use for immutable or stateless beans.


@Scope("prototype") - Everytime it's referenced, a new instance is created.

Like context.getBean() if you use to get bean twice, THEN TWO NEW INSTANCES CREATED!
But in springBOOT, difference is: 
  EVERY PLACE where its annotated explicitly or implicitly to Inject, each time new instance is injected.
  Like if it's supposed to be injected "magically", then its a new one injected for sure.


@Scope("session") - Instance is created once PER USER SESSION (Web environment ONLY)
@Scope("request") - Instance is created once PER Request (Web environment ONLY)

Web Socket Scope, Refresh Scope, Thread Scope (this one maybe not native) , or even custom scopes rarely are used and exist.


A bean should be named like accountRepository , and should return only the interface type (AccountRepository),
Not the implementation class's type, by polymorphism return ofc. Its a standard.


@Bean
public DataSource dataSource(Environment env) //Is a bean an easily injected like other beans.
{
	BasicDataSource ds = new BasicDataSource();
	ds.setDriverClassName(env.getProperty("db.driver")); //Takes from application.properties or somme other prop. file
	...
}

The env.getProperty("key") is used to get value from these below sources (DESCENDING ORDER of precedence):

JVM system properties (System.setProperty)
OS environment variables
Config files (application.properties, application.yml)
(Not sure: .properties overrides .yml if both have same key;
Profile-specific files (e.g., application-dev.properties) overrides the general application.properties)
Any custom property sources registered via annotations or code

Among same precedence property files, if specified like below 3 ways,
THE LATER FILE OVERRIDES the LEFT FILES! : -

@PropertySource({"classpath:fileA.properties", "classpath:fileB.properties"})
OR
@PropertySource("classpath:fileA.properties")
@PropertySource("classpath:fileB.properties")
OR
spring.config.additional-location=classpath:/fileA.properties,classpath:/fileB.properties

[ CAN ALSO USE "file:..." or "http:..." prefixes to get the property files using absolute/relative path.
classpath: is used like classpath:/com/sagent/daradefault/resources/application.properties , file: is as expected.
IF you dont use these 3 prefixes and mention @PropertySource("application.properties") or so,
It NON RECURSIVELY searches in classpath folders like src/main/resources/cloud.properties for it,
AS IT TAKES IT AS RELATIVE PATH TO CLASSPATH's resource folder]

Can check order too: 
((AbstractEnvironment) env).getPropertySources() gives the order of loading the property files in descending order of precedence.


Alternate to using env.getProperty(), use: -
@Value("${db.driver}")


Profiles: -
Actually Beans belong or not belong to profiles,
Like DataSource bean can be many but dev has one, and production uses another bean similar though.
So profile just categorizes beans (and usual beans is common to all).

@Profile("cloud") - CAN BE USED ON ANY BEAN so the bean is only available in context IF ITS IN THAT MENTIONED PROFILE!
@Profile("!cloud") - Means initialized when profile IS NOT "cloud"

Also, if you wanted say 2 DataSource beans in same class, one for cloud and one for local profiles,
function names can be different, so BEAN NAME WILL ALSO CHANGE RIGHT sicne overloading not possible? (same method signature)
So to EXPLICITLY mention Bean(name="dataSource") for both.


Ways to activate profile(s): (YES, CAN ACTIVATE MULTIPLE)
-Dspring.profiles.active=embedded,jpa
OR
System.setProperty("spring.profiles.active","embedded,jpa");
(SpringApplication.run(AppConfig.class) is THEN ONLY RUN)
OR for Integration testing: @ActiveProfiles annotation is used (later we will see)


Using @Profile("cloud")
	@PropertySource("cloud.properties")
on a configuration class means NOT ONLY that configuration will only have beans initialized in that particular profiles,
ONLY IN THE PARTICULAR PROFILE(S) THE PROPERTY SOURCE MENTIONED ALSO IS INCLUDED!!! (yes it has influence on fellow annotation)


Fun fact: Most annotations the order applied on same thing usually doesnt matter, especially class annotations never at all,
Maybe exceptions like : method-level annotations in JUnit 4, or when using annotation processors that care about orde



Spring Expression Language : -

@Value("#{ systemProperties[user.region] }")
//Can annotate this on a class field OR EVEN A METHOD PARAM too.

To fetch a field value, the main obj has to be a bean to be access by SEL.


TRICKY WEIRD NAMING BEHAVIOUR WARNING : -
class StrategyBean{
private KeyGenerator gen = new KeyGenerator.getInstance("Blowfish");
public KeyGenerator getKeyGenerator(){return gen;};
}

@Configuration
class StrategyConfig {
@Bean public StrategyBean strategyBean(){
return new StrategyBean();
}
}

If used on class field, the property name "keyGenerator" is used DESPITE THE METHOD NAME OR VARIABLE NAME IN StrategyBean NOT MATCHING.

@Value("#{strategyBean.keyGenerator}")
KeyGenerator kgen;

Reason is, first you specify the bean (aka StrategyBean, which is declared in StrategyConfig as a method,
You DONT have to always declare StrategyBean as a @Bean on the class declaration itself. Instead a method generating the object is in Config class, thats enough).

Now if you try using ".keyGenerator" asking the bean using SEL, it will FIRST:
search for a accessible getter method with proper naming convention, aka here its "getKeyGenerator()"
THEN IF IT FAILS TO, then searches for AN ACCESSIBLE FIELD IN THE Bean's class with EXACT SAME NAME,
aka field in StrategyBean class called keyGenerator is searched for, but since getter is there, field name being different is ok.

REMEMBER, THE GETTER OR FIELD (Whichever is gonna be taken) HAS TO HAVE GOOD ACCESS SPECIFIER. (Obviously not private access level)
Like, if @Value("#{...}") is done in another class which is IN SAME PACKAGE as StrategyBean,
THEN default access/package-private access to the getter or variable IS ENOUGH! OR ELSE INJECTION WILL FAIL AT RUNTIME!!!


@Value("${daily.limit}") IS EQUIVALENT TO @Value("#{environment['daily.limit']}")   [$ symbol is for getting property/env value, # can have expressions]

And YES, @Value("#{new Integer(environment['daily.limit']) * 2}") IS PERFECTLY FINE!

Just remember to have valid usage of the value from environment AS IT IS A STRING,
IT HAS TO BE CONVERTED TO BE USED AS INTEGER, etc. , IF NEEDED THAT IS.


@Value("${daily.limit : 100000}") IS EQUIVALENT TO @Value("#{environment['daily.limit'] ?: 100000}")
The ':' operator in ${...} and '?:' operator in #{...} BASICALLY DOES THE SAME THING EQUIVALENTLY.
They are " IS NOT NULL, ELSE " operator. Basically they help specify DEFAULT VALUES INCASE property is null.


REMEMBER: @Autowired is STILL REQUIRED even if all paramters of constructor is annotated with @Value, like ofcourse if only 1 constructor is there,
THen no need of autowired because IMPLCITLY its assumed. But generally Autowired is implcitly or explicitly needed at minimum to ATLEAST INDICATE
WHICH CONSTRUCTOR TO USE.

spEL can do this and all as below, whereas EL is more basic: 
@Value("#{T(java.lang.Math).random() * 100}") // where the T() ensures java.lang.Math is seen as a type/class, NOT as 'java' bean with member lang.Math


Annotation-based Configuration: -
@Component if you annotate on a class,
If you annotate @ComponentScan("com.package") on the CONFIG class,
It will search the (sub)package(s) specified and whichever classes have this @Component it will take as Bean adding to application context.
(If no package/argument given, just @ComponentScan, it takes the config class's package and scans inside that for beans ALONE. (its bad if package is only for config))


3 Types of injections: (Ensure NVER to create object of such a class using new keyword, or else everything expected to be injected will be null)
* Constructor injection (only needs @Autowired if 2 resultant constructors are there, and injects dependency into only paramterized constructor params ofcourse)
* Method injection (same way as constructor, but @Autowired(required=false) can be done if ITS OK for dependency bean not to exist to be available for injection)
* Field injection (directly injects into obj's class's fields if annotated, even if private variable (but bad for unit testing).)

Setter injection preferred only maybe if circular dependency should be resolved, (@Lazy can help too, but it wont let circular dep. beans to be initialized UNTIL ITS ACCESSED)
Constructor injection doesnt let that happen, atleast easily. setters will get injected after constructors, so by then objects are created,
WHY WILL SPRING CARE ABOUT CIRCULAR DEPENDENCIES WHEN NOW IT CAN FREELY INJECT using setters since all are created by then...got it? so thats one senario setter injections are helpful.

In method injection, Optional<...> IS ALSO ALLOWED TO BE INJECTED, as IT WILL UNDERSTAND THAT BEAN IS TO BE INJECTED IN OPTIONAL FORM!!!, like below line:
@Autowired public void setAccountService(Optional<AccountService> accountService){...}

@Qualifier: -
public TransferServiceImpl(@Qualifier("jdbcAccountRepository") AccountRepository accountRepository){} // Qualifier takes the bean name, not class name.
Above code ensures to disambiguate which bean to inject IF THERE EXISTS 2 CLASSES WITH @Component annotation EXTENDING AccountRepository.
YOU HAVE TO ANNOTATE @Qualifier(...) on the literal parameter or field itself, not on method or class.


Finally it couldnt find EXACTLY 1 bean by type or @Qualifier isnt an option, IT CHECKS THE VARIABLE NAME (like "accountRepository" above, takes the variable name as last resort.)

@Lazy should ONLY be used as worst case senario if the Bean REALLY wont be able to be created during startup while other beans are eagarly created immediately.
@Component("beanName") can also be used to give different name for bean name.
@Lazy(true) and @Lazy is same, only @Lazy(false) means its not lazy initialized.


Autowiring Constructors: -
Default constructor or only one constructor is there means @Autowired isnt necessary.
Even if more than one constructor is there, if there is ZERO-ARGUMENT CONSTRUCTOR DEFINED IT USES THAT.
ELSE, THEN @Autowired IS MANDATORY ON ONE OF THE CONSTRUCTORS.

Vaguely mentioning @ComponentScan({"org","com"}) is TERRIBLE PRACTICE as too many components wil be searched for (EVEN IN JAR DEPENDENCIES)
Best specify very accurately like "com.bank.app.repository", etc.

(Can do java configurations to avoid spring annotations directly sometimes (if you want to decouple spring directly from main code) BUT NOT ALWAYS POSSIBLE)

Startup and Shutdown behaviours: -
@PostConstruct() - If annotated on a method, AFTER CONSTRUCTOR AND SETTER INJECTIONS ARE DONE in the class, THEN it's executed (incase it needs those objects injected first).
@PreDestroy() - If (ConfigurableApplicationContext is the type) context.close() or basically context is being closed/ended NORMALLY!, (not if it died or was killed)
		    All methods with this annotation will be executed in all the bean classes,
		    EXCEPT Beans SCOPED WITH "prototype", AS ANYWAYS NEW BEAN IS CREATED EVERYTIME it has to be injected at some place.

Incase for some reason you cant or dont want to annotate inside the class , you can specify such methods in @Bean itself! : -
@Bean(initMethod="populateCache", destroyMethod="flushCache")

ConfigurableApplicationContext registers a shutdownHook in JVM, so any graceful shutdown way like System.exit() or Runtime.exit() can trigger context to run PreDestroy methods.


Stereotype & Meta Annotations: -
@Service, @Repository, @Configuration, @Controller, @RestController are basically @Component extended annotations with stereotypes associated with them (like additional properties).

YES YOU CAN CREATE A META ANNOTATION YOURSELF. Eg: @MyTransactionalService if you want to annotate on a class,

import java.lang.annotation.*;

@Target(ElementType.TYPE) // Where it can be used (.METHOD, .FIELD, etc., here TYPE means 4 things it can be used on: class, interface, enum, annotation type)
@Retention(RetentionPolicy.RUNTIME) // Available at runtime (most used), sometimes can use .CLASS (available in .class fiels but not runtime, eg: For frameworks which will see the annotation in compiled classes), or .SOURCE (just in typed source code alone, eg: for just documentation)

public @interface MyAnnotation { } // Marker annotation, no members, @interface is similar to defining an interface, but itâ€™s specifically for annotations.

[OR]

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Service // Makes the class a Spring service bean
@Transactional(timeout=60) // Makes all methods transactional with 60s time limit
public @interface MyAnnotation {     
    String description() default ""; // To have variables in annotation to specify, defauly values can be given.
    int order() default 0;
}

Below code/function is called for EVERY Bean, and incase it DOES HAVE THAT ANNOTATION, if condition below is executed, and stuff happens. This is how custom annoations can be useful.

@Component // Registers this processor as a Spring bean
public class MyAnnotationProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        // Check if the bean's class has your custom annotation
        MyAnnotation annotation = bean.getClass().getAnnotation(MyAnnotation.class);
        if (annotation != null) {
            System.out.println("Bean '" + beanName + "' has MyAnnotation:");
            System.out.println("  Description: " + annotation.description());
            System.out.println("  Order: " + annotation.order());
        }
        return bean;
    }
}


---------------------------------
Unrelated : -
javadocs basically can help tools to scan code and create html document with details of the classes.
@param â€” describes a method parameter
@return â€” describes the return value
@throws or @exception â€” describes exceptions thrown
@see â€” refers to related classes or methods
@author, @version â€” author and version info
Eg: 
/**
     * Creates a new customer.
     * @param name the customer's name
     * @param age the customer's age
     */
    public Customer(String name, int age) {
        this.name = name;
        this.age = age;
    }

    /**
     * Gets the customer's name.
     * @return the name
     */
    public String getName() {
        return name;
    }
}
---------------------------------


Bean LifeCycle Phases: Initializing, Usage, Destruction.


Spring Bean Lifecycle (in order):

1. Load & Process Bean Definitions

@Configuration classes processed
@Component classes scanned
Bean definitions added to BeanFactory (ApplicationContext extends BeanFactory)

2. BeanFactoryPostProcessor Phase

All BeanFactoryPostProcessor beans run (can modify bean definitions before beans are created)
public class BeanFactoryPostProcessorImpl implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableBeanFactory beanFactory) {
        // custom logic to modify bean definitions
    }
}

3. Bean Creation

Dependencies resolved
Beans instantiated (constructor, then setter/field injection, )
If @Lazy, bean is created only when needed

4. BeanPostProcessor Phase (instance-level)

All BeanPostProcessor beans run for each bean:

* postProcessBeforeInitialization(bean, beanName)

* Bean init methods:
	init-method (if configured)
	@PostConstruct method
	@Resource injection (both enabled by CommonAnnotationBeanPostProcessor)

* postProcessAfterInitialization(bean, beanName)


public interface BeanPostProcessor { //has to be implemented and that impl class has to be @Component
    Object postProcessBeforeInitialization(Object bean, String beanName);
    Object postProcessAfterInitialization(Object bean, String beanName);
}


5. Bean Usage

Beans are ready for use in the application

6. Bean Destruction

When context closes:
@PreDestroy method
destroy-method (if configured)


----------------------
NOTES: -

Static @Bean methods:
Use for beans that must be created before any other beans (e.g., custom BeanFactoryPostProcessor).
Eg: @Bean
    public static BeanFactoryPostProcessor myConfigurer() { ... }


PropertySourcesPlaceholderConfigurer

Spring 4.3+: auto-configured for value resolution
Older Spring: must configure manually


Java Config      : Read all @Bean annotated method signatures | BeanFactoryPostProcessor | Call @Bean method implementations | BeanPostProcessor
VS
Annotation Config: @Component Scanning | BeanFactoryPostProcessor | Instantiation (@Autowired constructor, then injection into @Autowired methods, fields) | BeanPostProcessor

----------------------

Usage Phase : -

If Bean already in context normally and required as a raw Object, its retrieved just like that if required.

But if a proxy is required like in the case of Transations, Security, Exceptions, etc.,
Then the Bean method/class isnt DIRECTLY used to supply a Bean.
It has a middleman like proxy between actual impl. bean and the caller/requirer.

This proxy creation is usually done in the BeanPostProcessor using the method: public Object postProcessAfterInitialization(Object,String)
This method WILL RETURN A PROXY OF THE OBJECT SUPPLIED IF REQUIRED by our logic.


Spring Boot: Proxy Beans Cheat Sheet

What is a Proxy Bean?

A proxy bean is a wrapper around your actual bean.
Spring uses proxies to add features like AOP (logging, transactions, security) without changing your code.
When you use annotations like @Transactional, @Async, @Cacheable, or AOP advices, Spring wraps your bean in a proxy.
The proxy intercepts method calls and adds extra behavior before/after/instead of your method.

Types of Proxies:

JDK Proxy (Inbuilt in JDK, also called dynamic proxies):
Used if your bean implements an interface.
Proxy implements the same interfaces as impl bean.

CGLIB Proxy (Spring jars have this):
Used if your bean does not implement an interface and/or if injection point directly has impl class type required.
Proxy subclasses your bean.
Cannot be applied for final classes or methods.

Example:
When you inject MyService, Spring actually gives you a proxy object.
When you call doSomething(), the proxy starts a transaction, calls your method, then commits/rolls back.
(SpringTransactionInterceptor intercepts and TransactionManager handles rollbacks/commits ofcourse)

How to See a Proxy Bean?
Print the beanâ€™s class:
The class name will show CGLIB or Proxy in it.

System.out.println(myService.getClass());
// Output: class com.example.MyService$$EnhancerBySpringCGLIB$$...

Limitations:

Only public methods are proxied.
Self-invocation (calling another method in the same bean) does not go through the proxy.
Final methods/classes cannot be proxied by CGLIB.

Why Use Proxies? :
Add cross-cutting concerns (transactions, security, logging) transparently.
Decouple business logic from infrastructure concerns.
--------------------------------------------------------------------------

Destruction Phase: -

ConfigurableApplicationContext context = //Get it from somewhere ;
context.close(); 
//will close context and trigger this phase

Any @PreDestroy (or destroy-method) method of Beans are invoked, then beans are released, and Garbage Collector will destroy them.

IMPORTANT: THIS DESTRUCTION PHASE ITSELF DOES NOT APPLY TO "prototype" scoped beans ALONE, EVERY SINGLE OTHER SCOPED Beans,
	   SPRING WILL MANAGE THEIR LIFECYCLE FULLY, but for prototype scoped beans, IT CREATES AND SIMPLY HANDS OVER FULL RESPONSIBILITY (to deallocate/destroy/etc) TO YOU.
	   Rest of the instantiation and usage (including proxy behaviour) all is SAME FOR prototype beans.

WILL NOT DO THIS PHASE IF APP ISNT SHUT DOWN GRACEFULLY, like killed or terminated.

---------

@DependsOn("beanName") on a bean (class) definition is JUST AN EXPLICIT way to say what Bean dependencies this class needs. (NO need for spring actually, but its just explicit simply)

2 Different Configuration types:

Java config: Takes bean name from method name, or name/value attribute. Type is taken from method return type.
Annotation-based Config: From Annotation value attr (we can give name as param @Bean(name="sampleBean")), Type is the class type.

One main difference is Java config typically RETURNS INTERFACE TYPE as method return type, NOT implementation class type.
But Annotation-based Config ALWAYS RETURNS THE EXACT Impl class TYPE as it has no choice since impl class is the one annotated.


Best Practices:
* Best for bean methods to return INTERFACE TYPES EXCEPT where multiple interfaces exist,
  and BOTH types WILL BE NEEDED for INJECTION. Then think about it, assume X implements A,B ,
  means if both A and B are expected to be injected somewhere, then 2 Bean methods or something has to be declared,
  Unless then alone you HAVE TO RETURN IMPL. TYPE INSTEAD so this 1 bean method alone will suffice for A and B injection places.

* Still for the "to be injected" spots, LET INTERFACE TYPES BE THERE to be injected.
  (Incase bean was proxied (Actual class name itself might be different) or different implementation object was returned as Bean in further development, IT WILL NOT COMPILE right)


--------------------------------------
AOP: -
Aspect-Oriented Programming is sort of a set of best practices, which enables modularization (module=class in java) of cross-cutting concerns.
Example: below concerns should ideally be as one modular class instead of being done FOR EVERY SINGLE CLASS/METHOD (or in many basically):
Logging & Tracing, Transaction Management, Security, Caching, Error Handling, Performance Monitoring, Custom Business Rules.


Without Cross Cutting Concerns, it leads to 2 problems:
* Code tangling (basically tightly coupled code with overlayed concepts like security, error handling, etc)
* Code Scattering (Exact same concern with duplicated code in several methods / classes)

Example:
if(!hasPermission(SecurityContext.getPrincipal())){throw new AccessDeniedException();}
This code could be added to several controller or service methods and UNNECESSARY duplication occurs with TIGHT COUPLING SECURITY WITH APP LOGIC.

2 APO Technologies:
AspectJ :
* Original AOP Technology (first version in 1995)
* Uses bytecode modification for aspect weaving
* A full blown AOP language

Spring AOP (focus of this session) :
* Java-based AOP framework with AspectJ integration.
* Focuses on using AOP to solve enterprise problems.

Spring AOP concepts in true layman's terms:

Join Point:
A spot in your code where something can happen (like calling a method, or exception might be thrown there).

PointCut:
An expression (filter) that says "only do something if methods matching this pattern of methodname does this specified action (eg: execution of method)."

Advice:
The lines of code to execute based on Pointcut (filter). (like logging, checking, or changing).

Aspect:
PointCut + Advice encapsulated in 1 module/class (like pair(s) of these 2 inside a class meant for AOP, that class can be called an Aspect).

Weaving:
The act of mixing your aspects are mixed into your regular code at the right spots.


AOP Proxy: An "enhanced" class that stands in place of original, having extra behaviour of aspects WOVEN INTO IT!
(Usually uses CGLIB or in interface cases and final class beans, JDK dynamic proxies also used, as previously learnt.)

NOTE: incase both proxies cant be used, like class is final means CGLIB cant be used, and if it doesnt implement interface, jdk dynamic proxy also cant be used. 
If you use such proxies, reason why Interface is required at injection point is, a new class with new name (with Aspect features or other stuff) will be there internally, if you had injected SPECIFICALLY your impl class somewhere, it might fail as its possibly different class. (mainly JDK proxy case I mean, as it could have same interface class but its not related to impl class directly...)


@Aspect // Aspect Annotation: Declares as an aspect class
@Component
public class PropertyChangeTracker {
	@Before("execution(void set*(*))") //Aspect Annotation: Basically filters all methods where any params can be there but func name starts with "set", and void return type
	public void trackChange(){
		//Do something here BEFORE any void set.... method is executed.
	}
}

@Configuration
@EnableAspectJAutoProxy
@ComponentScan(basePackages="com.example.aspects") //Component scan always required right? unless it @Import another config which already has componentscan
public class AspectConfig {}

@Configuration
@Import(AspectConfig.class) //NOW EVERY SINGLE BEAN, regardless if declared inside this config or not, IF INJECTED, IT WILL BE SCANNED BY ASPECT FOR A MATCHING METHOD, and DOES ACTION IF REQUIRED!
public class MainConfig{
@Bean public Cache cacheA(){return new SimpleCache("cacheA");} 
@Bean public Cache cacheB(){return new SimpleCache("cacheB");}
@Bean public Cache cacheC(){return new SimpleCache("cacheC");}
}

@Autowired
@Qualifier("cacheA")
private Cache cache; // Use @Qualifier("cacheA") on @Autowired additionally to specify incase multiple beans with same type but different beanNames (here,its function names as bean names) exist.
...
If cache.setCacheSize(2500); // That aspect expression should catch this and print the log it specifies.


Spring creates proxy bean 'weaving' aspect & target,  implements target's interface like the bean (TAKES AND PROXIES ONLY INTERFACE METHODS, NOT ALL THE ONES IN IMPLEMENTATION).
All calls are routed through proxy interceptor.
The Matching advice for any Aspect's PointCut is executed if condition is true, as interceptor intercepts each incoming calls.
Target bean's method is executed and returns value as expected along with matching aspect functionality also accordingly (Before or After).
			
		   _____Spring_AOP_Proxy____________________________________
incoming	   |  _____________________	 _______________________   |
-------------------|->| Method Interceptor|----->| SimpleCache (target)|   |
<------------------|--|___________________|<-----|_____________________|   |
outgoing return    |__________^__|______________________________|__________|
			      |  |				|  |
		     _________|__v_________________	   _____v__v_____________
		    |PropertyChangeTracker(Aspect) |	   |<<interface>> Cache |   (Spring AOP Proxy and SimpleCache both implement same interface)
		    |______________________________|	   |____________________|



NOTE: Only methods declared in the interface Cache are proxied.
If your implementation class SimpleCache has an extra set... method not in the interface, the aspect will not be applied to that method.
The aspect will work on the other set... methods that are declared in the interface.

(But in CGLIB where interfaces arent declared to be implemented, if subclass is used, then this problem WONT BE THERE. But if interface it implements and has to be inejcted as interface type, dynamic proxy is used as default and this problem will be there.)


@Aspect
@Component
public class PropertyChangeTracker {
	@Before("execution(void set*(*))")
	public void trackChange(JoinPoint point) //Autoinjected
	{
		String methodName = point.getSignature().getName(); //gets method name of the JoinPoint, aka method call.
		Object paramValue = point.getArgs()[0];		    //gets method param values of same call.
		String beanName = point.getTarget();		    //Gets Bean name of the non-proxied original bean.
	}
}


Common Pointcut Designator:
execution( <method pattern> ) - matches method
Can also CHAIN TOGETHER to create composite pointcuts using && , || and ! (not).
eg: execution(<pattern1>) || execution(<pattern2>)

<method pattern> = [Modifiers] ReturnType [ClassType] MethodName (Arguments) [throws ExceptionType]

Wildcard *  matches once (returntype, package, class, method name, argument)
Wildcard .. matches zero or more (arguments or packages)

For Example, Incase of : execution(@javax.annotation.security.RolesAllowed * rewards.restaurant.*Service.find*(..))

execution    ( @javax.annotation.security.RolesAllowed      *        rewards.restaurant .  *Service  .  find*     (..)         )
[designator]   [annotation]                            [returntype]  [package]		   [class]	[method]  [arguments]

Examples:
* execution(void send*(rewards.Dining)) - Any method, with name starting with "send" that takes a single Dining type parameter with void return type. Note: IF fully qualified type is mentioned, just ensure the single method param is of Dining type from reward PACKAGE ONLY.
* execution(* send(*)) - Any method called send which takes A SINGLE PARAMETER! (* DOES NOT MEAN MULTIPLE PARAMS LIKE REGEX)
* execution(* send(int,..)) - Any method called send whose first parameter is an int type, and 0 OR more parameters may follow.
* execution(void example.MessageServiceImpl.*(..)) - Any void method in the MessageServiceImpl class and in MOST CASES subclass object method access also triggers this.
  [HUGE DOUBT: Please refer foot NOTES for the massive explanation.]
* execution(void example.MessageService.send(*)) - ANY METHOD from class implementing MessageService INTERFACE WILL TRIGGER by this exp.

Note: you cant start a expression phrase with '..' like atleast '*..' is required Like expression(* ..restaurant.*.*(..)) IS WRONG!!!
Instead add a * just before .. to make it legal.


Advice TYPES: -

Before: In this @Before type of Aspect Advice, if an EXCEPTION is thrown, YOU CAN PREVENT THE TARGET METHOD FROM BEING EXECUTED! (useful security feature)

The other types of Aspect annotations available are:
@Before â€” before method execution
@After â€” after method execution (always executes)

@AfterReturning â€” after successful return

Eg: @AfterReturning(
    value = "execution(* rewards.internal.*.*(..))",
    returning = "result"
)
    public void afterReturningAdvice(JoinPoint joinPoint, ReturnType result) {}

WARNING: APART FROM MATCHING METHOD's RETURN TYPE in expression, ASPECT ALSO WONT BE TRIGGERED IF THE PARAMETER pointed to by 'returning' in annotation, of this advice method parameter, IS NOT OF THE SAME RETURNTYPE AS THE METHOD MATCHED.
Also, the 'returning' variable name specified in annotation should EXACTLY match a variable name in this advice method ELSE RUNTIME EXCEPTION WILL OCCUR. Just that if type of that variable in this above advice method param is different means method wont be matched DESPITE EXPRESSION DOES MATCH OR NOT.


@AfterThrowing â€” after (only if) exception thrown. Remember, THIS DOES NOT PREVENT THE ORIGINAL EXCEPTION FROM BEING THROWN! (But you can instead throw a new exception inside this method if you want a NEW MORE ELEGANT EXCEPTION INSTEAD OF THE ONE that was originally thrown.)

Eg: @AfterThrowing(
    value = "execution(* rewards.internal.*.*(..))",
    throwing = "ex"
)
    public void afterThrowingAdvice(JoinPoint joinPoint, Exception ex) {} // Similar to above example, here also the Exception type mentioned HAS TO BE MATCHED along with the expression for this method to be executed. (CAN ALSO BE A SUBTYPE OF THE MENTIONED EXCEPTION OFCOURSE)


@Around - This annotation, UNLIKE the above ones, DOES NOT HAVE THAT 'other than exception, return type also has to match'  condition, so only filter expression matters.
	  Return type of below method CAN be the specific type or Object also (TESTED, no issue). Just ensure you do proper typecasting, and RETURN PROPER COMPATIBLE VALUE.
	  When method is kept as void instead, VALUE RETURNED BY ORIGINAL METHOD BECOMES NULL!!! (printed this after method call line - "THE SECTION OF CHANGE IS OVER: null")

	  YES, WHAT VALUE YOU RETURN HERE WILL BE RECEIVED BY ORIGINAL METHOD CALL (and null, if this method is void)
	  AND if .proceed() is NOT called, then the ORIGINAL METHOD CALL DOESNT EVEN HAPPEN!!! (TESTED THIS, the before and after print statements were printed consecutively with NO 
	  "RandomClass.randomMethod() was called" in between those prints)

@Around(value="execution(@java.lang.Deprecated String rewards.internal.RandomClass.*(..))")
public String afterRandomMethod(ProceedingJoinPoint pjp) throws Throwable {         	     //throws is MANDATORY as proceed() method NEEDS THIS regardless of what method matches.
     System.out.println("Aspect triggered before randomMethod!");
     String returnedValue = (String)pjp.proceed();					     // If this line isn't called, original method call itself DOESNT HAPPEN!
     System.out.println("Aspect triggered after randomMethod! : "+returnedValue);
     return "DUMMY";									     //THIS VALUE WILL BE RECEIVED BY THE CALLING METHOD INSTEAD!!!
}

Output:
RewardNetworkImpl.rewardAccountFor() was called & Started
Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!
Aspect triggered after randomMethod! : RandomClass
THE SECTION OF CHANGE IS OVER


Limitations of Aspect advice: -
* ONLY WORKS FOR Non-PRIVATE METHODS
* Can only apply aspects to methods of SPRING MANAGED BEANS.
* IMPORTANT NOTE: IF in (say) RandomClass which is a spring bean/component, if randomMethod made another call to randomMethod2 OF THE SAME Component/Bean,
		  then randomMethod2 WILL NOT BE EXECUTED ON THE PROXIED BEAN AND HENCE, IT WONT TRIGGER ASPECT METHOD for that or any method calls inside it OF SAME BEAN!!!
		  But if you inject and CALL A NEW BEAN's method internally OTHER THAN THIS ONE, that would be proxyied and ASPECT WILL BE TRIGGERED accordingly (nested way as you expect).
		  		  
[See Notes section for detailed outputs]


Regarding the JUnit testing: -

Yes, @SpringBootTest is the equivalent APPROXIMATELY of all these plus maybe more: @ExtendWith(SpringExtension.class), @ContextConfiguration, @EnableAutoConfiguration,@TestPropertySource(optional, just like @PropertySource), @WebAppConfiguration â€” (optional, if you want a web environment).

@EnableAutoConfiguration - Optional. It enables Spring Bootâ€™s auto-configuration, but if your config class already sets up everything, you may not need it.
In Spring Boot tests, itâ€™s often included for convenience, but not strictly required if your context is fully defined.

Eg: Assume spring.datasource.driver-class-name/url/username/password all this is in a included properties file, and PostgreSQL JDBC driver JAR is in classpath.
    Then, If you used @Autowired to inject DataSource and you did'nt have a bean declared, This annotation WILL CREATE ONE IF THESE 2 ABOVE CONDITIONS ARE IN PLACE.

Same way, for autoconfiguring ObjectMapper as a bean (if org.fasterxml.jackson dependency is there), and EntityManagerFactor bean, if spring-boot-starter-data-jpa is there, etc.,
All such things this annotation may take care of, if the properties are in place (if any required).



JUnit 5 : -

JUnit5 is the default version from Springboot 2.6, and was a major feature of Spring 5.3
Requires Java 8+ Runtime.

Components oof JUnit: -
* JUnit Platform - Foundation for launching test frameworks on the JVM.
* JUnit Jupiter - An extension model for writing tests and extensions in JUnit5
* JUnit Vintage - A TestEngine for running JUnit 3 & 4 tests on the Platform. (for older JUnit tests execution)

Annotations NAME-CHANGED from JUnit 4 changed to JUnit 5:
@Before		==> @BeforeEach
@BeforeClass	==> @BeforeAll
@After		==> @AfterEach
@AfterClass	==> @AfterAll
@Ignore		==> @Disabled

(@DisplayName, @Nested, @ParameterizedTest , etc. are NEW annotations in JUnit5)

Note: It's very EASY to MIX AND MATCH JUnit5 and OLDER JUnit annotations, IT WONT WORK!!! Please check if ALL annotations are FROM org.junit.jupiter...

Diff between:
Stub: Provides fixed mockedresponses, no verification.
Mock: Provides responses and verifies interactions (can set expected number of calls done, how many arguments, etc. and verify this).

Difference between:

Unit Testing:
Tests one unit of functionality, isolated from the environment (including Spring)
Keeps dependencies minimal, uses simplified alternatives like Stubs and/or Mocks.

Integration Testing:
Tests MULTIPLE units working together, All units should first work individually.
In some kind of appcontext, but out-of-container testing, no need to run full App/Server.
Infra can be scaled down, like using ActiveMQ instead of Commercial messaging servers, using throwaway instances of common databases, etc.


@ExtendWith(SpringExtension.class):
It is a JUnit 5 annotation that tells JUnit to use Springâ€™s testing support for this test class.
It enables Spring features in your test, like dependency injection (@Autowired), loading the application context, and managing beans.
JUnit4 had Runners (@RunWith,but were unable to use multiple runners), now we have @ExtendWith which can RUN JUnit5 WITH SPRING EXTENSION (support)

@ContextConfiguration(classes={SystemTestConfig.class}):
TestContext framework, defines appcontext for tests, and USES THIS ANNOTATION to specify which configuration class to use for the application context.

FUN FACT: @SpringJUnitConfig(SystemTestConfig.class) IS THE COMBINATION OF THE ABOVE 2 ANNOTATIONS (@ExtendWith(SpringExtension.class) and @ContextConfiguration(classes={SystemTestConfig.class})).
And when either of these config specifications are used, THERE IS NO NEED FOR manually running springboot application .run() to create context (it handles it).


IMPORTANT NOTE: In Normal Springboot application, YOU CANNOT INJECT @Autowired to SPECIFIC PARAMs in a method alone instead of whole method,
like @Autowired on top of constructors, setters, fields, OR EVEN NORMAL methods also its allowed (Not recommended but allowed, called onces after initialization), BUT NOT INDIVIDUAL METHOD PARAMS.

BUT IN JUnit5 ALONE, for a @Test annotated function, I CAN USE @Autowired ON A @Test METHOD PARAMETER(s) to inject as dependencies, as usually these methods DONT have any params.

Another thing to do which INVOLVES JUnit Tests:
@ParameterizedTest
@ValueSource(strings = {"string1","string2","string3"})
void testMethod(String temp){}

The above test is RUN 3 TIMES, EACH TIME WITH ONE VALUE FROM WHAT @ValueSource provides. (basically to avoid repetition this annotation is used)


Multiple @Test methods in JUnit class WILL USE ONLY SAME ApplicationContext, not recreating each time as most beans are IMMUTABLE. So no need new.
 

Including an OVERRIDING/Changed @CONFIGURATION as EMBEDDED in your Test Class for that class alone to use the changed config.class: -

* First, DO NOT SPECIFY you Config.class in the @SpringJUnitConfig or the @ContextConfiguration annotations ON THE TEST CLASS. Just have @SpringJUnitConfig alone with no params.
* Inside the class body, have a static class like below TO IMPORT ANOTHER CONFIGURATION AND OVERRIDE ONE BEAN ALONE
(incase you want a different Bean instance/behaviour FOR RUNNING THIS CLASS ALONE, this can let you specify/redeclare for those one or 2 Beans)

@SpringJUnitConfig  //DO NOT SPECIFY Config class here or you cant override some beans aloe or this test class.
public class SampleJUnitTests {
   ...
   ...
   @Configuration
   @Import(SystemTestConfig.class)
   static class TestConfiguration{
	@Bean public Datasource dataSource(){...} //Now this bean returned will be used ONLY FOR THIS test class if injected, REST of the BEANS ARE TAKEN FROM SystemTestConfig.class
   }
}


@DirtiesContext : INCASE Your code DOES Change Beans/"Dirties" the context, if you annotate this on a @Test method, After this test, NEW Application context will be created.


@TestPropertSources(properties = {"username=foo","password=bar"},
		    locations = "classpath:/specialtestprops.properties")

Above annotation can be annotated on a Tests class TO OVERRIDE OR ADD properties to be used for Tests IN THIS CLASS.
Properties or property file mentioned this was HAVE HIGH PRIORITY and override any other property.


@ActiveProfiles({"jdbc","dev"}) OR spring.profiles.active=jdbc,dev
 - Annotation used on JUnit 5 class to take not just Non-profile-specific beans alone, but ALSO Beans, which are declared with @Profile("jdbc") (and "dev" ones too) on the configuration classes or bean classes (or EVEN ON BEAN METHODS), in the test application context.

Note: By default no profile is activated, there ISNT any default profile/profile name used.


@Sql({"/testfiles/schema.sql","/testfiles/load-data.sql"})   OR   @Sql(scripts="/testfiles/setupBadTransfer.sql")
   -   This annotation can be used on a JUnit5 test class to RUN THESE SQL scripts BEFORE EACH @Test method executions, UNLESS THE @Test method has @Sql specified for it especially, then it follows that annotation(s).
If used on JUnit5 TEST METHOD, it overrides the class level annotation, running the method specific @Sql scripts (by default, BEFORE the @Test execution).

@Sql(scripts="/testfiles/cleanup.sql",
		executionPhase=Sql.ExecutionPhase.AFTER_TEST_METHOD)   -    By default it is executed before, using this EXPLICIT option, it executes AFTER the @Test.

The @Sql annotation also has a config value you can specify:
@Sql(..., config = @SqlConfig(errorMode = ErrorMode.FAIL_ON_ERROR,
						commentPrefix="//", separator="@@") )

ErrorMode config options for @Sql in Spring:

FAIL_ON_ERROR: Stops execution if any SQL statement in the .sql file fails.
CONTINUE_ON_ERROR: Continues executing remaining SQL statements even if one fails.
IGNORE_FAILED_DROPS: Ignores errors from failed DROP statements, but fails on other errors.
DEFAULT: Uses the default error handling (usually same as FAIL_ON_ERROR). TYPICALLY takes @Sql config parameter from class level @Sql, OR DEFAULTS TO FAIL_ON_ERROR. (usually its fail on error)

Other config internal options (SQL syntax control):
commentPrefix: Marks the start of a comment in SQL scripts (e.g. -- )
separator: Defines the statement separator in SQL scripts (e.g. ; )


JDBC Template: -

Templates in Spring like: JdbcTemplate, JmsTemplate, RestTemplate, WebServiceTemplate.
They hide away boiler plate code, And can specify other details later if needed. All exception handling, resources are handled properly.

int count = jdbcTemplate.queryForObject("SELECT COUNT(*) FROM CUSTOMER", Integer.class); //HANDLES EVERYTHING ELSE!

// Note: queryForInt() and queryForLong() are deprecated and removed since Spring 4.2

It also allows CALLBACKS to be used to add the important implementation logic alone.
Eg: The logic to map the SQL row values into creating an object TO HOLD THOSE VALUES can be sent as a callback (RowMapper).

List<Customer> results = jdbcTemplate.query(someSqlStatementString,
    new RowMapper<Customer>(){
	public Customer mapRow(ResultSet rs, int row) throws SQLException {
	    //map the current row elements to Customer obj. int row will have value 0 if its first element, then 1,.. so on, use only if needed.
	    //The resultset POINTER WILL BE MOVED AUTOMATICALLY EACH TIME IN SEQUENCE, like mapRow() call is done INSIDE while(rs.next()){} !
	}
});

NOTE: while int row supplied by Spring starts from 0 as index, 
      rs.getString() TAKES INT PARAM FROM 1, NOT 0 !!! (That's because its part of old jdbc version while this int row is supplied by spring so its new)


JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // NEEDS Datasource as constructor param.
// JdbcTemplate class IS THREADSAFE AFTER CONSTRUCTION!
// So dont need to create one for each thread. Can be used anywhere even tests.

JdbcTemplate can query for the usual Simple types (int,long,String,Date), Generic Maps, Domain Objects

Query With Bind Variables:
jdbcTemplate.queryForObject("SELECT count(*) from person WHERE age > ? AND nationality = ?",
	Integer.class, 12, "Indian");

//BELOW METHOD update() IS USED FOR INSERT OPERATIONS ALSO!!!
jdbcTemplate.update("INSERT INTO NAME (first_name,last_name) VALUES (?,?)",
	"Matthew","Jonathan G");

jdbcTemplate.update("UPDATE NAME SET last_name=?","John")

jdbcTemplate.queryForMap("SELECT * FROM person WHERE id=?", 1) - Used to map query RETURNING ONE ROW into 1 Map<String, Object> object as return value.
jdbcTemplate.queryForList("SELECT * FROM person") - Similar as above except returns multiple Maps as List<Map<String, Object>>

NOTE: Depending on the DB driver, the case of the column name (aka Key) in the map can vary, cant say if it will be in upper or lower case for sure. (But Spring course example shows in uppercase depiction)

Domain Object Queries (Mapping of resultset to domain pojo objects using callback approach) :
* public interface RowMapper<T> {
	T mapRow(ResultSet rs, int row) throws SQLException;
}

Eg: 

jdbcTemplate.queryForObject("SELECT first_name,last_name FROM person WHERE id=?",
				(rs,rowNum)-> new Person( rs.getString("first_name"),rs.getString("last_name") ),
				idValue);  // Returns pojo object. and YES, Id value comes AFTER rowmapper lambda passed.
    
FOR MULTIPLE OBJECTS To be returned, use .query() method instead, REMOVE the idValue param supplied as syntax related changes.
And it will return List<PojoObject> in this case.

* public interface ResultSetExtractor<T> {
	T extractData(ResultSet rs) throws SQLException, DataAccessException;
}

Eg: Same as .query() method syntax above, EXCEPT that LAMBDA NEEDS TYPE CASTING (as THERE IS AMBIGUITY due to other ResultSet variations of .query() method, but RowMapper doesn't have this issue)

jdbcTemplate.query(
	"SELECT ID,NAME FROM order o WHERE confirmation_id=?",
	(ResultSetExtractor<Order>) (rs) -> {
		// THIS LAMBDA RUNS ONLY ONE TIME! So MANUALLY iterate and map rs to return 1 object of type Order.
		// Get the rs column values using rs.getLong("ID"), rs.getString("NAME") inside while(rs.next()){}
	},
	confirmationIdValue	// Same as rowmapper syntax, after lambda only the '?' param values are supplied
)

* RowCallbackHandler is similar to RowMapper, but IT DOESNT RETURN ANYTHING. Its just for processing and not returning some obj.

public interface RowCallbackHandler {
	void processRow(ResultSet rs) throws SQLException;
}


** CAUTION ** : the .query() method accepts ALL 3 callback obj types,
		BUT .queryForObject() ONLY ACCEPTS RowMapper CALLBACK, not other 2 !!!
		REST OF THE 2 QUERY METHODS (list and map), and update() DO NOT ACCEPT SUCH CALLBACKS !

Exception Handling: -

SQLException, like all other checked exceptions MAKE TIGHT-COUPLING of methods AS ALL INTERMEDIATE METHODS NEED TO DECLARE TO THROW such exceptions,
Incase you want to handle the exception at a higher level, so all method signatures have to handle this correctly, a nuisance.

DataAccessException is provided by Spring, an UNCHECKED HEIRARCHY of Exceptions which WRAPS SQLException by catching it,
giving A MORE MEANINGFUL EXCEPTION TYPE THROWN.

Like instead of SQLException, it can be wrapped into some meaningful unchecked exceptions like: 
BadSqlGrammarException (if there is sql syntax error),
DataAccessResourceFailureException, CleanupFailureDataAccessException, OptimisticLockingFailureException, DataIntegrityViolationException.



Transactions : -

ACID principle:
Atomicity - Each unit of work done is ALL OR NOTHING operation. Either full work committed or ROLLED BACK.
Consistency - No DB integrity rules or constraints are violated, ensures DB always is in valid state/data.
Isolation - Isolating changes (in progress/uncommitted) of transactions from each other. Only when one is committed, it's visible to the other.
Durablity - Once transaction is committed, changes are permanent, and can survive a system failure, power outage, etc. (Non-volatile)


Without transaction, till now, each time DB connection was acquired, used, and then released, several times this happening in 1 atomic work is bad. Transaction should/will ensure ONE connection is reused for such individual db operations, then released. Either all succeed or fail.

Separation of Concerns
Demarcation (@Transactional): You mark a method to indicate it should run in a transaction. Spring handles the rest automatically.
Implementation (PlatformTransactionManager): An underlying component handles the actual transaction logic (begin, commit, rollback), based on the configured manager.

2 Ways to use/include transactions in your code: -
Declarative (@Transactional): Recommended. Use an annotation. Spring's AOP creates a proxy that intercepts the method call to manage the transaction.
Programmatic (TransactionTemplate): Less common. Manually control transactions inside code for fine-grained control.

Global vs. Local Transactions
Spring uses @Transactional for both. Your code doesn't change when switching between them.
Just change the PlatformTransactionManager bean in your configuration between them.

The PlatformTransactionManager: -
Abstraction: A generic interface in Spring for transaction strategies.
Implementations: Different managers for different needs.

Local transactions (single resource [db/msg queue] ) : These manage transactions for a single resource, such as one database or one message queue.

DataSourceTransactionManager: Manages transactions for a single JDBC DataSource. Use this for applications that access a database via plain JDBC.
JpaTransactionManager: Handles transactions for a JPA EntityManagerFactory. This is typically used with JPA providers like Hibernate.
JmsTransactionManager: Manages transactions for a single JMS ConnectionFactory. It's suitable for applications that only involve a single message queue.
HibernateTransactionManager: Manages transactions specifically for Hibernate's native SessionFactory API (without using JPA).

Global transactions (multiple resources [db/msg queue]): These coordinate transactions across multiple transactional resources, like several databases or a database and a message queue. They require a transaction manager in an application server or a standalone JTA provider. They CAN ALSO DO local transactions but just more overhead due to TWO phase commits.

JtaTransactionManager: Delegates transaction management to the JTA (Java Transaction API) provider, which is often part of a Java EE/Jakarta EE application server. This is the standard choice for distributed transactions.
WebLogicJtaTransactionManager: A specialization of JtaTransactionManager for the BEA (now Oracle) WebLogic application server, providing additional vendor-specific features.
WebSphereUowTransactionManager: A specialization for the IBM WebSphere application server, using its Unit of Work (UOW) API to manage global transactions.

Just like other concepts, Transaction ALSO WORKS BY PROXYING THE BEAN, simply having SpringTransactionInterceptor intercept any request for target method/class (both work together as 1),
And it communicates with TransactionManager to begin/commit, adding transaction management behaviour to the code.

As expected, Transaction is started before entering method, Commits at end of normal method execution.
ROLLBACKS if method throws a RuntimeException BY DEFAULT. (can be overridden)
Checked exceptions DO NOT CAUSE ROLLBACK BY DEFAULT, BUT ALL THIS EXCEPTION BEHAVIOUR CAN BE OVERRIDEN USING:

@Transactional(rollbackFor = MyCheckedException.class, noRollbackFor = MyRecoverableRuntimeException.class))

Caution: Incase similar exception type (or even same) is mentioned in both opposite attributes, noRollbackFor takes PRECENDENCE !

Transaction context bound to Current Thread HOLDS THE UNDERLYING JDBC CONNECTION. Hibernate sessions, JTA (Java EE) work similarly.
JdbcTemplate CAN USE this capability automatically IF USED IN @Transactional method.

(Can also fetch Connection manually using DataSourceUtils.getConnection(dataSource))
--------------

Step 1: @EnableTransactionManagement (add to config class)

Step 2: Create a Bean returning PlatformTransactionManager implementation.

Step 3: @Transactional (add on method required to be transactional)

Eg: DataSourceTransactionManager is created by new DataSourceTransactionManager(dataSourceObj);
    While new JtaTransactionManager() doesn't required any constructor param.

@Transactional can be declared on CLASS or EVEN INTERFACE! (since Spring 5.0)

@Transactional(timeout=60) - Sets timeout in seconds for transaction if it exceeds it.

IF USED ON CLASS, its the default value for all methods in it, IF METHOD HAS the annotation TOO, it will use that specifically for that method alone instead.

WARNING: JAVA ALSO HAS @Transactional annotation, BUT ITS NOT THE SAME AS SPRING's @Transactional.
	 BE CAREFULY AND USE ONLY THE SPRING ONE.


@Transactional( propagation = Propagation.REQUIRED ) : [ DEFAULT VALUE ]

Creates one (obviously as usual) if method not in a transaction already.
If a @Transactional method CALLS ANOTHER @Transactional method, WHAT HAPPENS ???
The Transactions JOIN TOGETHER, which is one way. (Though marked as 2, internally logic works like 1 transaction)


@Transactional( propagation = Propagation.REQUIRES_NEW )

If you really want separate transactions, you can specify it. It will be separate independent transactions.
And NO, THEY AREN'T NESTED, Like Second Transaction can commit, but First can fail, that wouldn't happen if they were "nested" right? so yep,
It CREATES NEW INDEPENDENT TRANSACTION ALWAYS (If already one is there, it SUSPENDS it temporarily) !


CAUTION (MASSIVE ONE):

JUST LIKE OTHER PROXY BEAN BEHAVIOUR, if one @Transactional annotated method calls another one,
WHICH IS IN THE SAME CLASS, then THE CALL DOES NOT GO THROUGH PROXY BEAN, and hence THAT SECOND METHOD's propagation rule WONT APPLY !!!
Think about it, Proxy is injected instead of real target, so when you call method FROM ANOTHER BEAN, it will call proxy,
AS METHOD CALL HAPPENS ON OBJECT INJECTED (aka meaning its proxy if applicable).

BUT CALLING FROM THE METHOD (which you called using proxy bean) to another method INTERNALLY INSIDE SAME CLASS,
It's not calling on the proxy bean actually, it will call the actual TARGET class method itself DIRECTLY (think about it),
Proxy cant intercept if YOURE ALREADY INSIDE THE TARGET, only if outside and you injected and used obj, it can act as proxy.
Internal calls are directly in the target obj itself, like its literally that datatype as the class name, cant be some random proxy class.


You CAN make @Test methods TRANSACTIONAL !
But in this case, if you make it so, IT WILL ROLLBACK FOR SURE (since it's a test), UNLIKE THE MAIN CODE WHERE IT CAN COMMIT IF NO ERROR.

Warning: IF YOU START different TRANSACTION INSIDE the method body, then this RULE DOES NOT APPLY.

If you REALLY WANT TO COMMIT @Test method changes, NOT rollback, then:
@Commit if you use on the @Test method (@Transactional either on method or class itself), THEN IT WILL COMMIT TRANSACTION like main code!



----------------------------------

Springboot Course:=

Usually in springboot main class, we use 3 annotations together:

* @SpringBootConfiguration - Marks a class as a source of configuration specifically for a Spring Boot application.

* @ComponentScan - Tells Spring which packages to scan for components like @Component, @Service, and @Repository. This automatically registers them as beans in the application context. 

* @EnableAutoConfiguration - Automatically configures Spring beans based on the dependencies found in your project's classpath. For example, it sets up a web server if you have spring-boot-starter-web.


@SpringBootApplication(scanBasePackages="example.config") CAN REPLACE THESE 3 into just 1 annotation !!

In springboot, autoconfiguration checks like h2/derby/etc is there in classpath, then datasoure obj can be created or not based on properties etc.

A "Fat" JAR basically contains ALL dependencies required to run the web application. (even the required tomcat server)
So it can be simply run using the java -jar command.

Using the mvn package command or the gradle assemble command, you can create the required jars:
Eg: my-app.jar can be the executable "FAT" JAR,
whereas my-app.jar.original can be the "usual" JAR. (has ONLY CODE without the depndencies)

The below dependenency mentioned inside a <plugin>...</plugin> alone, WILL CREATE A "FAT" JAR:
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-maven-plugin</artifactId>

Ensure to use springboot:run option as a goal to it, so it runs the app.

@SpringJUnitConfig(SystemTestConfig.class) is usually used till now for JUnit 5 testing as it creates beans in test app context
only as many as required, NOT doing it exactly like it would happen in the real application.

@SpringBootTest(classes=Application.class) - IT'S THE ANNOTATION you can use to RUN THE ENTIRE application like in the main app run.
It's ideal for more general like Integration tests.

@SpringBootConfiguration - Optionally, you DONT have to mention the classes param value in the @SpringBootTest annotation
ONLY IF you have this annotation @SpringBootConfiguration on your TestConfiguration class where there is @ComponentScan, @EnableAutoConfiguration, etc.

WARNING: If you use @SpringBootTest ALONE no params in your test class,
YOU HAVE TO ENSURE the @SpringBootConfiguration annotated TestConfig class IS IN A PACKAGE ONE LEVEL HIGHER THAN the former.
And ONLY ONE of such configuration classes can exist in a hierarchy, basically NO multiple PRIMARY configuration classes.
(but generally multiple normal config classes allowed!)


Ideally to start springboot project, you can use spring initializer (also opensource),
But mainly 3 files are needed: pom.xml (for maven), Application.java (main class) , and application.properties


@SpringBootApplication is a combination of 3 annotations:
@SpringBootConfiguration (primarily to specify main class without specifying in SpringTests)
@EnableAutoConfiguration (Some Beans are autocreated based on classpath dependencies)
@ComponentScan

For example, JdbcTemplate WILL BE AUTOCREATED in app context, just inject it and use.

Commands to run app:
"mvn package" then use "java -jar JarName.jar"


logging.level.root=DEBUG
# Logs only log statements of MORE SEVERE OR EQUAL to the specified level.
# List of Logging levels (in asc. order of severity):
# TRACE (least severe)
# DEBUG
# INFO
# WARN
# ERROR
# FATAL (most severe)


If you keep 2 SQL files names schema.sql and data.sql,
IN A FOLDER PRESENT IN CLASSPATH (like "src/main/resources"),
Then SpringBoot WILL RUN IT automatically at the start,
Else if it is in some other subfolder, use this:
#path like classpath:db/schema.sql can be used
spring.sql.init.schema-locations=<path to your schema SQL file>
spring.sql.init.data-locations=<path to your data SQL file>

If you have banner.txt and it contains something (ideally meant to be like \___\ symbols used diagramatically),
Then at start of running application, SPRINGBOOT WILL DISPLAY THIS BANNER INSTEAD OF THE DEFAULT ONE.

assertThat(1).isEqualTo(21); is example of asset statement in test.



Environment and @Value annotation can be used to fetch properties and env values from application.properties or other @PropertyConfig sources.

application.properties is looked for in priority in following:
* /config subdirectory of the working directory (config subdir in the directory where executable jar is executed in target folder)
* The working directory (same directory as executable jar in target folder)
* config package in classpath (eg: src/main/resources/config/application.properties)
* classpath root (eg: src/main/resources/application.properties)

(if multiple same property is mentioned in the same file twice or more, LAST ENTRY IS TAKEN.
Also YOU SHOULD ONLY put properties of imp early created beans properties in this file or yaml (like LOGGING LEVEL or other important early initialized beans), not in some random PropertySource as application.properties or .yaml is loaded first)

Apart from this, springboot also looks for PROFILE-SPECIFIC like application-dv.properties

YAML FILE properties also can be specified: -

- environment.getProperty("server.port") or  @Value("${my.app.name}") can ONLY be used with snakeyaml.jar inside spring-boot-starter dependency is used)

- .yaml files neeed to use 2 spaces for indentation rather than tab space.

- ALL 2x4=8 possible files are attempted to be loaded.

- The SAME PRECEDENCE order as for .properties files is used, where IF BOTH .yaml and .properties ARE IN THE SAME LOCATION,
  any SHARED properties in .properties file IS MORE PRIORITY THAN one in .yaml.

- The parsing done to find these IS DONE FROM LOWEST PRIORITY, as it comes to higher priority files, PRE-EXISTING PROPERTIES ARE OVERWRITTEN WHEN ENCOUNTERED. So just follow priority list of 8 files blindly, but all 8 files are looked if they have some unique properties atleast.

- In yaml, the following way can be used to specify different profile properties IN SAME yaml FILE:

.....
..... (Common properties here always loaded, till the 3 dashes is encountered)
---
spring:
  profiles: local
  datasource:
    url: .......
---
spring:
  profiles: cloud
  datasource:
    url: .......



Properties Overall Heirarchy (in order): -

1. Devtools settings
2. @TestPropertySource and @SpringBootTest properties
3. Command line arguments
4. SPRING_APPLICATION_JSON (inline JSON properties).
5. ServletConfig / ServletContext parameters.
6. JNDI attributes from java:comp/env
7. Java System properties
8. OS environment variables
9. Profile-specific application properties
10. Application properties / YAML
11. @Property Source files
12. SpringApplication.setDefaultProperties.



@ConfigurationProperties :

If you want to map certain properties to a BEAN OBJECT, like these:
reward.client.host=192.168.1.42
rewards.client.port=8080

YOU CAN INJECT PROPERTIES INTO A BEAN OBJECT FOR ACCESS SOMEWHERE ELSE!

@ConfigurationProperties(prefix=rewards.client) //all properties will be fetched with this prefix
public class ConnectionSettings{ //Inject this bean anywhere like normal to get properties
	private String host;
	private int port;
// getters and setters are mandatory ofcourse
}

WARNING: To enable this behaviour of property injection using this annotation, 3 WAYS are there:
* Annotate @Component on above class
* Annotate @EnableConfigurationProperties(ConnectionSettings.class) on MAIN CLASS.
* Annotate @ConfigurationPropertiesScan on Main class (springboot 2.2.0+ onwards),
  Like @ComponentScan, THIS TOO SCANS the package of the class it's hosted on AND it's subpackages.


WARNING: If @ConfigurationProperties is used say with "rewards.client-connection", hostUrl as a variable,
The VARIOUS LEGAL MATCHES NEED NOT BE EXACT, CAN VARY SLIGHTLY AS FOLLOWS: (mix & match mostly is a NO)
* rewards.clientConnection.hostUrl (Camelcase words separation)
* rewards.client-connection.host-url (hyphens)
* rewards.client_connection.host_url (underscores)
* REWARDS_CLIENTCONNECTION_HOSTURL (For matching with ENV variables, capitalizes, removed dashes,
	replaces dots with underscores, and using this new string, it searches for a value in envs.)


@EnableAutoConfiguration (or just @SpringBootApplication is enough) on main class enables Spring's Configuration classes. (can create our own too)
They are @Configuration classes which are activated CONDITIONALLY based on things like:
Do classpath include specific classes, or some specific properties are set, or some beans already configured (or not)

Eg: JdbcTemplate is autoconfigured IF a DataSource bean is present in context,
Which can be present if there is dependency in classpath + properties relevant are there in properties files.


@ConditionalOnBean(DataSource.class) :
This annotation when annotated on bean class/method, IT's ONLY actually initialized as bean IF DataSource bean is present.

@ConditionalOnClass [If given class exists in classpath], @ConditionalOnProperty [If given property has a particular value],
@ConditionalOnMissingBean / ...MissingClass [Similar to above except only creates bean IF SPECIFIED BEAN/CLASS is missing instead]		
(Even @Profile annotation is in this category)


@AutoConfiguration annotation specifies a class EXPLICITLY for autoconfiguration. (Can be overridden)
Such classes only are enabled AFTER THE EXPLICIT beans you specify are CREATED.
(so missing ones are configured, and your beans defined always are preferred over AutoConfiguration beans)

There are 4 ways to controlling autoconfig classes:
- Set Springboot properties
	Eg: In springboot, spring.datasource.url/username/etc properties if are present, DataSource is prepared using @ConfigurationProperties("spring.datasource") on a bean,so only if you configure these properties you can control the datasource's params.

  Eg: Same way logging.level.org.springframework=DEBUG is a kind of property to control the logging framework.
      Basically whatever you put after "logging.level.", THAT PACKAGE's LOGGING WILL ONLY BE AFFECTED. More specific ones OVERRIDE general ones.
      (Springboot uses SLF4J as default "facade"/pattern interfaces/classes, with LogBack implementations for it, this is recommended)


-Explicilty specify the beans yourself so springboot won't

- Explicitly disable some AutoConfiguration

@EnableAutoConfiguration and @SpringBootApplication has (exclude=DataSourceAutoConfiguration.class) option for you to EXCLUDE any class you dont want so it doesn't autoconfigure.
(OR)
Have this property: spring.autoconfigure.exclude=\
			org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration

(Yes, a property can be extended beyond more than 1 line using '\' operator, next line you can indent and put value without issue)

- Change dependencies or their versions.

If you want to use Jetty instead of Tomcat server, you can specify spring-boot-starter-jetty dependency, BUT EXCLUDE tomcat FROM STARTER WEB DEPENDENCY as follows:
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
	<exclusions>
		<exclusion>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
		</exclusion>
	</exclusions>
</dependency>


As seen before, DataSource can be Auto-configured by 3 ways: predefined properties, define own bean instead,
CHANGE UNDERLYING DATASOURCE CONNECTION POOL IMPLEMENTATION

Connection pool can create and contain multiple connections for multiple usage to prevent multiple connections open and close.

You have seen spring.datasource.url/username/password/driver-class-name
We have below properties for AFFECTING UNDERLYING CONNECTION POOL (doesn't look so but yes) :
spring.datasource.initial-size/max-active/max-idle/min-idle

Note: Each connection pool IS FOR ONE DATABASE, yes multiple of such connection objects are there
      So they can use DIFFERENT NETWORK SOCKETS FOR THE SAME DB FOR CONCURRENCY/PERFORMANCE (or each db operation has to wait for the other)!


Default Pooled DataSource for springboot 1.x.x is Tomcat and for 2.x.x its Hikari. (can be in sp-bt-starter-jdbc or ..-..-starter-jpa)
Apache Commons DBCP2 is the backup if both dependencies arent present.
Can use spring.datasource.type to pick pool explicitly.

Even if regular datasource general property can be used, spring.datasource.tomcat.*, or x.x.hikari.* or x.x.commons-dbcp2.* are for FINEGRAIN control of properties.


CommandLineRunner and ApplicationRunner are basically having run() method WHICH RUN AFTER CONTEXT HAS ALL BEANS CREATED.
Its to ensure you dont put application logic in main method of mainclass, instead have this as Bean inside the main class.


    @Bean
    CommandLineRunner commandLineRunner(JdbcTemplate jdbcTemplate){ //You can autoinject any bean req

        String QUERY = "SELECT count(*) FROM T_ACCOUNT";

        // Use Lambda expression to display the result
        return args -> System.out.println("Hello, there are "
            + jdbcTemplate.queryForObject(QUERY, Long.class)
            + " accounts");
    }

ApplicationRunner interface has below method where it HAS ARGUMENTS FROM CMD (Can use LAMBDA INSTEAD to return like above)
public void run(ApplicationArguments args) throws Exception {
	// !nonOptionArgs.isEmpty()
	// nonOptionArgs.get(0)     // Basically gets first argument which ISNT part of like "-jar target/xxx", aka without respective option
}


spring-boot-maven-plugin : This dependency is required for packaging, running, and reloading Spring Boot apps via Maven.
			   (Eg: executable jar generated which can be executed using java -jar, ca also run using mvn clean package spring-boot:run)

Steps converting spring project to springboot: -
* Added @SpringBootApplication annotation to main class.

* Use @SpringBootTest instead of regular spring annotations like @ContextConfiguration(classes = {SystemTestConfig.class})
as while the ContextConfiguration annotation will just include ONLY THE CONFIG CLASS YOU SPECIFY.

The SpringBootTest annotation does 3 things (as told long before):

Load the full application context
Scan for components and configurations in the current package and subpackages
- ANY CONFIG inside SAME OR SUBPACKAGE of @SpringBootTest class, IT WILL BE DISCOVERED BY DEFAULT. (DOESNT MATTER main/test folder, all is same!!!)
- If you MENTION CLASSES AS PARAMS, it will ONLY INCLUDE THOSE and ignore rest (unless there is @Import or @ComponentScan usage in the classes it scans).

@ContextConfiguration:
Loads ONLY WHAT CLASSES you specify.
IF you dont specify, checks for DEFAULT CONFIG IN SAME PACKAGE, not subpackages.(aka class annotated with @Configuration OR an XML file EXACTLY named applicationContext.xml)

IMPORTANT: @SpringBootTest DOES NOT AUTOMATICALLY ENABLE AUTOCONFIG (like i incorrectly suspected),
	   Since main class ALSO was under "package rewards;", the SystemTestConfig PICKS UP THE CLASS AS CONFIG (no class params in test annotation),
	   And thus enables AutoConfiguration since the @SpringBootApplication (or xxConfiguration) does this unless explicitly excluded.

	   Now thats why it looked like WHEN SPECIFYING CLASSES IN @xxTest annotation it DIDNT ENABLE Autoconfig (and datasource wasnt found),
	   BUT when no params were given to the test annotation, IT ENABLED, because IT SCANNED MAIN CLASS IN SAME PACKAGE!!!

So remember that by default without any @EnableAutoConfiguration, or @SpringBootApplication which doesnt exclude the autconfig class, 
Then actually @SpringBootTest DOES NOT DIFFER IN THIS ASPECT like ContextConfiguration. (@SpringBootConfiguration WONT ENABLE THIS!)

So just that @ContextConfiguration only checks the same package for a @Configuration class or applicationContext.xml (otherwise nothing more),
Is the MAIN DIFFERENCE BETWEEN BOTH! While this is IDEAL FOR UNIT TEST,
@SpringBootTest is for INTEGRATION TESTS as the BOOT context starts up.


@SpringBootApplication on the main class ALSO acts like @SpringBootConfiguration (default main config marker annotation),
Meaning the SpringApplication.run() CAN HAVE THIS SAME CLASS as it's parameter for configuration.

If NO packages are specified for scanning components, ALL OF THE SAME + SUBPACKAGES classes ARE SCANNED! 
If you dont supply config or any class to run() in main class, it assumes the same class as the one to be passed (not some weird scanning).

The @SpringBootConfiguration is a marker annotation which is BASICALLY LIKE CONFIGURATION ENTRY POINT,
Minus the 2 things offered by @SpringBootApplication: @EnableAutoConfiguration and @ComponentScan; Usuall not preferred over the application annotation as main class usually is main config also

Can use this annotation in tests if you want a configuration entry point INSTEAD of main application class,
Therefore you can avoid loading (for some reason) THE ENTIRE CONTEXT which main class might include by @Import or component scanning, etc.
Instead here you can control what is scanned.

Locations where jars are stored:
cp *jdbc-autoconfig/target/*.jar temp (for Maven)
cp *jdbc-autoconfig/build/libs/*.jar temp (for Gradle)


@Order annotation, unlike the STRAIGHTFORWARD @Qualifier annotation, this:
- is used when injecting a collection (like List<BeanType> or Map<String, BeanType>).
- It tells Spring in what order to inject or execute those beans.
- It does not help select a specific bean.
- Has no effect on single bean injection.

Eg: 
@Component
@Order(1)
public class FirstHandler implements Handler { }

@Component
@Order(2)
public class SecondHandler implements Handler { }

@Autowired
List<Handler> handlers; // Injected as [FirstHandler, SecondHandler]

So it DOES NOT ACT LIKE QUALIFIER, just affects order incase List/Map<String, Bean> is injected.


Instead of using the annotation, your bean class CAN ALSO IMPLEMENT Ordered Interface FOR SAME EFFECT!
public interface Ordered { int getOrder(); }

Infact, @Order DOES NOT GET USED IF Ordered interface is implemented by a bean class!!! (preferred over what annotation @Order says).
Just implement the method in the class and override, lowest (1) value returned is highest priority.


-----------

Spring JPA: -
ORM Mapping: Maps Java classes to database tables using @Entity.
Auto Configuration: Spring Boot auto-configures JPA with minimal setup.
Repository Support: Use JpaRepository for CRUD without writing SQL.
Query Methods: Supports derived queries, JPQL, and native SQL.
Transaction Management: Handles commit/rollback automatically.
EntityManager Access: For custom persistence logic.
Relationship Mapping: Supports @OneToMany, @ManyToOne, etc.
Schema Generation: Can auto-create/update DB schema via properties.

spring-boot-starter-data-jpa is the dependency required as starter.
HIBERNATE WILL BE THE IMPLEMENTATION for this as JPA is just made of interfaces.

WARNING: @EnableJpaRepositories WONT BE NEEDED IF THIS DEPENDENCY IS INCLUDED, UNLESS there are rep. interfaces which
ARENT IN SAME OR SUBPACKAGES as your main class, then needed.
	@EnableTransactionManagement IS NOT EVEN NEEDED for default behaviour if this dependency is there!

If jpa is in classpath, springboot AUTOCONFIGURES:
- DataSource,
- JpaTransactionManager (remember @Transactional is just marker annotation, THIS BEAN HANDLES THE ACTUAL BEHAVIOUR)
  Eg: Can be created using EntityManagerFactory object passed as single param to JpaTransactionManager constructor.

- EntityManagerFactoryBean (creates & configures EntityManagerFactory, which inturn builds EntityManager objects,
	which are like smart helpers that let you save, update, delete, and fetch data as Java objects (handles ORM basically).),

---
Eg. of EntityManagerFactoryBean WITHOUT SPRING BOOT EASY WAY OF AUTOCONFIG (mostly FYI, not that important):
@Bean
public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
	HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter();
	adapter.setShowSql(true); // Enable SQL logging in the console
	adapter.setGenerateDdl(true); // Allow Hibernate to auto-generate database schema (DDL)
	adapter.setDatabase(Database.HSQL); // Set target database type
	
	Properties props = new Properties();
	props.setProperty("hibernate.format_sql","true"); // Format SQL output for better readability

	LocalContainerEntityManagerFactoryBean emfb = LocalContainerEntityManagerFactoryBean();
	emfb.setDataSource(dataSource);
	emfb.setPackagesToScan("rewards.internal"); // Packages To Scan for Entities for ORM
	emfb.setJpaProperties(props);
	emfb.setJpaVendorAdapter(adapter); // Hibernate Implementation (aka Adaptor) is added as the JPA's actual implementation.
	
	return emfb;
}
---

In springboot (dont need above code), @Entity is checked in the same package/subpackages by default (as told previously)
You can OVERRIDE WHERE IT SCANS FOR ENTITIES using @EntityScan("rewards.internal") to specify different BASE package.

Some Properties for jpa:
spring.jpa.database=default 	     # Springboot will try to select dialect for you, but default is enough as IT CAN FIGURE IT OUT BY ITSELF
spring.jpa.hibernate.ddl-auto=update # validate, create, create-drop are other legal values. Default val is none (does NOTHING at startup)
				     # Except for embedded databases, create-drop is default value in this case alone.
				     # validate - app startup fails if expected db tables format isn't there.
				     # update - modifies db schema to match entity classes. Adds cols/tables. NO DELETION though.
				     # create - DROPS AND CREATES schema (DONT MISTAKE AS IF THIS WONT DROP, it will)
				     # create-drop: One difference from create is IT DROPS ALSO WHEN YOU SHUTDOWN THE APP.

spring.jpa.show-sql=true    	     # Shows the SQL statements executed
spring.jpa.properties.hibernate.format_sql=true # Formats the SQL to beautify. Any other hibernate property can be access like this.

YES, JPA CAN be used for NO SQL DATABASES ALSO just like RDBMS ones!

Instant Repositories: a feature..just annotate the Interface with @Repository [OR] interface SpringDataCommon's Repository<T,K> (or subtype)
		      like CrudRepository<T,K>, JpaRepository<T,K> , etc, and define the keys & enable persistence,
		      Springboot will implement it with CRUD operations support, including paging, custom queries if any, sorting etc.

Annotations for RDBMS entities:
@Entity - Marks class as a persistence class
@Table - To specify what table to map this entity into (not mandatory but can use)
@Id - To mark id field in entity.
@GeneratedValue(strategy = GenerationType.AUTO) - Helps to specify id field value generation strategy.

Entity annotations for other dbs include : @Document [MongoDB], @NodeEntity [Neo4J] with @GraphId for id field, @Region [Gemfire]

The format for finder methods to just declare in repository interface you create is: [ALWAYS CHECK ENTITY's FIELD NAME MATCHES ALSO,
					if both conditions fail, then method wont be implemented automatically!]
find(First)By<DataMemberOfClass><Op>
<Op> - can be GreaterThan,NotEquals,Between,Like
Eg: findByOrderDateBetween(Date d1,Date d2)


You can also SPECIFY CUSTOM SQL QUERY FOR A finder method. Example:
@Query("SELECT c FROM Customer c WHERE c.email = ?1")
public List<Customer> findByEmail(String email); // ?1 is REPLACED BY parameter here


Note that JpaRepository<T,ID> extending interface supports WHICH EXTENDING Repository<T,ID> DOESNT SUPPORT:
- Basic CRUD operations like save(),delete(),findById()
- Batch operations (like saveAll(), deleteInBatch())
- Pagination & Sorting
- Flush operations,

COMMON THINGS BOTH SUPPORT:
- Finder methods autogeneration if declared
- Custom queries using @Query can autogenerate when explicit method declaration.
- Transactional behaviour

Note: @EnableJpaRepositories(basePackages="com.acme.repository") on a config file IS NOT MANDATORY IF the repositories are
IN SAME OR SUB PACKAGES of where @SpringBootApplication is in.

SpringData implements your repositories AT RUNTIME, creating proxies for injection so at runtime it intercepts method call to interface,
Gets query custom created and executes using Jpa.


Firstly, JpaRepository<T, K> is ideal to be extended by repository interfaces if you want the predefined default operations,
else the generic Repository<T,K> is better, as INCASE of test, you try injecting Stub* repository CLASSES instead,
Then remember, whatever predefined methods JpaRepository INTERFACE has, Stub* Repository CLASS MUST IMPLEMENT.
Usually hibernate will implement those predefined but youre injecting stub repository, so it's UNNECESSARY work for you, so you dont use in that case.

@Entity - Marks class as a JPA persistent entity class.
@Table(name="T_ACCOUNT") - Specifies exact table name to use from DB (would be class's name if unspecified).
@Id - Indicates the field to use as the primary key on the database.
@Column(name="ID") - Identifies column-level customization, such as the exact name of the column on the table. (optional if same name)
@OneToMany - Identifies the field on the 'one' side of a one to many relationship. (MARKS field as COLLECTION like List<>/Set<>)
@JoinColumn - Identifies the column on the 'many' table containing the column to be used when joining. Usually a foreign key.

Eg: Here ONE-TO-MANY relationship field is set (this entity's field will be on the "ONE" side, mapping to many Beneficiary entries)
    the field name (here it's "ACCOUNT_ID") is looked for in the injected datatype's entity (Beneficiary) and is mapped.
    
    @OneToMany
    @JoinColumn(name = "ACCOUNT_ID")
    private Set<Beneficiary> beneficiaries = new HashSet<Beneficiary>();

Remember: Jpa could POSSIBLY convert simple datatype differences like int and Integer, etc between this entity and other entity's
same named fields you try to join, but IT SHOULD PRACTICALLY BE SAME TYPE!


@AttributeOverride(name="value", column=@Column(name="ALLOCATION_PERCENTAGE"))
private Percentage percentage; // GETS this variable SET USING REFLECTION!

WARNING: A datatype/class used like above HAS TO BE ANNOTATED WITH EITHER @Entity or @Embeddable in this case (latter is the case here).
YES THE VALUES HAVE TO BE IN DATABASE. it starts using default constructor but values are assigned by ORM.

@Transient - In this case this annotation ensures while ORM is done, THIS FIELD IS IGNORED.
	     Saving entity or retreival of this entity from or to db WILL IGNORE THIS FIELD!

In SQL schema, identity keyword in table creation statements like "ID integer identity primary key"
AUTOINCREMENTS by 1 and saves the value (default behaviour atleast).


Remember: spring.sql.init.schema-locations & data-locations is the right property to set in springboot 2.x.x usually. (value is like "classpath:/xxx").


Spring MVC (Model/View/Controller): -

2 types of MVC applications: Web Servlet (what we will do, traditional web apps with limited threads/imperative programming style)
			     Web Reactive (eg: Netty/Undertow server supports this, reactive/functional programming, fewer threads, highly concurrent apps in real time)

Embedded servlet containers are supported by springboot. FAT jar contains even the container required to run springboot web apps from cmd!

spring-boot-starter-web is required for Spring MVC plus Spring Web. It DOES AUTOCONFIGURATION OF:
DispatcherServlet, default Message Converters, default resource locations (img, css, js, etc), internal config to support controllers, etc.

REST request-response processing lifecycle involves "Dispatcher Servlet" calling a "Message Converter" which converts the JSON/XML to Data/Objects,
which is how the Controller only deals with receiving and sending requests/responses as Objects while on the outside deals with JSON, XMl, etc.

Warning: @Controller is for Controller classes whose methods/endpoints RETURN VIEWS, NOT JSON/XML!!!
	 @RestController is the one whose methods return JSON/XML.
	 BUT annotating @ResponseBody on the methods/CLASS ITSELF in @Controller class is BASICALLY EQUIVALENT TO just using @RestController alone. (so RestController just spares that extra @ResponseBody annotation , ofc you cant use it if you need a method to return a View)

@GetMapping("/data") - specifies suburl for Get endpoint. Use it on class for a GENERAL base path applying to ALL GET requests (not others) in that class.
@RequestMapping("/api") - same as above except general to ALL requests in controller.

@RequestParam("userid") - This is for param. variable used in controller method, so a url query variable's value with given name is assigned to it. 
			  Even @RequestParam(value = "userid", required=false) exists to HAVE THIS PARAM AS OPTIONAL (doesn't throw exception unlike the usual case where it will)

@PathVariable("accountId") - Similarly but path variable value is assigned to method param. (both do 'implicit' type conversions decently)
			     suburl in method annotation should be like @GetMapping("/accounts/{accountId}") to let it know where in url it should take val.

Note: you DONT NEED TO SUPPLY PARAM to above 2 annotations if the variable names in query/suburl_path_var EXACTLY matches java variable name.

@RequestHeader("user-agent") - Gets the header received mapped to the method param variable you annotate this on.

The methods in controller CAN have ANY PARAMETERS which is available in Servlet Api like: Principal, HttpSession, Locale, HttpServletRequest, etc.

Except Protobuf (protocol buffers), springboot sets up everything else like XML conversions and JSON (using Jackson, gson for json too possible), form-based data, Byte[], String, BufferedImage, etc. google protocol buggers require 3rd party libraries on classpath for this to convert.

ResponseEntity (Subclass of HttpEntity):
You can return ResponseEntity<> instead for more control like sending status codes, SETTING RESPONSE HEADERS, content type etc.

Eg: ResponseEntity<String> response = ResponseEntity.ok()
					.contentType(MediaType.TEXT_PLAIN) //Sets the Content-Type header to let client know format of response
					.lastModified(System.currentTimeMillis()) // Sets Last-Modified header with 'long' type value
					.body("Hello Spring");

.contentType(MediaType.APPLICATION_JSON) is OPTIONAL if you use @RestController, as SpringBoot WILL SET THAT HEADER AUTOMATICALLY as application/json.


WAR file ARE NOT selfcontained ;like JAR files are, as they require external container to run it unlike JAR (fat jar) which can have everything required and run in cmd alone! To run as WAR file, you have to do this to main class as below :

//EXTEND main class WITH SpringBootServletInitializer and implement below method
protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
	return application.sources(Application.class);
}

The main method with SpringApplication.run(Application.class, args) CAN EXIST ALONG WTH ABOVE METHOD ALSO! IF BOTH ARE THERE,
Then while running as JAR, main method is used, when running WAR file, above method is used. that's all. Ensure that tomcat dependencies versions are compatible with the tomcat server version (if using tomcat as external server) in case of WAR. Same fat and thin WARs will be generated.

spring-boot-devtools (in org.springframework.boot) dependency can make development EASIER by HOT restarting application,
instead of cold restarting from the start EVERYTIME YOU MAKE A CHANGE TO A CLASS/ON RECOMPILING.
Use <scope>runtime</scope> (tells maven this is only for runtime, NOT for compile time dependency so it can ignore for build as not needed),
and <optional>true</optional> (tells maven that this dependency is NOT required by downstream projects, aka projects which take this project's POM as a parent to it, etc., besides you dont want this for production build)


<parent>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-parent</artifactd>
	<version>2.7.5</version>
</parent>

This parent can be added which serves 4 purposes: 
* Centralizes dependency versions without need to specify versions individually.
* Applies sensible defaults for compiler settings, encoding, plugin versions, etc.
* Manages plugin configurations: Like spring-boot-maven-plugin for packaging your app.
* Supports BOM (Bill of Materials): Ensures consistent versions across dependencies.

spring-boot-maven-plugin can be added to <plugins> as a <plugin> artifact so it can package and make FAT executable jars for mvn command to execute springboot directly also.

server.port=8088 # if not specified, 8080 is default
server.servlet.session.timeout=5m


spring-boot-starter-mustache : Dependency which adds support for Mustache template engine, renders .mustache template files for HTML views in controller.

If a dependency is a jar file/packaged project inside same repo/parent project, then you HAVE to ensure that is build and jar is generated first.
Then only other projects which import that subproject will work. (like just do mvn clean install, it works atleast)
IMPORTING A SUBPROJECT INTO ANOTHER SUBPROJECT IS SIMPLE, no extra steps. In root component body of pom.xml,
you specify <artifactId>, and maybe <groupId> right? That is enough, just import using these as <dependency> in the other subproject!!

Any PUBLIC classes, interfaces, beans, configuration, resources, AND TRANSITIVE dependencies declared in that subproject WILL BE INCLUDED! (No Source code ofcourse)


REST (Representational State Transfer) usually doesn't use HttpSession, as REST is supposed to be Stateless, forcing client to maintain state.
Jakarta EE (successor of Java EE, basically javax.* to jakarta.*) is a collection of APIs and specifications for building scalable, secure, and transactional enterprise apps. It covers everything from web services, servlets, and REST APIs to dependency injection, security, and persistence. But Spring MVC DOES NOT IMPLEMENT JAX-RS.

RestTemplate is used to build Rest clients in java.

@RequestMapping is generic annotation which can be equivalent to the composite annotation '@GetMapping(path="xxx")' by
@RequestMapping(path="xxx", method=RequestMethod.GET)

All enumerators are: GET,POST,PUT,PATCH,DELETE,HEAD,OPTIONS,TRACE (for these last 3, there aren't composite Mapping annotations separately)

PUT changes body of existing entity in 1 shot (giving null in some other field WILL SET IT AS NULL typically), where PATCH is ideally for changing one field alone.

Http Status Codes: 200 OK, 30x (Redirects), 4xx Client error (like 404 Not Found), 5xx Server Error (like 500 Internal Server Error)
		   201 CREATED sucessfully (sends back constructed url as "location" header, pointing to resource created), 405 HTTP method not supported,
		   406 Cannot generate Response Body in requested format, 415 Req body NOT supported.

@ResponseStatus(HttpStatus.NO_CONTENT) - If annotated on controller method, Then sends back with given status code.
					(instead of returning ResponseEntity<> as that can set response headers, etc additionally than this)

Note: If method is void, it sends back EMPTY BODY with given response code, aka 204 No Content.

@RequestBody - Annotate this ON THE CONTROLLER METHOD PARAM for PUT/POST to get the Request Body sent as an object.
	      (Can take from JSON/XML sent to endpoint BASED ON Content-Type header sent AUTOMATICALLY)

Warning: ResponseEntity<Void> is returned by controller method IF THERE IS NO CONTENT TO RETURN BUT JUST STATUS CODE ALONE!

UriComponentsBuilder        : Allows Explicitc creation of URI, requires hardcoded URLs.
ServletUriComponentsBuilder : Subclass of UriComponentsBuilder, which provides access to URL THAT INVOKED CURRENT CONTROLLER METHOD!

Eg: URI location = ServletUriComponentsBuilder.fromCurrentRequestUri() //takes currently called controller method url
			.path("/{itemId}") //Adds "/{itemId}" to whatever URL this contr. method is called through
			.buildAndExpand("item A") // Substitutes the placeholder Path Variable (WARNING: space becomes %20 when converted)
			.toUri();
ResponseEntity.created(location).build();

RestTemplate: 

Creating RestTemplate using new keyword is fine for normal configuration, BUT IF YOU HAVE PROPERTIES to be used to modify default props,
you can EITHER change in code itself OR properties file:

Eg: @Bean
public RestTemplate restTemplate(RestTemplateBuilder builder) {
    return builder
        .setConnectTimeout(Duration.ofSeconds(3))
        .setReadTimeout(Duration.ofSeconds(5))
        .defaultHeader("Accept", "application/json")
        .build();
}

OR

# Below properties are optional and used by RestTemplateBuilder, SO builder.build() ALONE IS ENOUGH INSTEAD OF ABOVE CODE !
# Set timeouts (in milliseconds), set a root URI for all requests, Set basic auth credentials
spring.rest.template.request-factory.connect-timeout=5000
spring.rest.template.request-factory.read-timeout=10000
spring.rest.template.root-uri=https://api.example.com
spring.rest.template.basic-auth.username=myuser
spring.rest.template.basic-auth.password=mypass


RestTemplate methods: - ("uri" string can have {orderId} path variable, pojo object itemObj here should minimum satisfy these requirements: A public no-arg constructor, all fields getters and setters, serializable fields)

Items[] items    = template.getForObject(uri, Items[].class, "1")  [Gets all items of order id 1]
URI itemLocation = template.postForLocation(uri, itemObj, "1") [Basically POST for 201 CREATED]
ResponseType ack = template.postForObject(uri, itemObj, ResponseType.class, "1") [Basically POST but gets and returns an acknowledgement response as java obj (from json/xml)]
ResponseType ack = template.patchForObject(uri, itemObj, ResponseType.class, "1") [similar to postForObject as above]
		   template.put(uri, itemObj, "1") [PUTs the item obj modified values for item with id "1"]
		   template.delete(uri, "1") [Deletes the given item]
HttpHeaders hdrs = template.headForHeaders(url, "1") [retrieves only the headers, no body.Check metadata like Content-Type, Content-Length]
Set<HttpMethod> allowedMethods = template.optionsForAllow(url, "1") [FOR GIVEN ENDPOINT, WHAT HttpMethod is allowed or not it fetches]

Same way as above, getForEntity() instead returns ResponseEntity<...>, basically same obj but inside ResponseEntity.
Use responseEntity.getBody() to get obj,  response.getHeaders.getxxx() to fetch header values, .getStatusCode() returns HttpStatus.OK / etc.

ResponseEntity<Void> response = restTemplate.exchange(request, Void.class);

To use above metod, you can create as follows the request obj:
RequestEntity<Item> request = RequestEntity.post(new URI(itemUrl))
					.getHeaders().add(HttpHeaders.AUTHORIZATION,
						"Basic "+base64EncodedLoginData)
					.contentType(MediaType.APPLICATION_JSON)
					.body(newItemObj);

Ideally WebClient is preferred in cases of Streaming , and may evolve compared to RestTemplate, which wont, but that DOESN'T mean IT's depreciated.

The trailing variable params, last param(s) end of each restTemplate method like getForObject, postForObject, etc, CAN TAKE STRING of that val,
OR the datatype meant to be used also (like Integer, or just the number as it will autobox), as the values to be substituted
in the uri's "/{id}" part. Actually any type with a proper .toString() implementation WILL WORK apparently!

For static rendering of resources in webapp, springboot looks in "classpath:static", basically static folder in resources folder,
BUT IT WILL LOOK FIRST IN src/main/webapp if such a path exists!

Spring boot also CONVENIENTLY MAPS "/" endpoint to the index.html which SHOULD BE IN main/resources/static OR main/resources/public folders.

RestTemplate methods THROW Exceptions IF STATUS CODE IS NOT 2xx.

assertThrows RETURNS THE EXCEPTION IT EXPECTS TO BE THROWN (and if it is thrown, else it throws its own ERROR - AssertionFailedError) :
HttpClientErrorException exp = assertThrows(HttpClientErrorException.class,()->{...});

Exception handling in Controller involves the @ExceptionHandler annotation, where if any controller method throws specified exception,
This method runs and that exception is a parameter to this. Eg:

@ResponseStatus(HttpStatus.CONFLICT) //Returns 409 status without the method to even return anything.
@ExceptionHandler({ DataIntegrityViolationException.class }) //This exception can occur if while saving to db some constraint is violated (like unique)
public void handleAlreadyExists(Exception ex){...}


Spring Boot Testing Framework (Built on top of Spring Testing Framework): - (spring-boot-starter-test dependency required (<scope> as test))

Eg of annotations: @SpringBootTest,@WebMvcTest,@WebFluxTest,@DataJpaTest,@DataJdbcTest,@JdbcTest,@DataMongoTest,@DataRedisTest
@MockBean annotation helps to mock specific bean.

Dependencies inside starter dependency: JUnit(5),SpringBootTest,SpringTest,AssertJ,Mockito,JSONassert,JsonPath,Hamcrest(library of matcher)

webEnviroment option in @SpringBootTest annotation can be set to RANDOM_PORT / DEFINED_PORT (server.port prop it finds it uses)
TO START WEB SERVER !
MOCK (default, NO REAL webserver started, only mocked using MockMvc) and NONE (no web env) are the other options

WARNING: Simply using @SpringBootTest (which itself is optional while using @Test methods) WILL NOT START THE EMBEDDED WEB SERVER/CONTAINER. Only app and app context will be ready.
	 You need to use this annotation to ensure it does start, or app is running in another terminal/etc :
	 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)


TestRestTemplate bean is always configured if SpringBootTest annotation is there.
Difference between this and RestTemplate is:
* It takes a relative path instead of mandatory absolute path
* Fault Tolerant: It does NOT throw an exception when an error response like 404 occurs from server.
* Configured to ignore cookies and redirects.

TestRestTemplate CAN ALSO BE MODIFIED by RestTemplateBuilder (autoconfigured in tests too, so can inject directly) as shown before.
Create a normal restTemplate USING BUILDER, and PASS IT TO CONSTRUCTOR. Eg: new TestRestTemplate(restTemplate)


Mvc test framework does NOT NEED to run web server container to test the controller endpoints!

For MOCK option value:
@SpringBootTest(webEnvironment = WebEnvironment.MOCK)
@AutoConfigureMockMvc //on test class these both should be used, can inject MockMvc bean directly

Code should be like: (mock server, not a real one)
     mockMvc.perform( get("/api/user/{id}" , "1").accept(MediaType.APPLICATION_JSON)) // Can use URI substitution like restTemplate methods
               .andExpect(status().isOk())                                 // Checks HTTP 200
               .andExpect(content().contentType(MediaType.APPLICATION_JSON)) // Checks response is JSON
               .andExpect(jsonPath("$.name").value("Alice"))              // Checks JSON field "name" is "Alice"
               .andExpect(header().string("X-Custom-Header", "value"));   // Checks custom header is present

// .perform() returns MockHttpServletRequestBuilder, which we can chain methods with like this.
// Required static imports for these is org.springboot.test.web.servlet.request.MockMvcResultBuilders.get; and xxx.request.MockMvcResultMatchers.status;

Other methods of MockMvc to chain from like get()/put()/post(), all INSIDE perform() as 1 parameter:

.param("id", "42")                      // Adds a query parameter ?id=42 to the request, instead can directly substitute in get() 2nd param too.
.requestAttr("userRole", "admin")      // Sets a request attribute accessible in the controller
.header("Authorization", "Bearer xyz") // Adds an HTTP header to the request
.content("{\"name\":\"Alice\"}")       // Sets the raw request body content (e.g., JSON payload)
.contentType(MediaType.APPLICATION_JSON) // Declares the format of the request body as JSON
.accept(MediaType.APPLICATION_JSON)    // Tells the server the client expects a JSON response
.locale(Locale.ENGLISH)                // Sets the request's locale (used for i18n or formatting)

Below static methods are to be used inside each .andExpect() as 1 parameter, which itself is chained to perform: (can chain .andExpect() with another, perform() only 1 should be there)

content().string("Hello World")                 // Asserts that the response body is exactly "Hello World"
header().string("Content-Type", "application/json") // Asserts that the response has a header Content-Type with value application/json
status().isOk()                                 // Asserts that the response status code is 200 OK
xpath("/user/name").string("Alice")            // Asserts that the XML response has <name>Alice</name> at the given XPath
jsonPath("$.user.name").value("Alice")         // Asserts that the JSON response has "user.name" equal to "Alice"


Difference between TestRestTemplate and MockMvc: TestRestTemplate DOES need startup of a REAL embedded SERVER using REAL http calls,
		   Whereas MockMvc does In-memory simulation via DispatcherServlet. MockMvc is ideal only for Controller Slice Tests, not exactly unit test or integration but inbetween somewhat.


.andDo(print())                      		   // Logs the full request and response details to the console for debugging
.andDo(result -> assertTrue(result.getResponse()
	.getContentAsString().contains("Alice"))) // Executes custom logic after the request, useful for advanced assertions or side effects

.andReturn()              // Eg: MvcResult r = perform(...).x.x.x.andReturn();  // Returns the MvcResult object so you can inspect the response manually (e.g., extract body, headers, status)

Note: Basically andDo lets you access MvcResult object (above eg. shows result variable) which you can use to inspect response/request,
      BUT if you wanted to stop for now and check in further lines, you can instead end the parent level chaining with .andReturn(); ,
      which will return MvcResult obj. In later lines, you can do SAME THING YOU COULD'VE DONE INSIDE andDo() example as above!


@WebMvcTest(MyController.class)       // Web slice testing: loads only web layer (controllers, filters, etc.) for fast controller testing

Disables FULL autoconfiguration and instead apply ONLY configuration relevant to MVC tests OF GIVEN CONTROLLER CLASS.
(aka controllers, filters, exception handlers, and related config & beans OF Controller.class you pass as param to the annotation!)

MockMvc bean (as seen before) is autoconfigured, and optionally Spring Security too.

@MockBean is used to mock & inject any other beans you will need which ISNT part of the mvc like service class beans etc.

given(userService.getUserName(1L)).willReturn("Alice"); // When getUserName(1L) is called, return "Alice"
verify(userService).getUserName(1L);			// Verifies that getUserName(1L) was called once, can have another verify() parameter where you can give times(2) or atMost(3) or never(), etc.

Warning: @Mock from Mockito creates a bean which is NOT PRESENT OR MANAGED IN SPRINGBOOT CONTEXT. Like inside controller,
if i injected a bean i want to mock there, by executing controller method in test I CANT CHANGE THAT INJECTION, so @MockBean springboot annotation is needed.


@DataJpaTest                          // Repository slice: loads JPA repositories and related config for testing database access

Loads @Repository beans, excludes all other @Components. Autoconfigures TestEntityManager, an alternative to EntityManager (for helper methods alone for entity management during testing like persistAndFlush() or persistFlushFind())

@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) //Used on test class to say basically: "use configured db in properties file". IF YOU OMIT THIS ANNOTATION OR just use .ANY option instead, it will assume you want a lightweight IN-MEMORY db for testing purposes.


@CacheTest                    // Caching slice: loads only caching-related beans to test cache behavior and configuration (like CacheManager)





---------------------------------------------------
==================================================

NOTES: -
* Springboot scans and takes default/no param constructor if multiple are there, one is there means it takes that constructor. Else it raises error.

* Mix and matching field and constructor injection in a component is fine,  but remember that in test if I create by constructor,
  Now field injection ALONE WILL BE NULL, and if you forget this fact, youll keep testing how all others aren't null except that obj.

* Usually SpringApplication.run() will have the Configuration file it uses, now any AspectConfig or something you have to add means, just Import AspectConfig into that main config.

* WARNING ABOUT ASPECT (AOP): If Spring proxy-based AOP	is used, then Injecting bean from Spring only will work as expected with aspects, NOT with objects created with "new" keyword. (You already know this)
  I thought It was malfunctioning, BUT I TESTED AND IT's right, see below output and observe how if new is used t create the class obj whose method should be observed by aspect, then no it wont work.

RewardNetworkImpl.rewardAccountFor() was called & Started
Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!
THE SECTION OF CHANGE IS OVER
THIS is the test where RewardNetwork bean was autoinjected/initialized, so spring managed RandomClass.

RewardNetworkImpl.rewardAccountFor() was called & Started
RandomClass.randomMethod() was called!
THE SECTION OF CHANGE IS OVER
This is the test with OBJ manually created using new and initalized by constructor.
-----------------------------

* I EXECUTED AND VERIFIED THAT : NO, ITS NOT MANDATORY TO IMPORT ALL CONFIG FILES TO THE MAIN CONFIG FILE (which you use for SpringApplication.run()).
  				 Instead, ensure in the @ComponentScan (Can be in main config or imported config, 2 annotations are just additive, so no issues if you see double),
				 That you add the package where config java files are there additionally to be scanned (INCASE IT ALREADY ISNT covered). Eg: @ComponentScan(basePackages = {"rewards.internal","config"})
				 Then you will see even without @Import(AspectConfig.class), functionality works as expected AS LONG AS config file is in package(s) mentioned in ComponentScan, AND @Configuration annotation is on it.

----------------------------------------------------------------------

* I TESTED if RandomSubClass obj executing its parent's method also triggers aspect, and see if overrided that method, that has an effect. (by mixing datatypes ofcourse.)

YES, I injected RandomSubClass obj then used it to access it's superclass method randomMethod() directly, ASPECT TRIGGER WORKED JUST LIKE AS IF I INJECTED AND RAN USING RandomClass obj!
(Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!)

Then I ensured I OVERRIDED THE RandomClass method with RandomSubClass version of the method, IT STILL TRIGGERED THE ASPECT!
I even tried removing @Component from RandomClass incase, and FIRST TRIED Injection points as RandomClass, it works same! THEN TRIED WITH RandomSubClass as type expected at injection, STILL WORKS!
Similarly I tried making RandomClass as interface, SAME WAY IT WORKS, SUBCLASS METHOD TRIGGERS THE ASPECT!

(Aspect triggered before randomMethod!
RandomSubClass.randomMethod() was called!)

BUT THERE IS ONE CRITERIA WHERE ASPECT ISNT EXECUTED. IF the randomMethod declaration is REMOVED FROM THE SUPERCLASS (for interface its impossible obviously), AND ONLY IN SUBCLASS YOU HAVE THAT METHOD (Injection points expect RandomSubClass as then only it will compile since randomClass.randomMethod() WONT BE AVAILABLE IN THIS SITUATION AS WE REMOVED IT), Then FINALLY,
ASPECT DOES NOT RUN!!! This shows as long as superclass or interface has the method, then its all fine, even if you override it in subclass, aspect filter will catch it. See below output:

RewardNetworkImpl.rewardAccountFor() was called & Started
RandomSubClass.randomMethod() was called!
THE SECTION OF CHANGE IS OVER
THIS is the test where RewardNetwork bean was autoinjected/initialized, so spring managed RandomClass.


The aspect PointCut expression used for above is: @Before("execution(void rewards.internal.RandomClass.*(..))").
And OBVIOUSLY creating new Object in these cases, Aspect WONT WORK/TRIGGER.


Second part, i tried Experimenting with annotation specifications also, like @Before("execution(@java.lang.Deprecated void rewards.internal.RandomClass.*(..))") with same classes.
After annotating @Deprecated on method in RandomClass, and INJECTION POINTS ARE OF RandomClass, ASPECT IS TRIGGERED.

But while trying REMOVING @Component on RandomClass, and forcing it to inject RandomSubClass to RandomClass injection points, IT DOESNT RUN ASPECT! (It has overrided method)
Injection points were kept as RandomClass, then RandomSubClass, still NO LUCK!!!

BUT if RandomSubClass BODY IS EMPTY COMPLETELY, THEN NO METHOD IN SUBCLASS TO OVERRIDE, and IT WORKS AGAIN!

RewardNetworkImpl.rewardAccountFor() was called & Started
Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!


RewardNetworkImpl.rewardAccountFor() was called & Started
RandomSubClass.randomMethod() was called!
THE SECTION OF CHANGE IS OVER


MORAL OF THE STORY: Normally, subclass methods whther overriding or not, as long as the superclass/interface declares same signature method, THEN IT WILL TRIGGER ASPECT HOWEVER YOU INJECT IT!

BUT IF YOU HAVE SPECIFIED ANNOTATION in the filter PointCut of the aspect, THEN BEHAVIOUR IS CHANGING. EVEN IF YOU USE SUBCLASS OBJECT, If subclass object injected, is used to
ACCESSING THE SUPER CLASS METHOD (SubClass doesnt have that method), THEN IT WORKS SAME!
BUT IF YOU OVERRIDE THE METHOD IN SUBCLASS, THEN ASPECT ISNT TRIGGERED IF YOU INJECT THE SUBCLASS OBJECT! (Regardless of injection point type) In this annotation specified CASE ALONE!

-----------------------------------------------------------------------------
For Aspect triggering regarding bean internal method calls to its own other methods...(Assuming methods a() and b() both match some aspect PointCut conditions)

If I do intentional separate calls in code, then clearly aspect is triggered:
Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!
RandomClass.randomMethod2() was called!
Aspect triggered after randomMethod! : RandomClassmethod2
THE SECTION OF CHANGE IS OVER: DUMMY
Aspect triggered before randomMethod!
RandomClass.randomMethod2() was called!
Aspect triggered after randomMethod! : RandomClassmethod2
THE 2nd SECTION OF CHANGE IS OVER: DUMMY


But if I do "return randomMethod2();" inside randomMethod(), then see output where Aspect WAS NOT TRIGGERED because now the internal calls after aspect triggering ARE HAPPENING ON THE REAL BEAN ITSELF!

Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!
RandomClass.randomMethod2() was called!
Aspect triggered after randomMethod! : RandomClassmethod2
THE SECTION OF CHANGE IS OVER: DUMMY


But if I attempt to call ANOTHER BEAN's (RandomSubClass in this case) method internally of that original method call body, THEN IF ASPECT filter is matched then YES IT WILL BE TRIGGERED AS USUAL! So as expected, nested way of Aspect triggering and ending happens (as I use @Around method with more proper labelled output dynamically using PointJoinPoint methods to print function and bean names)

Aspect triggered before rewards.internal.RandomClass@9e2ad91.randomMethod!
RandomClass.randomMethod() was called!
RandomClass.randomMethod2() was called!
Aspect triggered before rewards.internal.RandomSubClass@1aa6e3c0.randomMethod!
RandomSubClass.randomMethod() was called!
Aspect triggered after rewards.internal.RandomSubClass@1aa6e3c0.randomMethod! : Subclass
Aspect triggered after rewards.internal.RandomClass@9e2ad91.randomMethod! : DUMMY
THE SECTION OF CHANGE IS OVER: DUMMY


-------------------------------------------------------------------------------------------

HOW TO EXECUTE: I moved to lab folder in cmd and usually to run tests alone I used: mvn test -pl 22-aop
BUT FOR ASPECT TESTING, the LOGGER STATEMENT WERE MISSING, I SEARCHED FOR CODE ISSUES and all,

FINALLY PROBLEM WAS HOW I EXECUTED UNIT TEST OF 1 Test ALONE : mvn -pl 22-aop -Dtest=LoggingAspectTests test [THIS WORKS!!!]

Also, anything wrong with JoinPoint expression (like @Before("execution(* *(..))") IS NOT CORRECT) , it will THROW EXCEPTION AS IF beanInitialization failed for the Aspect class.
SO ENSURE TO CHECK IT's correct or not.
