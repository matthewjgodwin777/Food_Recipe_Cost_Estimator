repository are automatically a bean if extends JpaRepository<...> or CrudReposity<...> , etc.
One constructor in class (including lombok) means no need @Autowired, private or access modifier doesnt affect injection or IoC.

ResponseEntity.ok(...) or created(...) when you pass a parameter to it, it's basically like constructing ResponseEntity.status(...).header(HttpHeaders.LOCATION, "/cashcards/1").build(); and the value is obtained using response.getHeaders().getLocation() , which will be a URI.

URI location = URI.create("/cashcards/1");

return ResponseEntity.created(location).body(resource); // build() is not required if body() is used
[OR]
return ResponseEntity
    .status(HttpStatus.CREATED)
    .header(HttpHeaders.LOCATION, location.toString())
    .body(resource);

 UriComponentsBuilder as parameter to post function in controller correctly got injected by IoC just like that.
---------------------
URI locationOfNewCashCard = ucb
                    .path("cashcards/{id}")
                    .buildAndExpand(savedCashCard.id())
                    .toUri();

Another way of sending back the path as URI in the ResponseEntity.created(locationOfNewCashCard).build();

Atleast in CrudRepository internal db, YOU CANNOT give Id field when creating an object using POST endpoint when it saves using repository.save() ;

CREATE TABLE cash_card
(
    ID     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    AMOUNT NUMBER NOT NULL DEFAULT 0
);

Regardless of H2 or postgres, ofcourse if this CREATE TABLE script is either used or generated, it will ofcourse use generated value if id field is null, else it uses provided value.
------------------
@Table("cash_card")
public record Card(@Id Long id, Double amount) {}
------------------
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.datasource.url=jdbc:postgresql://localhost:5432/yourdb
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.username=youruser
spring.datasource.password=yourpass
------------------

incase there are 2 constructors in a class type (records must always have only 1 constructor with all fields), then if the type is converted from a json,
like @RequestBody is used to do so, then apparently acc to AI, it will choose depending on what fields json has and choose constructors. (not sure)

Page<CashCard> page2 = cashCardRepository.findAll(
    PageRequest.of(
        1,  // page index for the second page - indexing starts at 0
        10, // page size (the last page might have fewer items)
        Sort.by(new Sort.Order(Sort.Direction.DESC, "amount"))
    )
);

Pageable pageable is a variable that can be injected magically in a constructor function which takes the size and page query parameters in request.
Otherwise, if one of these or both isnt given, Spring provides defaults: page=0, size=20.

pageable.getPageNumber(),
pageable.getPageSize(),
pageable.getSortOr(Sort.by(Sort.Direction.DESC, "amount"))));  //Yep this is correct , either uses given in url else the default specified here.

///Example queries which will be given to Pageable obj in controller func: cashcards?page=1&size=3&sort=amount,desc
(The comma cannot have spaces before and after...)

@DiryContext on a method and @DirtiesContext(classMode = ClassMode.AFTER_EACH_TEST_METHOD) on the test class can help to clean the data after each test if it makes a permanent change
(like if a card is added in a test for next test it can be undone)

Additional for paging support you need to extend this repository:
interface CashCardRepository extends CrudRepository<CashCard, Long>, PagingAndSortingRepository<CashCard, Long> { ... }


Spring Security (works via Role-Based Access Control (RBAC) , which is self explainatory): Token types, Bearer token authentication, CSRF token (Cross-Site Request Forgery token)

Filter Chain in springboot helps to define methods to be executed before controllers to ensure the requests are authenticated, else send back 401 UNAUTHORIZED.

@CrossOrigin - used to specify the urls to allow cross origin requests and if args not give, it ALLOWS ALL ORIGINS!

Cross-Site Request Forgery - involves cookie token to be used and sent trying to impersonate, therefore a specially dedicated CSRF token generated is recommended.
Cross-Site Scripting - Similar to SQL injection attacks, if the script or something goes in the raw form , and due to poor programming practices its not cleaned and used somewhere,
If say js code chunk is not cleaned and directly rendered in a webpage, unwanted scripts can be executed. Properly data should be escaped accordingly and no loop holes.

----------------------------
Principal principal in controller is a method argument, provided automatically by Spring Security.
Same as Paegable

Spring security always returns 403 forbidden if that mapping/suburl doesnt exist so it doesnt reveal by mistake any useful info.
delete (Atleast in CRUD repository)

Note: Have to explore how repository interface we just type method name and it correctly does the queries behind the scenes.






---------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Spring Framework Essentials : -


ApplicationContext context = SpringApplication.run(ApplicationConfig.class);

TransferService service = context.getBean("transferService" , TransferService.class); // one of the parameter is enough too
// only first param means RETURN TYPE WILL BE OF TYPE Object (just typecast thats all) , only with 2nd param it gives directly correct type.
   And also, the class name of the bean just make FIRST LETTER LOWERCASE, that WILL BE THE BEAN NAME TO SUPPLY as FIRST PARAM.

// If there is no other beans returning that type or being that type, then 2nd param ALONE CAN BE ENOUGH.


@Configuration
@Import({ApplicationConfig.class, WebConfig.class}) // To not repeat config classes, basically extending config classes so common stuff is shared.
public class TestInfraConfig {
@Bean // Can also be @Bean(name="dataSource") incase method name had to be different
public TransferService transferService(AccountRepository){
		return new TransferServiceImpl(repository);
	}
}


If TransferServiceImpl is annotated as some bean annotation, then since no other type other than this extends TransferService,
Spring automatically will inject this where TransferService interface type is used.
If multiple contenders, then @Qualifier should be used on the one you want it to be injected with.

Incase there is cyclic dependency and cant be resolved design wise, then use @Lazy like:

public Constructor(@Lazy Service2 s, ...){} // This will atleast break cycle delaying the MANDATORY req that Service2 is to be injected immediately.
							  // It will basically not fully initalize properly and then after that will inject this bean.


Bean Scopes: -

@Scope("singleton") - Only once instance is created

Issues when it maintains any state/mutable type. Then THREADSAFE stuff should be done.(syncronizing etc)
Better only use for immutable or stateless beans.


@Scope("prototype") - Everytime it's referenced, a new instance is created.

Like context.getBean() if you use to get bean twice, THEN TWO NEW INSTANCES CREATED!
But in springBOOT, difference is: 
  EVERY PLACE where its annotated explicitly or implicitly to Inject, each time new instance is injected.
  Like if it's supposed to be injected "magically", then its a new one injected for sure.


@Scope("session") - Instance is created once PER USER SESSION (Web environment ONLY)
@Scope("request") - Instance is created once PER Request (Web environment ONLY)

Web Socket Scope, Refresh Scope, Thread Scope (this one maybe not native) , or even custom scopes rarely are used and exist.


A bean should be named like accountRepository , and should return only the interface type (AccountRepository),
Not the implementation class's type, by polymorphism return ofc. Its a standard.


@Bean
public DataSource dataSource(Environment env) //Is a bean an easily injected like other beans.
{
	BasicDataSource ds = new BasicDataSource();
	ds.setDriverClassName(env.getProperty("db.driver")); //Takes from application.properties or somme other prop. file
	...
}

The env.getProperty("key") is used to get value from these below sources (DESCENDING ORDER of precedence):

JVM system properties (System.setProperty)
OS environment variables
Config files (application.properties, application.yml)
(Not sure: .properties overrides .yml if both have same key;
Profile-specific files (e.g., application-dev.properties) overrides the general application.properties)
Any custom property sources registered via annotations or code

Among same precedence property files, if specified like below 3 ways,
THE LATER FILE OVERRIDES the LEFT FILES! : -

@PropertySource({"classpath:fileA.properties", "classpath:fileB.properties"})
OR
@PropertySource("classpath:fileA.properties")
@PropertySource("classpath:fileB.properties")
OR
spring.config.additional-location=classpath:/fileA.properties,classpath:/fileB.properties

[ CAN ALSO USE "file:..." or "http:..." prefixes to get the property files using absolute/relative path.
classpath: is used like classpath:/com/sagent/daradefault/resources/application.properties , file: is as expected.
IF you dont use these 3 prefixes and mention @PropertySource("application.properties") or so,
It NON RECURSIVELY searches in classpath folders like src/main/resources/cloud.properties for it,
AS IT TAKES IT AS RELATIVE PATH TO CLASSPATH's resource folder]

Can check order too: 
((AbstractEnvironment) env).getPropertySources() gives the order of loading the property files in descending order of precedence.


Alternate to using env.getProperty(), use: -
@Value("${db.driver}")


Profiles: -
Actually Beans belong or not belong to profiles,
Like DataSource bean can be many but dev has one, and production uses another bean similar though.
So profile just categorizes beans (and usual beans is common to all).

@Profile("cloud") - CAN BE USED ON ANY BEAN so the bean is only available in context IF ITS IN THAT MENTIONED PROFILE!
@Profile("!cloud") - Means initialized when profile IS NOT "cloud"

Also, if you wanted say 2 DataSource beans in same class, one for cloud and one for local profiles,
function names can be different, so BEAN NAME WILL ALSO CHANGE RIGHT sicne overloading not possible? (same method signature)
So to EXPLICITLY mention Bean(name="dataSource") for both.


Ways to activate profile(s): (YES, CAN ACTIVATE MULTIPLE)
-Dspring.profiles.active=embedded,jpa
OR
System.setProperty("spring.profiles.active","embedded,jpa");
(SpringApplication.run(AppConfig.class) is THEN ONLY RUN)
OR for Integration testing: @ActiveProfiles annotation is used (later we will see)


Using @Profile("cloud")
	@PropertySource("cloud.properties")
on a configuration class means NOT ONLY that configuration will only have beans initialized in that particular profiles,
ONLY IN THE PARTICULAR PROFILE(S) THE PROPERTY SOURCE MENTIONED ALSO IS INCLUDED!!! (yes it has influence on fellow annotation)


Fun fact: Most annotations the order applied on same thing usually doesnt matter, especially class annotations never at all,
Maybe exceptions like : method-level annotations in JUnit 4, or when using annotation processors that care about orde



Spring Expression Language : -

@Value("#{ systemProperties[user.region] }")
//Can annotate this on a class field OR EVEN A METHOD PARAM too.

To fetch a field value, the main obj has to be a bean to be access by SEL.


TRICKY WEIRD NAMING BEHAVIOUR WARNING : -
class StrategyBean{
private KeyGenerator gen = new KeyGenerator.getInstance("Blowfish");
public KeyGenerator getKeyGenerator(){return gen;};
}

@Configuration
class StrategyConfig {
@Bean public StrategyBean strategyBean(){
return new StrategyBean();
}
}

If used on class field, the property name "keyGenerator" is used DESPITE THE METHOD NAME OR VARIABLE NAME IN StrategyBean NOT MATCHING.

@Value("#{strategyBean.keyGenerator}")
KeyGenerator kgen;

Reason is, first you specify the bean (aka StrategyBean, which is declared in StrategyConfig as a method,
You DONT have to always declare StrategyBean as a @Bean on the class declaration itself. Instead a method generating the object is in Config class, thats enough).

Now if you try using ".keyGenerator" asking the bean using SEL, it will FIRST:
search for a accessible getter method with proper naming convention, aka here its "getKeyGenerator()"
THEN IF IT FAILS TO, then searches for AN ACCESSIBLE FIELD IN THE Bean's class with EXACT SAME NAME,
aka field in StrategyBean class called keyGenerator is searched for, but since getter is there, field name being different is ok.

REMEMBER, THE GETTER OR FIELD (Whichever is gonna be taken) HAS TO HAVE GOOD ACCESS SPECIFIER. (Obviously not private access level)
Like, if @Value("#{...}") is done in another class which is IN SAME PACKAGE as StrategyBean,
THEN default access/package-private access to the getter or variable IS ENOUGH! OR ELSE INJECTION WILL FAIL AT RUNTIME!!!


@Value("${daily.limit}") IS EQUIVALENT TO @Value("#{environment['daily.limit']}")   [$ symbol is for getting property/env value, # can have expressions]

And YES, @Value("#{new Integer(environment['daily.limit']) * 2}") IS PERFECTLY FINE!

Just remember to have valid usage of the value from environment AS IT IS A STRING,
IT HAS TO BE CONVERTED TO BE USED AS INTEGER, etc. , IF NEEDED THAT IS.


@Value("${daily.limit : 100000}") IS EQUIVALENT TO @Value("#{environment['daily.limit'] ?: 100000}")
The ':' operator in ${...} and '?:' operator in #{...} BASICALLY DOES THE SAME THING EQUIVALENTLY.
They are " IS NOT NULL, ELSE " operator. Basically they help specify DEFAULT VALUES INCASE property is null.


REMEMBER: @Autowired is STILL REQUIRED even if all paramters of constructor is annotated with @Value, like ofcourse if only 1 constructor is there,
THen no need of autowired because IMPLCITLY its assumed. But generally Autowired is implcitly or explicitly needed at minimum to ATLEAST INDICATE
WHICH CONSTRUCTOR TO USE.

spEL can do this and all, whereas EL is more basic: 
@Value("#{T(java.lang.Math).random() * 100}")


Annotation-based Configuration: -
@Component if you annotate on a class,
If you annotate @ComponentScan("com.package") on the CONFIG class,
It will search the (sub)package(s) specified and whichever classes have this @Component it will take as Bean adding to application context.
(If no package/argument given, just @ComponentScan, it takes the config class's package and scans inside that for beans ALONE. (its bad if package is only for config))


3 Types of injections: (Ensure NVER to create object of such a class using new keyword, or else everything expected to be injected will be null)
* Constructor injection (only needs @Autowired if 2 resultant constructors are there, and injects dependency into only paramterized constructor params ofcourse)
* Method injection (same way as constructor, but @Autowired(required=false) can be done if ITS OK for dependency bean not to exist to be available for injection)
* Field injection (directly injects into obj's class's fields if annotated, even if private variable (but bad for unit testing).)

Setter injection preferred only maybe if circular dependency should be resolved, (@Lazy can help too, but it wont let circular dep. beans to be initialized UNTIL ITS ACCESSED)
Constructor injection doesnt let that happen, atleast easily. setters will get injected after constructors, so by then objects are created,
WHY WILL SPRING CARE ABOUT CIRCULAR DEPENDENCIES WHEN NOW IT CAN FREELY INJECT using setters since all are created by then...got it? so thats one senario setter injections are helpful.

In method injection, Optional<...> IS ALSO ALLOWED TO BE INJECTED, as IT WILL UNDERSTAND THAT BEAN IS TO BE INJECTED IN OPTIONAL FORM!!!, like below line:
@Autowired public void setAccountService(Optional<AccountService> accountService){...}

@Qualifier: -
public TransferServiceImpl(@Qualifier("jdbcAccountRepository") AccountRepository accountRepository){} // Qualifier takes the bean name, not class name.
Above code ensures to disambiguate which bean to inject IF THERE EXISTS 2 CLASSES WITH @Component annotation EXTENDING AccountRepository.
YOU HAVE TO ANNOTATE @Qualifier(...) on the literal parameter or field itself, not on method or class.


Finally it couldnt find EXACTLY 1 bean by type or @Qualifier isnt an option, IT CHECKS THE VARIABLE NAME (like "accountRepository" above, takes the variable name as last resort.)

@Lazy should ONLY be used as worst case senario if the Bean REALLY wont be able to be created during startup while other beans are eagarly created immediately.
@Component("beanName") can also be used to give different name for bean name.
@Lazy(true) and @Lazy is same, only @Lazy(false) means its not lazy initialized.


Autowiring Constructors: -
Default constructor or only one constructor is there means @Autowired isnt necessary.
Even if more than one constructor is there, if there is ZERO-ARGUMENT CONSTRUCTOR DEFINED IT USES THAT.
ELSE, THEN @Autowired IS MANDATORY ON ONE OF THE CONSTRUCTORS.

Vaguely mentioning @ComponentScan({"org","com"}) is TERRIBLE PRACTICE as too many components wil be searched for (EVEN IN JAR DEPENDENCIES)
Best specify very accurately like "com.bank.app.repository", etc.

(Can do java configurations to avoid spring annotations directly sometimes (if you want to decouple spring directly from main code) BUT NOT ALWAYS POSSIBLE)

Startup and Shutdown behaviours: -
@PostConstruct() - If annotated on a method, AFTER CONSTRUCTOR AND SETTER INJECTIONS ARE DONE in the class, THEN it's executed (incase it needs those objects injected first).
@PreDestroy() - If (ConfigurableApplicationContext is the type) context.close() or basically context is being closed/ended NORMALLY!, (not if it died or was killed)
		    All methods with this annotation will be executed in all the bean classes,
		    EXCEPT Beans SCOPED WITH "prototype", AS ANYWAYS NEW BEAN IS CREATED EVERYTIME it has to be injected at some place.

Incase for some reason you cant or dont want to annotate inside the class , you can specify such methods in @Bean itself! : -
@Bean(initMethod="populateCache", destroyMethod="flushCache")

ConfigurableApplicationContext registers a shutdownHook in JVM, so any graceful shutdown way like System.exit() or Runtime.exit() can trigger context to run PreDestroy methods.


Stereotype & Meta Annotations: -
@Service, @Repository, @Configuration, @Controller, @RestController are basically @Component extended annotations with stereotypes associated with them (like additional properties).

YES YOU CAN CREATE A META ANNOTATION YOURSELF. Eg: @MyTransactionalService if you want to annotate on a class,

import java.lang.annotation.*;

@Target(ElementType.TYPE) // Where it can be used (.METHOD, .FIELD, etc., here TYPE means 4 things it can be used on: class, interface, enum, annotation type)
@Retention(RetentionPolicy.RUNTIME) // Available at runtime (most used), sometimes can use .CLASS (available in .class fiels but not runtime, eg: For frameworks which will see the annotation in compiled classes), or .SOURCE (just in typed source code alone, eg: for just documentation)

public @interface MyAnnotation { } // Marker annotation, no members, @interface is similar to defining an interface, but it’s specifically for annotations.

[OR]

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Service // Makes the class a Spring service bean
@Transactional(timeout=60) // Makes all methods transactional with 60s time limit
public @interface MyAnnotation {     
    String description() default ""; // To have variables in annotation to specify, defauly values can be given.
    int order() default 0;
}

Below code/function is called for EVERY Bean, and incase it DOES HAVE THAT ANNOTATION, if condition below is executed, and stuff happens. This is how custom annoations can be useful.

@Component // Registers this processor as a Spring bean
public class MyAnnotationProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        // Check if the bean's class has your custom annotation
        MyAnnotation annotation = bean.getClass().getAnnotation(MyAnnotation.class);
        if (annotation != null) {
            System.out.println("Bean '" + beanName + "' has MyAnnotation:");
            System.out.println("  Description: " + annotation.description());
            System.out.println("  Order: " + annotation.order());
        }
        return bean;
    }
}


---------------------------------
Unrelated : -
javadocs basically can help tools to scan code and create html document with details of the classes.
@param — describes a method parameter
@return — describes the return value
@throws or @exception — describes exceptions thrown
@see — refers to related classes or methods
@author, @version — author and version info
Eg: 
/**
     * Creates a new customer.
     * @param name the customer's name
     * @param age the customer's age
     */
    public Customer(String name, int age) {
        this.name = name;
        this.age = age;
    }

    /**
     * Gets the customer's name.
     * @return the name
     */
    public String getName() {
        return name;
    }
}
---------------------------------


Bean LifeCycle Phases: Initializing, Usage, Destruction.


Spring Bean Lifecycle (in order):

1. Load & Process Bean Definitions

@Configuration classes processed
@Component classes scanned
Bean definitions added to BeanFactory (ApplicationContext extends BeanFactory)

2. BeanFactoryPostProcessor Phase

All BeanFactoryPostProcessor beans run (can modify bean definitions before beans are created)
public class BeanFactoryPostProcessorImpl implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableBeanFactory beanFactory) {
        // custom logic to modify bean definitions
    }
}

3. Bean Creation

Dependencies resolved
Beans instantiated (constructor, then setter/field injection, )
If @Lazy, bean is created only when needed

4. BeanPostProcessor Phase (instance-level)

All BeanPostProcessor beans run for each bean:

* postProcessBeforeInitialization(bean, beanName)

* Bean init methods:
	init-method (if configured)
	@PostConstruct method
	@Resource injection (both enabled by CommonAnnotationBeanPostProcessor)

* postProcessAfterInitialization(bean, beanName)


public interface BeanPostProcessor { //has to be implemented and that impl class has to be @Component
    Object postProcessBeforeInitialization(Object bean, String beanName);
    Object postProcessAfterInitialization(Object bean, String beanName);
}


5. Bean Usage

Beans are ready for use in the application

6. Bean Destruction

When context closes:
@PreDestroy method
destroy-method (if configured)


----------------------
NOTES: -

Static @Bean methods:
Use for beans that must be created before any other beans (e.g., custom BeanFactoryPostProcessor).
Eg: @Bean
    public static BeanFactoryPostProcessor myConfigurer() { ... }


PropertySourcesPlaceholderConfigurer

Spring 4.3+: auto-configured for value resolution
Older Spring: must configure manually


Java Config      : Read all @Bean annotated method signatures | BeanFactoryPostProcessor | Call @Bean method implementations | BeanPostProcessor
VS
Annotation Config: @Component Scanning | BeanFactoryPostProcessor | Instantiation (@Autowired constructor, then injection into @Autowired methods, fields) | BeanPostProcessor

----------------------

Usage Phase : -

If Bean already in context normally and required as a raw Object, its retrieved just like that if required.

But if a proxy is required like in the case of Transations, Security, Exceptions, etc.,
Then the Bean method/class isnt DIRECTLY used to supply a Bean.
It has a middleman like proxy between actual impl. bean and the caller/requirer.

This proxy creation is usually done in the BeanPostProcessor using the method: public Object postProcessAfterInitialization(Object,String)
This method WILL RETURN A PROXY OF THE OBJECT SUPPLIED IF REQUIRED by our logic.


Spring Boot: Proxy Beans Cheat Sheet

What is a Proxy Bean?

A proxy bean is a wrapper around your actual bean.
Spring uses proxies to add features like AOP (logging, transactions, security) without changing your code.
When you use annotations like @Transactional, @Async, @Cacheable, or AOP advices, Spring wraps your bean in a proxy.
The proxy intercepts method calls and adds extra behavior before/after/instead of your method.

Types of Proxies:

JDK Proxy (Inbuilt in JDK, also called dynamic proxies):
Used if your bean implements an interface.
Proxy implements the same interfaces as impl bean.

CGLIB Proxy (Spring jars have this):
Used if your bean does not implement an interface and/or if injection point directly has impl class type required.
Proxy subclasses your bean.
Cannot be applied for final classes or methods.

Example:
When you inject MyService, Spring actually gives you a proxy object.
When you call doSomething(), the proxy starts a transaction, calls your method, then commits/rolls back.
(SpringTransactionInterceptor intercepts and TransactionManager handles rollbacks/commits ofcourse)

How to See a Proxy Bean?
Print the bean’s class:
The class name will show CGLIB or Proxy in it.

System.out.println(myService.getClass());
// Output: class com.example.MyService$$EnhancerBySpringCGLIB$$...

Limitations:

Only public methods are proxied.
Self-invocation (calling another method in the same bean) does not go through the proxy.
Final methods/classes cannot be proxied by CGLIB.

Why Use Proxies? :
Add cross-cutting concerns (transactions, security, logging) transparently.
Decouple business logic from infrastructure concerns.
--------------------------------------------------------------------------

Destruction Phase: -

ConfigurableApplicationContext context = //Get it from somewhere ;
context.close(); 
//will close context and trigger this phase

Any @PreDestroy (or destroy-method) method of Beans are invoked, then beans are released, and Garbage Collector will destroy them.

IMPORTANT: THIS DESTRUCTION PHASE ITSELF DOES NOT APPLY TO "prototype" scoped beans ALONE, EVERY SINGLE OTHER SCOPED Beans,
	   SPRING WILL MANAGE THEIR LIFECYCLE FULLY, but for prototype scoped beans, IT CREATES AND SIMPLY HANDS OVER FULL RESPONSIBILITY (to deallocate/destroy/etc) TO YOU.
	   Rest of the instantiation and usage (including proxy behaviour) all is SAME FOR prototype beans.

WILL NOT DO THIS PHASE IF APP ISNT SHUT DOWN GRACEFULLY, like killed or terminated.

---------

@DependsOn("beanName") on a bean (class) definition is JUST AN EXPLICIT way to say what Bean dependencies this class needs. (NO need for spring actually, but its just explicit simply)

2 Different Configuration types:

Java config: Takes bean name from method name, or name/value attribute. Type is taken from method return type.
Annotation-based Config: From Annotation value attr (we can give name as param @Bean(name="sampleBean")), Type is the class type.

One main difference is Java config typically RETURNS INTERFACE TYPE as method return type, NOT implementation class type.
But Annotation-based Config ALWAYS RETURNS THE EXACT Impl class TYPE as it has no choice since impl class is the one annotated.


Best Practices:
* Best for bean methods to return INTERFACE TYPES EXCEPT where multiple interfaces exist,
  and BOTH types WILL BE NEEDED for INJECTION. Then think about it, assume X implements A,B ,
  means if both A and B are expected to be injected somewhere, then 2 Bean methods or something has to be declared,
  Unless then alone you HAVE TO RETURN IMPL. TYPE INSTEAD so this 1 bean method alone will suffice for A and B injection places.

* Still for the "to be injected" spots, LET INTERFACE TYPES BE THERE to be injected.
  (Incase bean was proxied (Actual class name itself might be different) or different implementation object was returned as Bean in further development, IT WILL NOT COMPILE right)


--------------------------------------
AOP: -
Aspect-Oriented Programming is sort of a set of best practices, which enables modularization (module=class in java) of cross-cutting concerns.
Example: below concerns should ideally be as one modular class instead of being done FOR EVERY SINGLE CLASS/METHOD (or in many basically):
Logging & Tracing, Transaction Management, Security, Caching, Error Handling, Performance Monitoring, Custom Business Rules.


Without Cross Cutting Concerns, it leads to 2 problems:
* Code tangling (basically tightly coupled code with overlayed concepts like security, error handling, etc)
* Code Scattering (Exact same concern with duplicated code in several methods / classes)

Example:
if(!hasPermission(SecurityContext.getPrincipal())){throw new AccessDeniedException();}
This code could be added to several controller or service methods and UNNECESSARY duplication occurs with TIGHT COUPLING SECURITY WITH APP LOGIC.

2 APO Technologies:
AspectJ :
* Original AOP Technology (first version in 1995)
* Uses bytecode modification for aspect weaving
* A full blown AOP language

Spring AOP (focus of this session) :
* Java-based AOP framework with AspectJ integration.
* Focuses on using AOP to solve enterprise problems.

Spring AOP concepts in true layman's terms:

Join Point:
A spot in your code where something can happen (like calling a method, or exception might be thrown there).

PointCut:
An expression (filter) that says "only do something if methods matching this pattern of methodname does this specified action (eg: execution of method)."

Advice:
The lines of code to execute based on Pointcut (filter). (like logging, checking, or changing).

Aspect:
PointCut + Advice encapsulated in 1 module/class (like pair(s) of these 2 inside a class meant for AOP, that class can be called an Aspect).

Weaving:
The act of mixing your aspects are mixed into your regular code at the right spots.


AOP Proxy: An "enhanced" class that stands in place of original, having extra behaviour of aspects WOVEN INTO IT!
(Usually uses CGLIB or in interface cases and final class beans, JDK dynamic proxies also used, as previously learnt.)

NOTE: incase both proxies cant be used, like class is final means CGLIB cant be used, and if it doesnt implement interface, jdk dynamic proxy also cant be used. 
If you use such proxies, reason why Interface is required at injection point is, a new class with new name (with Aspect features or other stuff) will be there internally, if you had injected SPECIFICALLY your impl class somewhere, it might fail as its possibly different class. (mainly JDK proxy case I mean, as it could have same interface class but its not related to impl class directly...)


@Aspect // Aspect Annotation: Declares as an aspect class
@Component
public class PropertyChangeTracker {
	@Before("execution(void set*(*))") //Aspect Annotation: Basically filters all methods where any params can be there but func name starts with "set", and void return type
	public void trackChange(){
		//Do something here BEFORE any void set.... method is executed.
	}
}

@Configuration
@EnableAspectJAutoProxy
@ComponentScan(basePackages="com.example.aspects") //Component scan always required right? unless it @Import another config which already has componentscan
public class AspectConfig {}

@Configuration
@Import(AspectConfig.class) //NOW EVERY SINGLE BEAN, regardless if declared inside this config or not, IF INJECTED, IT WILL BE SCANNED BY ASPECT FOR A MATCHING METHOD, and DOES ACTION IF REQUIRED!
public class MainConfig{
@Bean public Cache cacheA(){return new SimpleCache("cacheA");} 
@Bean public Cache cacheB(){return new SimpleCache("cacheB");}
@Bean public Cache cacheC(){return new SimpleCache("cacheC");}
}

@Autowired
@Qualifier("cacheA")
private Cache cache; // Use @Qualifier("cacheA") on @Autowired additionally to specify incase multiple beans with same type but different beanNames (here,its function names as bean names) exist.
...
If cache.setCacheSize(2500); // That aspect expression should catch this and print the log it specifies.


Spring creates proxy bean 'weaving' aspect & target,  implements target's interface like the bean (TAKES AND PROXIES ONLY INTERFACE METHODS, NOT ALL THE ONES IN IMPLEMENTATION).
All calls are routed through proxy interceptor.
The Matching advice for any Aspect's PointCut is executed if condition is true, as interceptor intercepts each incoming calls.
Target bean's method is executed and returns value as expected along with matching aspect functionality also accordingly (Before or After).
			
		   _____Spring_AOP_Proxy____________________________________
incoming	   |  _____________________	 _______________________   |
-------------------|->| Method Interceptor|----->| SimpleCache (target)|   |
<------------------|--|___________________|<-----|_____________________|   |
outgoing return    |__________^__|______________________________|__________|
			      |  |				|  |
		     _________|__v_________________	   _____v__v_____________
		    |PropertyChangeTracker(Aspect) |	   |<<interface>> Cache |   (Spring AOP Proxy and SimpleCache both implement same interface)
		    |______________________________|	   |____________________|



NOTE: Only methods declared in the interface Cache are proxied.
If your implementation class SimpleCache has an extra set... method not in the interface, the aspect will not be applied to that method.
The aspect will work on the other set... methods that are declared in the interface.

(But in CGLIB where interfaces arent declared to be implemented, if subclass is used, then this problem WONT BE THERE. But if interface it implements and has to be inejcted as interface type, dynamic proxy is used as default and this problem will be there.)


@Aspect
@Component
public class PropertyChangeTracker {
	@Before("execution(void set*(*))")
	public void trackChange(JoinPoint point) //Autoinjected
	{
		String methodName = point.getSignature().getName(); //gets method name of the JoinPoint, aka method call.
		Object paramValue = point.getArgs()[0];		    //gets method param values of same call.
		String beanName = point.getTarget();		    //Gets Bean name of the non-proxied original bean.
	}
}


Common Pointcut Designator:
execution( <method pattern> ) - matches method
Can also CHAIN TOGETHER to create composite pointcuts using && , || and ! (not).
eg: execution(<pattern1>) || execution(<pattern2>)

<method pattern> = [Modifiers] ReturnType [ClassType] MethodName (Arguments) [throws ExceptionType]

Wildcard *  matches once (returntype, package, class, method name, argument)
Wildcard .. matches zero or more (arguments or packages)

For Example, Incase of : execution(@javax.annotation.security.RolesAllowed * rewards.restaurant.*Service.find*(..))

execution    ( @javax.annotation.security.RolesAllowed      *        rewards.restaurant .  *Service  .  find*     (..)         )
[designator]   [annotation]                            [returntype]  [package]		   [class]	[method]  [arguments]

Examples:
* execution(void send*(rewards.Dining)) - Any method, with name starting with "send" that takes a single Dining type parameter with void return type. Note: IF fully qualified type is mentioned, just ensure the single method param is of Dining type from reward PACKAGE ONLY.
* execution(* send(*)) - Any method called send which takes A SINGLE PARAMETER! (* DOES NOT MEAN MULTIPLE PARAMS LIKE REGEX)
* execution(* send(int,..)) - Any method called send whose first parameter is an int type, and 0 OR more parameters may follow.
* execution(void example.MessageServiceImpl.*(..)) - Any void method in the MessageServiceImpl class and in MOST CASES subclass object method access also triggers this.
  [HUGE DOUBT: Please refer foot NOTES for the massive explanation.]
* execution(void example.MessageService.send(*)) - ANY METHOD from class implementing MessageService INTERFACE WILL TRIGGER by this exp.

Note: you cant start a expression phrase with '..' like atleast '*..' is required Like expression(* ..restaurant.*.*(..)) IS WRONG!!!
Instead add a * just before .. to make it legal.


Advice TYPES: -

Before: In this @Before type of Aspect Advice, if an EXCEPTION is thrown, YOU CAN PREVENT THE TARGET METHOD FROM BEING EXECUTED! (useful security feature)

The other types of Aspect annotations available are:
@Before — before method execution
@After — after method execution (always executes)

@AfterReturning — after successful return

Eg: @AfterReturning(
    value = "execution(* rewards.internal.*.*(..))",
    returning = "result"
)
    public void afterReturningAdvice(JoinPoint joinPoint, ReturnType result) {}

WARNING: APART FROM MATCHING METHOD's RETURN TYPE in expression, ASPECT ALSO WONT BE TRIGGERED IF THE PARAMETER pointed to by 'returning' in annotation, of this advice method parameter, IS NOT OF THE SAME RETURNTYPE AS THE METHOD MATCHED.
Also, the 'returning' variable name specified in annotation should EXACTLY match a variable name in this advice method ELSE RUNTIME EXCEPTION WILL OCCUR. Just that if type of that variable in this above advice method param is different means method wont be matched DESPITE EXPRESSION DOES MATCH OR NOT.


@AfterThrowing — after (only if) exception thrown. Remember, THIS DOES NOT PREVENT THE ORIGINAL EXCEPTION FROM BEING THROWN! (But you can instead throw a new exception inside this method if you want a NEW MORE ELEGANT EXCEPTION INSTEAD OF THE ONE that was originally thrown.)

Eg: @AfterThrowing(
    value = "execution(* rewards.internal.*.*(..))",
    throwing = "ex"
)
    public void afterThrowingAdvice(JoinPoint joinPoint, Exception ex) {} // Similar to above example, here also the Exception type mentioned HAS TO BE MATCHED along with the expression for this method to be executed. (CAN ALSO BE A SUBTYPE OF THE MENTIONED EXCEPTION OFCOURSE)


@Around - This annotation, UNLIKE the above ones, DOES NOT HAVE THAT 'other than exception, return type also has to match'  condition, so only filter expression matters.
	  Return type of below method CAN be the specific type or Object also (TESTED, no issue). Just ensure you do proper typecasting, and RETURN PROPER COMPATIBLE VALUE.
	  When method is kept as void instead, VALUE RETURNED BY ORIGINAL METHOD BECOMES NULL!!! (printed this after method call line - "THE SECTION OF CHANGE IS OVER: null")

	  YES, WHAT VALUE YOU RETURN HERE WILL BE RECEIVED BY ORIGINAL METHOD CALL (and null, if this method is void)
	  AND if .proceed() is NOT called, then the ORIGINAL METHOD CALL DOESNT EVEN HAPPEN!!! (TESTED THIS, the before and after print statements were printed consecutively with NO 
	  "RandomClass.randomMethod() was called" in between those prints)

@Around(value="execution(@java.lang.Deprecated String rewards.internal.RandomClass.*(..))")
public String afterRandomMethod(ProceedingJoinPoint pjp) throws Throwable {         	     //throws is MANDATORY as proceed() method NEEDS THIS regardless of what method matches.
     System.out.println("Aspect triggered before randomMethod!");
     String returnedValue = (String)pjp.proceed();					     // If this line isn't called, original method call itself DOESNT HAPPEN!
     System.out.println("Aspect triggered after randomMethod! : "+returnedValue);
     return "DUMMY";									     //THIS VALUE WILL BE RECEIVED BY THE CALLING METHOD INSTEAD!!!
}

Output:
RewardNetworkImpl.rewardAccountFor() was called & Started
Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!
Aspect triggered after randomMethod! : RandomClass
THE SECTION OF CHANGE IS OVER


Limitations of Aspect advice: -
* ONLY WORKS FOR Non-PRIVATE METHODS
* Can only apply aspects to methods of SPRING MANAGED BEANS.
* IMPORTANT NOTE: IF in (say) RandomClass which is a spring bean/component, if randomMethod made another call to randomMethod2 OF THE SAME Component/Bean,
		  then randomMethod2 WILL NOT BE EXECUTED ON THE PROXIED BEAN AND HENCE, IT WONT TRIGGER ASPECT METHOD for that or any method calls inside it OF SAME BEAN!!!
		  But if you inject and CALL A NEW BEAN's method internally OTHER THAN THIS ONE, that would be proxyied and ASPECT WILL BE TRIGGERED accordingly (nested way as you expect).
		  		  
[See Notes section for detailed outputs]


Regarding the JUnit testing: -

Yes, @SpringBootTest is the equivalent APPROXIMATELY of all these plus maybe more: @ExtendWith(SpringExtension.class), @ContextConfiguration, @EnableAutoConfiguration,@TestPropertySource(optional, just like @PropertySource), @WebAppConfiguration — (optional, if you want a web environment).

@EnableAutoConfiguration - Optional. It enables Spring Boot’s auto-configuration, but if your config class already sets up everything, you may not need it.
In Spring Boot tests, it’s often included for convenience, but not strictly required if your context is fully defined.

Eg: Assume spring.datasource.driver-class-name/url/username/password all this is in a included properties file, and PostgreSQL JDBC driver JAR is in classpath.
    Then, If you used @Autowired to inject DataSource and you did'nt have a bean declared, This annotation WILL CREATE ONE IF THESE 2 ABOVE CONDITIONS ARE IN PLACE.

Same way, for autoconfiguring ObjectMapper as a bean (if org.fasterxml.jackson dependency is there), and EntityManagerFactor bean, if spring-boot-starter-data-jpa is there, etc.,
All such things this annotation may take care of, if the properties are in place (if any required).



JUnit 5 : -

JUnit5 is the default version from Springboot 2.6, and was a major feature of Spring 5.3
Requires Java 8+ Runtime.

Components oof JUnit: -
* JUnit Platform - Foundation for launching test frameworks on the JVM.
* JUnit Jupiter - An extension model for writing tests and extensions in JUnit5
* JUnit Vintage - A TestEngine for running JUnit 3 & 4 tests on the Platform. (for older JUnit tests execution)

Annotations NAME-CHANGED from JUnit 4 changed to JUnit 5:
@Before		==> @BeforeEach
@BeforeClass	==> @BeforeAll
@After		==> @AfterEach
@AfterClass	==> @AfterAll
@Ignore		==> @Disabled

(@DisplayName, @Nested, @ParameterizedTest , etc. are NEW annotations in JUnit5)

Note: It's very EASY to MIX AND MATCH JUnit5 and OLDER JUnit annotations, IT WONT WORK!!! Please check if ALL annotations are FROM org.junit.jupiter...

Diff between:
Stub: Provides fixed mockedresponses, no verification.
Mock: Provides responses and verifies interactions (can set expected number of calls done, how many arguments, etc. and verify this).

Difference between:

Unit Testing:
Tests one unit of functionality, isolated from the environment (including Spring)
Keeps dependencies minimal, uses simplified alternatives like Stubs and/or Mocks.

Integration Testing:
Tests MULTIPLE units working together, All units should first work individually.
In some kind of appcontext, but out-of-container testing, no need to run full App/Server.
Infra can be scaled down, like using ActiveMQ instead of Commercial messaging servers, using throwaway instances of common databases, etc.


@ExtendWith(SpringExtension.class):
It is a JUnit 5 annotation that tells JUnit to use Spring’s testing support for this test class.
It enables Spring features in your test, like dependency injection (@Autowired), loading the application context, and managing beans.
JUnit4 had Runners (@RunWith,but were unable to use multiple runners), now we have @ExtendWith which can RUN JUnit5 WITH SPRING EXTENSION (support)

@ContextConfiguration(classes={SystemTestConfig.class}):
TestContext framework, defines appcontext for tests, and USES THIS ANNOTATION to specify which configuration class to use for the application context.

FUN FACT: @SpringJUnitConfig(SystemTestConfig.class) IS THE COMBONATION OF THE ABOVE 2 ANNOTATIONS (@ExtendWith(SpringExtension.class) and @ContextConfiguration(classes={SystemTestConfig.class})).
And when either of these config specifications are used, THERE IS NO NEED FOR manually running springboot application .run() to create context (it handles it).


IMPORTANT NOTE: In Normal Springboot application, YOU CANNOT INJECT @Autowired to SPECIFIC PARAMs in a method alone instead of whole method,
like @Autowired on top of constructors, setters, fields, OR EVEN NORMAL methods also its allowed (Not recommended but allowed, called onces after initialization), BUT NOT INDIVIDUAL METHOD PARAMS.

BUT IN JUnit5 ALONE, for a @Test annotated function, I CAN USE @Autowired ON A @Test METHOD PARAMETER(s) to inject as dependencies, as usually these methods DONT have any params.

Another thing to do which INVOLVES JUnit Tests:
@ParameterizedTest
@ValueSource(strings = {"string1","string2","string3"})
void testMethod(String temp){}

The above test is RUN 3 TIMES, EACH TIME WITH ONE VALUE FROM WHAT @ValueSource provides. (basically to avoid repetition this annotation is used)


Multiple @Test methods in JUnit class WILL USE ONLY SAME ApplicationContext, not recreating each time as most beans are IMMUTABLE. So no need new.
 

Including an OVERRIDING/Changed @CONFIGURATION as EMBEDDED in your Test Class for that class alone to use the changed config.class: -

* First, DO NOT SPECIFY you Config.class in the @SpringJUnitConfig or the @ContextConfiguration annotations ON THE TEST CLASS. Just have @SpringJUnitConfig alone with no params.
* Inside the class body, have a static class like below TO IMPORT ANOTHER CONFIGURATION AND OVERRIDE ONE BEAN ALONE
(incase you want a different Bean instance/behaviour FOR RUNNING THIS CLASS ALONE, this can let you specify/redeclare for those one or 2 Beans)

@SpringJUnitConfig  //DO NOT SPECIFY Config class here or you cant override some beans aloe or this test class.
public class SampleJUnitTests {
   ...
   ...
   @Configuration
   @Import(SystemTestConfig.class)
   static class TestConfiguration{
	@Bean public Datasource dataSource(){...} //Now this bean returned will be used ONLY FOR THIS test class if injected, REST of the BEANS ARE TAKEN FROM SystemTestConfig.class
   }
}


@DirtiesContext : INCASE Your code DOES Change Beans/"Dirties" the context, if you annotate this on a @Test method, After this test, NEW Application context will be created.


@TestPropertSources(properties = {"username=foo","password=bar"},
		    locations = "classpath:/specialtestprops.properties")

Above annotation can be annotated on a Tests class TO OVERRIDE OR ADD properties to be used for Tests IN THIS CLASS.
Properties or property file mentioned this was HAVE HIGH PRIORITY and override any other property.


@ActiveProfiles({"jdbc","dev"}) OR spring.profiles.active=jdbc,dev
 - Annotation used on JUnit 5 class to take not just Non-profile-specific beans alone, but ALSO Beans, which are declared with @Profile("jdbc") (and "dev" ones too) on the configuration classes or bean classes (or EVEN ON BEAN METHODS), in the test application context.

Note: By default no profile is activated, there ISNT any default profile/profile name used.


@Sql({"/testfiles/schema.sql","/testfiles/load-data.sql"})   OR   @Sql(scripts="/testfiles/setupBadTransfer.sql")
   -   This annotation can be used on a JUnit5 test class to RUN THESE SQL scripts BEFORE EACH @Test method executions, UNLESS THE @Test method has @Sql specified for it especially, then it follows that annotation(s).
If used on JUnit5 TEST METHOD, it overrides the class level annotation, running the method specific @Sql scripts (by default, BEFORE the @Test execution).

@Sql(scripts="/testfiles/cleanup.sql",
		executionPhase=Sql.ExecutionPhase.AFTER_TEST_METHOD)   -    By default it is executed before, using this EXPLICIT option, it executes AFTER the @Test.

The @Sql annotation also has a config value you can specify:
@Sql(..., config = @SqlConfig(errorMode = ErrorMode.FAIL_ON_ERROR,
						commentPrefix="//", separator="@@") )

ErrorMode config options for @Sql in Spring:

FAIL_ON_ERROR: Stops execution if any SQL statement in the .sql file fails.
CONTINUE_ON_ERROR: Continues executing remaining SQL statements even if one fails.
IGNORE_FAILED_DROPS: Ignores errors from failed DROP statements, but fails on other errors.
DEFAULT: Uses the default error handling (usually same as FAIL_ON_ERROR). TYPICALLY takes @Sql config parameter from class level @Sql, OR DEFAULTS TO FAIL_ON_ERROR. (usually its fail on error)

Other config internal options (SQL syntax control):
commentPrefix: Marks the start of a comment in SQL scripts (e.g. -- )
separator: Defines the statement separator in SQL scripts (e.g. ; )


JDBC Template: -

Templates in Spring like: JdbcTemplate, JmsTemplate, RestTemplate, WebServiceTemplate.
They hide away boiler plate code, And can specify other details later if needed. All exception handling, resources are handled properly.

int count = jdbcTemplate.queryForObject("SELECT COUNT(*) FROM CUSTOMER", Integer.class); //HANDLES EVERYTHING ELSE!

// Note: queryForInt() and queryForLong() are deprecated and removed since Spring 4.2

It also allows CALLBACKS to be used to add the important implementation logic alone.
Eg: The logic to map the SQL row values into creating an object TO HOLD THOSE VALUES can be sent as a callback (RowMapper).

List<Customer> results = jdbcTemplate.query(someSqlStatementString,
    new RowMapper<Customer>(){
	public Customer mapRow(ResultSet rs, int row) throws SQLException {
	    //map the current row elements to Customer obj. int row will have value 0 if its first element, then 1,.. so on, use only if needed.
	    //The resultset POINTER WILL BE MOVED AUTOMATICALLY EACH TIME IN SEQUENCE, like mapRow() call is done INSIDE while(rs.next()){} !
	}
});

NOTE: while int row supplied by Spring starts from 0 as index, 
      rs.getString() TAKES INT PARAM FROM 1, NOT 0 !!! (That's because its part of old jdbc version while this int row is supplied by spring so its new)


JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // NEEDS Datasource as constructor param.
// JdbcTemplate class IS THREADSAFE AFTER CONSTRUCTION!
// So dont need to create one for each thread. Can be used anywhere even tests.

JdbcTemplate can query for the usual Simple types (int,long,String,Date), Generic Maps, Domain Objects

Query With Bind Variables:
jdbcTemplate.queryForObject("SELECT count(*) from person WHERE age > ? AND nationality = ?",
	Integer.class, 12, "Indian");

//BELOW METHOD update() IS USED FOR INSERT OPERATIONS ALSO!!!
jdbcTemplate.update("INSERT INTO NAME (first_name,last_name) VALUES (?,?)",
	"Matthew","Jonathan G");

jdbcTemplate.update("UPDATE NAME SET last_name=?","John")

jdbcTemplate.queryForMap("SELECT * FROM person WHERE id=?", 1) - Used to map query RETURNING ONE ROW into 1 Map<String, Object> object as return value.
jdbcTemplate.queryForList("SELECT * FROM person") - Similar as above except returns multiple Maps as List<Map<String, Object>>

NOTE: Depending on the DB driver, the case of the column name (aka Key) in the map can vary, cant say if it will be in upper or lower case for sure. (But Spring course example shows in uppercase depiction)

Domain Object Queries (Mapping of resultset to domain pojo objects using callback approach) :
* public interface RowMapper<T> {
	T mapRow(ResultSet rs, int row) throws SQLException;
}

Eg: 

jdbcTemplate.queryForObject("SELECT first_name,last_name FROM person WHERE id=?",
				(rs,rowNum)-> new Person( rs.getString("first_name"),rs.getString("last_name") ),
				idValue);  // Returns pojo object. and YES, Id value comes AFTER rowmapper lambda passed.
    
FOR MULTIPLE OBJECTS To be returned, use .query() method instead, REMOVE the idValue param supplied as syntax related changes.
And it will return List<PojoObject> in this case.

* public interface ResultSetExtractor<T> {
	T extractData(ResultSet rs) throws SQLException, DataAccessException;
}

Eg: Same as .query() method syntax above, EXCEPT that LAMBDA NEEDS TYPE CASTING (as THERE IS AMBIGUITY due to other ResultSet variations of .query() method, but RowMapper doesn't have this issue)

jdbcTemplate.query(
	"SELECT ID,NAME FROM order o WHERE confirmation_id=?",
	(ResultSetExtractor<Order>) (rs) -> {
		// THIS LAMBDA RUNS ONLY ONE TIME! So MANUALLY iterate and map rs to return 1 object of type Order.
		// Get the rs column values using rs.getLong("ID"), rs.getString("NAME") inside while(rs.next()){}
	},
	confirmationIdValue	// Same as rowmapper syntax, after lambda only the '?' param values are supplied
)

RowCallbackHandler is similar to RowMapper, but IT DOESNT RETURN ANYTHING. Its just for processing and not returning some obj.


Exception Handling: -

SQLException, like all other checked exceptions MAKE TIGHT-COUPLING of methods AS ALL INTERMEDIATE METHODS NEED TO DECLARE TO THROW such exceptions,
Incase you want to handle the exception at a higher level, so all method signatures have to handle this correctly, a nuisance.

DataAccessException is provided by Spring, an UNCHECKED HEIRARCHY of Exceptions which WRAPS SQLException by catching it,
giving A MORE MEANINGFUL EXCEPTION TYPE THROWN.

Like instead of SQLException, it can be wrapped into some meaningful unchecked exceptions like: 
BadSqlGrammarException (if there is sql syntax error),
DataAccessResourceFailureException, CleanupFailureDataAccessException, OptimisticLockingFailureException, DataIntegrityViolationException.









---------------------------------------------------
==================================================
NOTES: -
* Springboot scans and takes default/no param constructor if multiple are there, one is there means it takes that constructor. Else it raises error.

* Mix and matching field and constructor injection in a component is fine,  but remember that in test if I create by constructor,
  Now field injection ALONE WILL BE NULL, and if you forget this fact, youll keep testing how all others aren't null except that obj.

* Usually SpringApplication.run() will have the Configuration file it uses, now any AspectConfig or something you have to add means, just Import AspectConfig into that main config.

* WARNING ABOUT ASPECT (AOP): If Spring proxy-based AOP	is used, then Injecting bean from Spring only will work as expected with aspects, NOT with objects created with "new" keyword. (You already know this)
  I thought It was malfunctioning, BUT I TESTED AND IT's right, see below output and observe how if new is used t create the class obj whose method should be observed by aspect, then no it wont work.

RewardNetworkImpl.rewardAccountFor() was called & Started
Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!
THE SECTION OF CHANGE IS OVER
THIS is the test where RewardNetwork bean was autoinjected/initialized, so spring managed RandomClass.

RewardNetworkImpl.rewardAccountFor() was called & Started
RandomClass.randomMethod() was called!
THE SECTION OF CHANGE IS OVER
This is the test with OBJ manually created using new and initalized by constructor.
-----------------------------

* I EXECUTED AND VERIFIED THAT : NO, ITS NOT MANDATORY TO IMPORT ALL CONFIG FILES TO THE MAIN CONFIG FILE (which you use for SpringApplication.run()).
  				 Instead, ensure in the @ComponentScan (Can be in main config or imported config, 2 annotations are just additive, so no issues if you see double),
				 That you add the package where config java files are there additionally to be scanned (INCASE IT ALREADY ISNT covered). Eg: @ComponentScan(basePackages = {"rewards.internal","config"})
				 Then you will see even without @Import(AspectConfig.class), functionality works as expected AS LONG AS config file is in package(s) mentioned in ComponentScan, AND @Configuration annotation is on it.

----------------------------------------------------------------------

* I TESTED if RandomSubClass obj executing its parent's method also triggers aspect, and see if overrided that method, that has an effect. (by mixing datatypes ofcourse.)

YES, I injected RandomSubClass obj then used it to access it's superclass method randomMethod() directly, ASPECT TRIGGER WORKED JUST LIKE AS IF I INJECTED AND RAN USING RandomClass obj!
(Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!)

Then I ensured I OVERRIDED THE RandomClass method with RandomSubClass version of the method, IT STILL TRIGGERED THE ASPECT!
I even tried removing @Component from RandomClass incase, and FIRST TRIED Injection points as RandomClass, it works same! THEN TRIED WITH RandomSubClass as type expected at injection, STILL WORKS!
Similarly I tried making RandomClass as interface, SAME WAY IT WORKS, SUBCLASS METHOD TRIGGERS THE ASPECT!

(Aspect triggered before randomMethod!
RandomSubClass.randomMethod() was called!)

BUT THERE IS ONE CRITERIA WHERE ASPECT ISNT EXECUTED. IF the randomMethod declaration is REMOVED FROM THE SUPERCLASS (for interface its impossible obviously), AND ONLY IN SUBCLASS YOU HAVE THAT METHOD (Injection points expect RandomSubClass as then only it will compile since randomClass.randomMethod() WONT BE AVAILABLE IN THIS SITUATION AS WE REMOVED IT), Then FINALLY,
ASPECT DOES NOT RUN!!! This shows as long as superclass or interface has the method, then its all fine, even if you override it in subclass, aspect filter will catch it. See below output:

RewardNetworkImpl.rewardAccountFor() was called & Started
RandomSubClass.randomMethod() was called!
THE SECTION OF CHANGE IS OVER
THIS is the test where RewardNetwork bean was autoinjected/initialized, so spring managed RandomClass.


The aspect PointCut expression used for above is: @Before("execution(void rewards.internal.RandomClass.*(..))").
And OBVIOUSLY creating new Object in these cases, Aspect WONT WORK/TRIGGER.


Second part, i tried Experimenting with annotation specifications also, like @Before("execution(@java.lang.Deprecated void rewards.internal.RandomClass.*(..))") with same classes.
After annotating @Deprecated on method in RandomClass, and INJECTION POINTS ARE OF RandomClass, ASPECT IS TRIGGERED.

But while trying REMOVING @Component on RandomClass, and forcing it to inject RandomSubClass to RandomClass injection points, IT DOESNT RUN ASPECT! (It has overrided method)
Injection points were kept as RandomClass, then RandomSubClass, still NO LUCK!!!

BUT if RandomSubClass BODY IS EMPTY COMPLETELY, THEN NO METHOD IN SUBCLASS TO OVERRIDE, and IT WORKS AGAIN!

RewardNetworkImpl.rewardAccountFor() was called & Started
Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!


RewardNetworkImpl.rewardAccountFor() was called & Started
RandomSubClass.randomMethod() was called!
THE SECTION OF CHANGE IS OVER


MORAL OF THE STORY: Normally, subclass methods whther overriding or not, as long as the superclass/interface declares same signature method, THEN IT WILL TRIGGER ASPECT HOWEVER YOU INJECT IT!

BUT IF YOU HAVE SPECIFIED ANNOTATION in the filter PointCut of the aspect, THEN BEHAVIOUR IS CHANGING. EVEN IF YOU USE SUBCLASS OBJECT, If subclass object injected, is used to
ACCESSING THE SUPER CLASS METHOD (SubClass doesnt have that method), THEN IT WORKS SAME!
BUT IF YOU OVERRIDE THE METHOD IN SUBCLASS, THEN ASPECT ISNT TRIGGERED IF YOU INJECT THE SUBCLASS OBJECT! (Regardless of injection point type) In this annotation specified CASE ALONE!

-----------------------------------------------------------------------------
For Aspect triggering regarding bean internal method calls to its own other methods...(Assuming methods a() and b() both match some aspect PointCut conditions)

If I do intentional separate calls in code, then clearly aspect is triggered:
Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!
RandomClass.randomMethod2() was called!
Aspect triggered after randomMethod! : RandomClassmethod2
THE SECTION OF CHANGE IS OVER: DUMMY
Aspect triggered before randomMethod!
RandomClass.randomMethod2() was called!
Aspect triggered after randomMethod! : RandomClassmethod2
THE 2nd SECTION OF CHANGE IS OVER: DUMMY


But if I do "return randomMethod2();" inside randomMethod(), then see output where Aspect WAS NOT TRIGGERED because now the internal calls after aspect triggering ARE HAPPENING ON THE REAL BEAN ITSELF!

Aspect triggered before randomMethod!
RandomClass.randomMethod() was called!
RandomClass.randomMethod2() was called!
Aspect triggered after randomMethod! : RandomClassmethod2
THE SECTION OF CHANGE IS OVER: DUMMY


But if I attempt to call ANOTHER BEAN's (RandomSubClass in this case) method internally of that original method call body, THEN IF ASPECT filter is matched then YES IT WILL BE TRIGGERED AS USUAL! So as expected, nested way of Aspect triggering and ending happens (as I use @Around method with more proper labelled output dynamically using PointJoinPoint methods to print function and bean names)

Aspect triggered before rewards.internal.RandomClass@9e2ad91.randomMethod!
RandomClass.randomMethod() was called!
RandomClass.randomMethod2() was called!
Aspect triggered before rewards.internal.RandomSubClass@1aa6e3c0.randomMethod!
RandomSubClass.randomMethod() was called!
Aspect triggered after rewards.internal.RandomSubClass@1aa6e3c0.randomMethod! : Subclass
Aspect triggered after rewards.internal.RandomClass@9e2ad91.randomMethod! : DUMMY
THE SECTION OF CHANGE IS OVER: DUMMY


-------------------------------------------------------------------------------------------

HOW TO EXECUTE: I moved to lab folder in cmd and usually to run tests alone I used: mvn test -pl 22-aop
BUT FOR ASPECT TESTING, the LOGGER STATEMENT WERE MISSING, I SEARCHED FOR CODE ISSUES and all,

FINALLY PROBLEM WAS HOW I EXECUTED UNIT TEST OF 1 Test ALONE : mvn -pl 22-aop -Dtest=LoggingAspectTests test [THIS WORKS!!!]

Also, anything wrong with JoinPoint expression (like @Before("execution(* *(..))") IS NOT CORRECT) , it will THROW EXCEPTION AS IF beanInitialization failed for the Aspect class.
SO ENSURE TO CHECK IT's correct or not.
